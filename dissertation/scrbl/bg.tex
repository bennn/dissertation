\documentclass[ twoside,open=right,titlepage,numbers=noenddot,headinclude,%1headlines,% letterpaper a4paper
                footinclude=true,cleardoublepage=empty,abstract=off,
                BCOR=5mm,paper=a4,fontsize=11pt,%11pt,a4paper,%
                ngerman,american,%
                parts,pdfspacing]{scrreprt}
%% from http://tex.stackexchange.com/a/39418
\makeatletter
\newcommand{\dontusepackage}[2][]{%
  \@namedef{ver@#2.sty}{9999/12/31}%
  \@namedef{opt@#2.sty}{#1}}
\makeatother

%% Disable Scribble's default TOC configuration
\dontusepackage{tocstyle}
\newcommand{\usetocstyle}[1]{\relax}
\newcommand{\packageGraphicx}{\usepackage{graphicx}}
\newcommand{\packageHyperref}{\usepackage{hyperref}}
\newcommand{\renewrmdefault}{\renewcommand{\rmdefault}{ptm}}
\newcommand{\packageRelsize}{\usepackage{relsize}}
% amsmath is required for the combination of {mathabx,
% wasysym, newtxmath} to work. Otherwise, newtxmath
% would load amsmath *after* mathabx and wasysym,
% causing command redefinition issues.
\newcommand{\packageAmsmath}{\usepackage{amsmath}}
\newcommand{\packageMathabx}{\usepackage{mathabx}}
% Avoid conflicts between "mathabx" and "wasysym",
% and between "wasysym" integrals and "amsmath" integrals (iint).
\newcommand{\packageWasysym}{
  \let\leftmoon\relax \let\rightmoon\relax \let\fullmoon\relax \let\newmoon\relax \let\diameter\relax
  \usepackage[nointegrals]{wasysym}}
% Both newtxmath and mathabx define the \widering command.
% The only reason we choose the newtxmath version is that
% acmart.cls is also using the one from newtxmath.
\newcommand{\packageTxfonts}{
  \let\widering\relax
  \usepackage{newtxmath}}
\newcommand{\packageTextcomp}{\usepackage{textcomp}}
\newcommand{\packageFramed}{\usepackage{framed}}
\newcommand{\packageHyphenat}{\usepackage[htt]{hyphenat}}
\newcommand{\packageColor}{\usepackage[usenames,dvipsnames]{color}}
\newcommand{\doHypersetup}{\hypersetup{bookmarks=true,bookmarksopen=true,bookmarksnumbered=true}}
\newcommand{\packageTocstyle}{\IfFileExists{tocstyle.sty}{\usepackage{tocstyle}\usetocstyle{standard}}{}}
\newcommand{\packageCJK}{\IfFileExists{CJK.sty}{\usepackage{CJK}}{}}
\renewcommand{\packageGraphicx}{}
\renewcommand{\packageHyperref}{}
\renewcommand{\renewrmdefault}{}
\renewcommand{\packageRelsize}{}
\renewcommand{\packageMathabx}{}
\renewcommand{\packageWasysym}{}
\renewcommand{\packageTxfonts}{}
\renewcommand{\packageTextcomp}{}
\renewcommand{\packageFramed}{}
\renewcommand{\packageHyphenat}{}
\renewcommand{\packageColor}{}
\renewcommand{\doHypersetup}{}
\renewcommand{\packageTocstyle}{}
\renewcommand{\packageCJK}{}
% This is the default style configuration for Scribble-generated Latex

\packageGraphicx
\packageHyperref
\renewrmdefault
\packageRelsize
\packageAmsmath
\packageMathabx
\packageWasysym
\packageTxfonts
\packageTextcomp
\packageFramed
\packageHyphenat
\packageColor
\doHypersetup
\packageTocstyle
\packageCJK


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Configuration that is especially meant to be overridden:

% Inserted before every ``chapter'', useful for starting each one on a new page:
\newcommand{\sectionNewpage}{}
% Inserted before every book ``part''
\newcommand{\partNewpage}{\sectionNewpage}

% Hooks for actions within the `document' environment:
\newcommand{\preDoc}{}
\newcommand{\postDoc}{}

% Generated by `secref'; first arg is section number, second is section title:
\newcommand{\BookRef}[2]{\emph{#2}}
\newcommand{\ChapRef}[2]{\SecRef{#1}{#2}}
\newcommand{\SecRef}[2]{section~#1}
\newcommand{\PartRef}[2]{part~#1}
% Generated by `Secref':
\newcommand{\BookRefUC}[2]{\BookRef{#1}{#2}}
\newcommand{\ChapRefUC}[2]{\SecRefUC{#1}{#2}}
\newcommand{\SecRefUC}[2]{Section~#1}
\newcommand{\PartRefUC}[2]{Part~#1}

% Variants of the above with a label for an internal reference:
\newcommand{\BookRefLocal}[3]{\hyperref[#1]{\BookRef{#2}{#3}}}
\newcommand{\ChapRefLocal}[3]{\hyperref[#1]{\ChapRef{#2}{#3}}}
\newcommand{\SecRefLocal}[3]{\hyperref[#1]{\SecRef{#2}{#3}}}
\newcommand{\PartRefLocal}[3]{\hyperref[#1]{\PartRef{#2}{#3}}}
\newcommand{\BookRefLocalUC}[3]{\hyperref[#1]{\BookRefUC{#2}{#3}}}
\newcommand{\ChapRefLocalUC}[3]{\hyperref[#1]{\ChapRefUC{#2}{#3}}}
\newcommand{\SecRefLocalUC}[3]{\hyperref[#1]{\SecRefUC{#2}{#3}}}
\newcommand{\PartRefLocalUC}[3]{\hyperref[#1]{\PartRefUC{#2}{#3}}}

% Variants of the above with a section number is empty (i.e., UnNumbered):
\newcommand{\BookRefUN}[1]{\BookRef{}{#1}}
\newcommand{\ChapRefUN}[1]{\SecRefUN{#1}}
\newcommand{\SecRefUN}[1]{``#1''}
\newcommand{\PartRefUN}[1]{\SecRefUN{#1}}
\newcommand{\BookRefUCUN}[1]{\BookRefUN{#1}}
\newcommand{\ChapRefUCUN}[1]{\ChapRefUN{#1}}
\newcommand{\SecRefUCUN}[1]{\SecRefUN{#1}}
\newcommand{\PartRefUCUN}[1]{\PartRefUN{#1}}

\newcommand{\BookRefLocalUN}[2]{\hyperref[#1]{\BookRefUN{#2}}}
\newcommand{\ChapRefLocalUN}[2]{\SecRefLocalUN{#1}{#2}}
\newcommand{\SecRefLocalUN}[2]{\hyperref[#1]{\SecRefUN{#2}}}
\newcommand{\PartRefLocalUN}[2]{\SecRefLocalUN{#1}{#2}}
\newcommand{\BookRefLocalUCUN}[2]{\BookRefLocalUN{#1}{#2}}
\newcommand{\ChapRefLocalUCUN}[2]{\ChapRefLocalUN{#1}{#2}}
\newcommand{\SecRefLocalUCUN}[2]{\SecRefLocalUN{#1}{#2}}
\newcommand{\PartRefLocalUCUN}[2]{\PartRefLocalUN{#1}{#2}}

\newcommand{\SectionNumberLink}[2]{\hyperref[#1]{#2}}

% Enabled with a 'enable-index-merge part style property. This default
% implementation isn't good enough, because the argument is a
% comma-separated sequence of labels:
\newcommand{\Smanypageref}[1]{\pageref{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Fonts

% Font commands used by generated text:
\newcommand{\Scribtexttt}[1]{{\texttt{#1}}}
\newcommand{\textsub}[1]{$_{\hbox{\textsmaller{#1}}}$}
\newcommand{\textsuper}[1]{$^{\hbox{\textsmaller{#1}}}$}
\newcommand{\intextcolor}[2]{\textcolor{#1}{#2}}
\newcommand{\intextrgbcolor}[2]{\textcolor[rgb]{#1}{#2}}
\newcommand{\incolorbox}[2]{{\fboxrule=0pt\fboxsep=0pt\protect\colorbox{#1}{#2}}}
\newcommand{\inrgbcolorbox}[2]{{\fboxrule=0pt\fboxsep=0pt\protect\colorbox[rgb]{#1}{#2}}}
\newcommand{\plainlink}[1]{#1}
\newcommand{\techoutside}[1]{#1}
\newcommand{\techinside}[1]{#1}
\newcommand{\badlink}[1]{#1}
\newcommand{\indexlink}[1]{#1}
\newcommand{\noborder}[1]{#1}
\newcommand{\Smaller}[1]{\textsmaller{#1}}
\newcommand{\Larger}[1]{\textlarger{#1}}
\newcommand{\planetName}[1]{PLane\hspace{-0.1ex}T}
\newcommand{\slant}[1]{{\textsl{#1}}}

% Used for <, >, and | in tt mode. For some fonts and installations,
% there seems to be an encoding issue, so pick T1 explicitly:
\newcommand{\Stttextmore}{{\fontencoding{T1}\selectfont>}}
\newcommand{\Stttextless}{{\fontencoding{T1}\selectfont<}}
\newcommand{\Stttextbar}{{\fontencoding{T1}\selectfont|}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tables

% The `stabular' environment seems to be the lesser of evils among 
%  page-breaking table environments (and we've made a copy as ``pltstabular'
%  to make sure that it doesn't change).

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\message{pltstabular is a modification of stabular}
%% A renamed version of:
%% stabular.sty
%% Copyright 1998 Sigitas Tolu\v sis
%% VTeX Ltd., Akademijos 4, Vilnius, Lithuania
%% e-mail sigitas@vtex.lt
%% http://www.vtex.lt/tex/download/macros/
%%
% This program can redistributed and/or modified under the terms
% of the LaTeX Project Public License Distributed from CTAN
% archives in directory macros/latex/base/lppl.txt; either
% version 1 of the License, or (at your option) any later version.
%
% PURPOSE:   Improve tabular environment.
%
% SHORT DESCRIPTION:
%
% Changed internal commands: \@mkpream, \@addamp, \@xhline
%
% Provides new commands in tabular (used after command \\):
% \emptyrow[#1] 
% -------------
%    Adds empty row, #1 - height of the row 
%
% \tabrow{#1}[#2] 
% ---------------
%    Adds row of natural height: #1\\[#2]
%
% Provides new environments: pltstabular and pltstabular* 
%                            --------     ---------
%            One more multi-page version of tabular
%
%
\def\empty@finalstrut#1{%
  \unskip\ifhmode\nobreak\fi\vrule\@width\z@\@height\z@\@depth\z@}
\def\no@strut{\global\setbox\@arstrutbox\hbox{%
    \vrule \@height\z@
           \@depth\z@
           \@width\z@}%
    \gdef\@endpbox{\empty@finalstrut\@arstrutbox\par\egroup\hfil}%
}%
\def\yes@strut{\global\setbox\@arstrutbox\hbox{%
    \vrule \@height\arraystretch \ht\strutbox
           \@depth\arraystretch \dp\strutbox
           \@width\z@}%
    \gdef\@endpbox{\@finalstrut\@arstrutbox\par\egroup\hfil}%
}%
\def\@mkpream#1{\@firstamptrue\@lastchclass6
  \let\@preamble\@empty\def\empty@preamble{\add@ins}%
  \let\protect\@unexpandable@protect
  \let\@sharp\relax\let\add@ins\relax
  \let\@startpbox\relax\let\@endpbox\relax
  \@expast{#1}%
  \expandafter\@tfor \expandafter
    \@nextchar \expandafter:\expandafter=\reserved@a\do
       {\@testpach\@nextchar
    \ifcase \@chclass \@classz \or \@classi \or \@classii \or \@classiii
      \or \@classiv \or\@classv \fi\@lastchclass\@chclass}%
  \ifcase \@lastchclass \@acol
      \or \or \@preamerr \@ne\or \@preamerr \tw@\or \or \@acol \fi}
\def\@addamp{%
  \if@firstamp
    \@firstampfalse
    \edef\empty@preamble{\add@ins}%
  \else
    \edef\@preamble{\@preamble &}%
    \edef\empty@preamble{\expandafter\noexpand\empty@preamble &\add@ins}%
  \fi}
\newif\iftw@hlines \tw@hlinesfalse
\def\@xhline{\ifx\reserved@a\hline
               \tw@hlinestrue
             \else\ifx\reserved@a\Hline
               \tw@hlinestrue
             \else
               \tw@hlinesfalse
             \fi\fi
      \iftw@hlines
        \aftergroup\do@after
      \fi
      \ifnum0=`{\fi}%
}
\def\do@after{\emptyrow[\the\doublerulesep]}
\def\emptyrow{\noalign\bgroup\@ifnextchar[\@emptyrow{\@emptyrow[\z@]}}
\def\@emptyrow[#1]{\no@strut\gdef\add@ins{\vrule \@height\z@ \@depth#1 \@width\z@}\egroup%
\empty@preamble\\
\noalign{\yes@strut\gdef\add@ins{\vrule \@height\z@ \@depth\z@ \@width\z@}}%
}
\def\tabrow#1{\noalign\bgroup\@ifnextchar[{\@tabrow{#1}}{\@tabrow{#1}[]}}
\def\@tabrow#1[#2]{\no@strut\egroup#1\ifx.#2.\\\else\\[#2]\fi\noalign{\yes@strut}}
%
\def\endpltstabular{\crcr\egroup\egroup \egroup}
\expandafter \let \csname endpltstabular*\endcsname = \endpltstabular
\def\pltstabular{\let\@halignto\@empty\@pltstabular}
\@namedef{pltstabular*}#1{\def\@halignto{to#1}\@pltstabular}
\def\@pltstabular{\leavevmode \bgroup \let\@acol\@tabacol
   \let\@classz\@tabclassz
   \let\@classiv\@tabclassiv \let\\\@tabularcr\@stabarray}
\def\@stabarray{\m@th\@ifnextchar[\@sarray{\@sarray[c]}}
\def\@sarray[#1]#2{%
  \bgroup
  \setbox\@arstrutbox\hbox{%
    \vrule \@height\arraystretch\ht\strutbox
           \@depth\arraystretch \dp\strutbox
           \@width\z@}%
  \@mkpream{#2}%
  \edef\@preamble{%
    \ialign \noexpand\@halignto
      \bgroup \@arstrut \@preamble \tabskip\z@skip \cr}%
  \let\@startpbox\@@startpbox \let\@endpbox\@@endpbox
  \let\tabularnewline\\%
%    \let\par\@empty
    \let\@sharp##%
    \set@typeset@protect
    \lineskip\z@skip\baselineskip\z@skip
    \@preamble}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatother

\newenvironment{bigtabular}{\begin{pltstabular}}{\end{pltstabular}}
% For the 'boxed table style:
\newcommand{\SBoxedLeft}{\textcolor[rgb]{0.6,0.6,1.0}{\vrule width 3pt\hspace{3pt}}}
% Formerly used to keep the horizontal line for a definition on the same page:
\newcommand{\SEndFirstHead}[0]{ \nopagebreak \\ }
% Corrects weirdness when a table is the first thing in
%  an itemization:
\newcommand{\bigtableinlinecorrect}[0]{~

\vspace{-\baselineskip}\vspace{\parskip}}
% Used to indent the table correctly in an itemization, since that's
%  one of the things stabular gets wrong:
\newlength{\stabLeft}
\newcommand{\bigtableleftpad}{\hspace{\stabLeft}}
\newcommand{\atItemizeStart}[0]{\addtolength{\stabLeft}{\labelsep}
                                \addtolength{\stabLeft}{\labelwidth}}


% For a single-column table in simple environments, it's better to
%  use the `list' environment instead of `stabular'.
\newenvironment{SingleColumn}{\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0pt\rightmargin=0pt%
\itemsep=0pt\parsep=0pt}\item}{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Etc.

% ._ and .__
\newcommand{\Sendabbrev}[1]{#1\@}
\newcommand{\Sendsentence}[1]{\@#1}

% Default style for a nested flow:
\newenvironment{Subflow}{\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0pt\rightmargin=0pt%
\itemsep=0pt}\item}{\end{list}}

% For the 'inset nested-flow style:
\newenvironment{SInsetFlow}{\begin{quote}}{\end{quote}}

% Indent a 'code-inset nested flow:
\newcommand{\SCodePreSkip}{\vskip\abovedisplayskip}
\newcommand{\SCodePostSkip}{\vskip\belowdisplayskip}
\newenvironment{SCodeFlow}{\SCodePreSkip\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=2ex\rightmargin=2ex%
\itemsep=0pt\parsep=0pt}\item}{\end{list}\SCodePostSkip}
\newcommand{\SCodeInsetBox}[1]{\setbox1=\hbox{\hbox{\hspace{2ex}#1\hspace{2ex}}}\vbox{\SCodePreSkip\vtop{\box1\SCodePostSkip}}}

% Inset a 'vertical-inset nested flow:
\newcommand{\SVInsetPreSkip}{\vskip\abovedisplayskip}
\newcommand{\SVInsetPostSkip}{\vskip\belowdisplayskip}
\newenvironment{SVInsetFlow}{\SVInsetPreSkip\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0pt\rightmargin=0pt%
\itemsep=0pt\parsep=0pt}\item}{\end{list}\SVInsetPostSkip}
\newcommand{\SVInsetBox}[1]{\setbox1=\hbox{\hbox{#1}}\vbox{\SCodePreSkip\vtop{\box1\SCodePostSkip}}}

% The 'compact itemization style:
\newenvironment{compact}{\begin{itemize}}{\end{itemize}}
\newcommand{\compactItem}[1]{\item #1}

% The nested-flow style for `centerline':
\newenvironment{SCentered}{\begin{trivlist}\item \centering}{\end{trivlist}}

% The \refpara command corresponds to `margin-note'. The
% refcolumn and refcontent environments also wrap the note,
% because they simplify the CSS side.
\newcommand{\refpara}[1]{\normalmarginpar\marginpar{\raggedright \footnotesize #1}}
\newcommand{\refelem}[1]{\refpara{#1}}
\newenvironment{refcolumn}{}{}
\newenvironment{refcontent}{}{}

\newcommand{\refparaleft}[1]{\reversemarginpar\marginpar{\raggedright \footnotesize #1}}
\newcommand{\refelemleft}[1]{\refparaleft{#1}}
\newenvironment{refcolumnleft}{}{}

% Macros used by `title' and `author':
\newcommand{\titleAndVersionAndAuthors}[3]{\title{#1\\{\normalsize \SVersionBefore{}#2}}\author{#3}\maketitle}
\newcommand{\titleAndVersionAndEmptyAuthors}[3]{\title{#1\\{\normalsize \SVersionBefore{}#2}}#3\maketitle}
\newcommand{\titleAndEmptyVersionAndAuthors}[3]{\title{#1}\author{#3}\maketitle}
\newcommand{\titleAndEmptyVersionAndEmptyAuthors}[3]{\title{#1}\maketitle}
\newcommand{\titleAndVersionAndAuthorsAndShort}[4]{\title[#4]{#1\\{\normalsize \SVersionBefore{}#2}}\author{#3}\maketitle}
\newcommand{\titleAndVersionAndEmptyAuthorsAndShort}[4]{\title[#4]{#1\\{\normalsize \SVersionBefore{}#2}}#3\maketitle}
\newcommand{\titleAndEmptyVersionAndAuthorsAndShort}[4]{\title[#4]{#1}\author{#3}\maketitle}
\newcommand{\titleAndEmptyVersionAndEmptyAuthorsAndShort}[4]{\title[#4]{#1}\maketitle}
\newcommand{\SAuthor}[1]{#1}
\newcommand{\SAuthorSep}[1]{\qquad}
\newcommand{\SVersionBefore}[1]{Version }

% Useful for some styles, such as sigalternate:
\newcommand{\SNumberOfAuthors}[1]{}

\let\SOriginalthesubsection\thesubsection
\let\SOriginalthesubsubsection\thesubsubsection

% sections
\newcommand{\Spart}[2]{\part[#1]{#2}}
\newcommand{\Ssection}[2]{\section[#1]{#2}\let\thesubsection\SOriginalthesubsection}
\newcommand{\Ssubsection}[2]{\subsection[#1]{#2}\let\thesubsubsection\SOriginalthesubsubsection}
\newcommand{\Ssubsubsection}[2]{\subsubsection[#1]{#2}}
\newcommand{\Ssubsubsubsection}[2]{{\bf #2}}
\newcommand{\Ssubsubsubsubsection}[2]{\Ssubsubsubsection{#1}{#2}}

% "star" means unnumbered and not in ToC:
\newcommand{\Spartstar}[1]{\part*{#1}}
\newcommand{\Ssectionstar}[1]{\section*{#1}\renewcommand*\thesubsection{\arabic{subsection}}\setcounter{subsection}{0}}
\newcommand{\Ssubsectionstar}[1]{\subsection*{#1}\renewcommand*\thesubsubsection{\arabic{section}.\arabic{subsubsection}}\setcounter{subsubsection}{0}}
\newcommand{\Ssubsubsectionstar}[1]{\subsubsection*{#1}}
\newcommand{\Ssubsubsubsectionstar}[1]{{\bf #1}}
\newcommand{\Ssubsubsubsubsectionstar}[1]{\Ssubsubsubsectionstar{#1}}

% "starx" means unnumbered but in ToC:
\newcommand{\Spartstarx}[2]{\Spartstar{#2}\phantomsection\addcontentsline{toc}{part}{#1}}
\newcommand{\Ssectionstarx}[2]{\Ssectionstar{#2}\phantomsection\addcontentsline{toc}{section}{#1}}
\newcommand{\Ssubsectionstarx}[2]{\Ssubsectionstar{#2}\phantomsection\addcontentsline{toc}{subsection}{#1}}
\newcommand{\Ssubsubsectionstarx}[2]{\Ssubsubsectionstar{#2}\phantomsection\addcontentsline{toc}{subsubsection}{#1}}
\newcommand{\Ssubsubsubsectionstarx}[2]{\Ssubsubsubsectionstar{#2}}
\newcommand{\Ssubsubsubsubsectionstarx}[2]{\Ssubsubsubsubsectionstar{#2}}

% "grouper" is for the 'grouper style variant --- on subsections and lower,
%  because \Spart is used for grouper at the section level. Grouper implies
%  unnumbered.
\newcounter{GrouperTemp}
\newcommand{\Ssubsectiongrouper}[2]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsectionstarx{#1}{#2}\setcounter{subsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsectiongrouper}[2]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstarx{#1}{#2}\setcounter{subsubsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsubsectiongrouper}[2]{\Ssubsubsubsectionstarx{#1}{#2}}
\newcommand{\Ssubsubsubsubsectiongrouper}[2]{\Ssubsubsubsubsectionstarx{#1}{#2}}

\newcommand{\Ssubsectiongrouperstar}[1]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsectionstar{#1}\setcounter{subsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsectiongrouperstar}[1]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstar{#1}\setcounter{subsubsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsubsectiongrouperstar}[1]{\Ssubsubsubsectionstar{#1}}
\newcommand{\Ssubsubsubsubsectiongrouperstar}[1]{\Ssubsubsubsubsectionstar{#1}}

\newcommand{\Ssubsectiongrouperstarx}[2]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsectionstarx{#1}{#2}\setcounter{subsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsectiongrouperstarx}[2]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstarx{#1}{#2}\setcounter{subsubsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsubsectiongrouperstarx}[2]{\Ssubsubsubsectionstarx{#1}{#2}}
\newcommand{\Ssubsubsubsubsectiongrouperstarx}[2]{\Ssubsubsubsubsectionstarx{#1}{#2}}

% Generated by `subsubsub*section':
\newcommand{\SSubSubSubSection}[1]{\Ssubsubsubsubsectionstar{#1}}

% For hidden parts with an empty title:
\newcommand{\notitlesection}{\vspace{2ex}\phantomsection\noindent}

% To increment section numbers:
\newcommand{\Sincpart}{\stepcounter{part}}
\newcommand{\Sincsection}{\stepcounter{section}}
\newcommand{\Sincsubsection}{\stepcounter{subsection}}
\newcommand{\Sincsubsubsection}{\stepcounter{subsubsection}}
\newcommand{\Sincsubsubsubsection}{}
\newcommand{\Sincsubsubsubsubsection}{}

% When brackets appear in section titles:
\newcommand{\SOpenSq}{[}
\newcommand{\SCloseSq}{]}

% Helper for box-mode macros:
\newcommand{\Svcenter}[1]{$\vcenter{#1}$}

% Verbatim
\newenvironment{SVerbatim}{}{}

% Helper to work around a problem with "#"s for URLs within \href
% within other macros:
\newcommand{\Shref}[3]{\href{#1\##2}{#3}}

% For URLs:
\newcommand{\Snolinkurl}[1]{\nolinkurl{#1}}

% History note:
\newcommand{\SHistory}[1]{\begin{smaller}#1\end{smaller}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Scribble then generates the following:
%
%  \begin{document}
%  \preDoc
%  \titleAndVersion{...}{...}
%  ... document content ...
%  \postDoc
%  \end{document}
\usepackage{ccaption}

% \legend relies on \belowcaptionskip, which is not defined
% by the JFP class file:
\makeatletter
\@ifundefined{belowcaptionskip}{\newlength{\belowcaptionskip}}{}
\makeatother

\newcommand{\Legend}[1]{~

                        \hrule width \hsize height .33pt
                        \vspace{4pt}
                        \legend{#1}}

\newcommand{\LegendContinued}[1]{\Legend{#1}}

\newcommand{\FigureTarget}[2]{#1}
\newcommand{\FigureRef}[2]{#1}

\newlength{\FigOrigskip}
\FigOrigskip=\parskip

% Put this before the figure content, so that a hyperref goes to
% the start of the content:
\newcommand{\FigureSetRef}{\refstepcounter{figure}}

\newenvironment{Figure}{\begin{figure}\FigureSetRef}{\end{figure}}
\newenvironment{FigureMulti}{\begin{figure*}[t!p]\FigureSetRef}{\end{figure*}}
\newenvironment{FigureMultiWide}{\begin{FigureMulti}\FigureSetRef}{\end{FigureMulti}}
\newenvironment{Herefigure}{\begin{figure}[ht!]\FigureSetRef\centering}{\end{figure}}

\newenvironment{Centerfigure}{\begin{Xfigure}\centering\item}{\end{Xfigure}}
\newenvironment{Leftfigure}{\begin{Xfigure}\item}{\end{Xfigure}}
\newenvironment{Rightfigure}{\begin{Xfigure}\item}{\end{Xfigure}}

\newenvironment{Xfigure}{\begin{list}{}{\leftmargin=0pt\topsep=0pt\parsep=\FigOrigskip\partopsep=0pt}}{\end{list}}

\newenvironment{FigureInside}{}{}

\newcommand{\Centertext}[1]{\begin{center}#1\end{center}}


%% almost everything here was taken from either
%% - scribble/sigplan
%% - classicthesis's examples
%% - Stephen Chang's dissertation

%% these are overwritten by functions that are called from scribble-generated code
\newcommand{\myTitle}{Put title Here}
%% \newcommand{\mySubtitle}{Put subtitle Here} %% did not add support on the scribble side
\newcommand{\myName}{Put name here}
%% \newcommand{\myProf}{Put name here} %% ditto
%% \newcommand{\myOtherProf}{Put name here}
%% \newcommand{\mySupervisor}{Put name here}
%% \newcommand{\myFaculty}{Put data here}
\newcommand{\Sdegree}[1]{\newcommand{\myDegree}{#1}}
\newcommand{\Sdepartment}[1]{\newcommand{\myDepartment}{#1}}
\newcommand{\Suniversity}[1]{\newcommand{\myUni}{#1}}
\newcommand{\Slocation}[1]{\newcommand{\myLocation}{#1}}
\newcommand{\Ssubmitdate}[1]{\newcommand{\myTime}{#1}}
%% \newcommand{\myVersion}{Put data here} %% ditto

\newcounter{dummy} % necessary for correct hyperlinks (to index, bib, etc.)
\newlength{\abcd} % for ab..z string length calculation
\usepackage{textcomp} % fix warning with missing font shapes
\usepackage{scrhack} % fix warnings when using KOMA with listings package
\usepackage{xspace} % to get the spacing after macros right
\usepackage{mparhack} % get marginpar right
\usepackage{fixltx2e} % fixes some LaTeX stuff

\usepackage{classicthesis}

\usepackage{inconsolata}
\usepackage[T1]{fontenc}

\renewcommand{\preDoc}{
\frenchspacing
\raggedbottom
\pagenumbering{roman} %% last pre-content section should set it to `arabic` at the end
\pagestyle{plain}
}


\newcommand{\thesisTitle}{
%% taken from Stephen Chang's dissertation
\begin{titlepage}
\begin{addmargin}[-1cm]{-3cm}
    \begin{center}
        \large

        \hfill

        \vfill

        \begingroup
        \LARGE
            \parbox[c][1in][c]{5in}{\center\color{Blue}\spacedallcaps{\myTitle}} \\ \bigskip
        \endgroup

        \bigskip

        \spacedlowsmallcaps{\Large \myName}

        \vfill

        \vfill

%        \mySubtitle \\ \medskip

        Submitted in partial fulfillment of the requirements \\
        for the degree of \myDegree \\ \bigskip

        \bigskip

        \myDepartment \\
        \myUni \\ \myLocation \bigskip

        \myTime\ %-- \myVersion

        \vfill

    \end{center}
  \end{addmargin}
\end{titlepage}

%% back of title page
\thispagestyle{empty}

\hfill

\vfill

\noindent\myName: \\\textit{\myTitle,} \\ \myDegree, \myUni, \myLocation \\ %\mySubtitle,
\textcopyright\ \myTime

}

\renewcommand{\titleAndVersionAndAuthors}[3]{
  \renewcommand{\myTitle}{#1}
  \renewcommand{\myName}{#3}
  \thesisTitle
}
\renewcommand{\titleAndEmptyVersionAndAuthors}[3]{
  \titleAndVersionAndAuthors{#1}{#2}{#3}
}

\usepackage{pdfpages}
\newcommand{\Sapproval}[1]{
  \includepdf[pages={1}]{#1}
  \cleardoublepage
}

\newcommand{\Sabstract}[1]{
  \pdfbookmark[1]{Abstract}{Abstract}
  \begingroup
  \chapter*{Abstract}
  #1
  \endgroup
  \vfill
}

\newcommand{\Sacknowledgements}[1]{
  \bigskip
  \begingroup
  \cleardoublepage
  \pdfbookmark[1]{Acknowledgments}{acknowledgments}
  \chapter*{Acknowledgments}
  #1
  \endgroup
  \cleardoublepage
}

\newcommand{\Stableofcontents}[1]{
  \refstepcounter{dummy}
  \pdfbookmark[1]{\contentsname}{tableofcontents}
  \setcounter{tocdepth}{2} % <-- 2 includes up to subsections in the ToC
  \setcounter{secnumdepth}{3} % <-- 3 numbers up to subsubsections
  \manualmark
  \markboth{\spacedlowsmallcaps{\contentsname}}{\spacedlowsmallcaps{\contentsname}}
  \tableofcontents
  \automark[section]{chapter}
  \renewcommand{\chaptermark}[1]{\markboth{\spacedlowsmallcaps{#1}}{\spacedlowsmallcaps{#1}}}
  \renewcommand{\sectionmark}[1]{\markright{\thesection\enspace\spacedlowsmallcaps{#1}}}
  \cleardoublepage
}

%% doesn't seem to work when called from inside \Stableofcontents, so
%% needs to be called explicitly from the scribble document
\newcommand{\Sendfrontmatter}{
  \cleardoublepage\pagenumbering{arabic}
}

\newcommand{\Sthesispart}[2]{
  \cleardoublepage
  \part{#2}\label{#1}
}

%% Taken from scribble/book
\renewcommand{\Spart}[2]{\part[#1]{#2}}
\renewcommand{\Ssection}[2]{\chapter[#1]{#2}}
\renewcommand{\Ssubsection}[2]{\section[#1]{#2}}
\renewcommand{\Ssubsubsection}[2]{\subsection[#1]{#2}}
\renewcommand{\Ssubsubsubsection}[2]{\subsubsection[#1]{#2}}
\renewcommand{\Ssubsubsubsubsection}[2]{{\bf #2}}

%% "star" means unnumbered and not in ToC: (also from scribble/book)
\renewcommand{\Spartstar}[1]{\part*{#1}}
\renewcommand{\Ssectionstar}[1]{\chapter*{#1}}
\renewcommand{\Ssubsectionstar}[1]{\section*{#1}}
\renewcommand{\Ssubsubsectionstar}[1]{\subsection*{#1}}
\renewcommand{\Ssubsubsubsectionstar}[1]{\subsubsection*{#1}}
\renewcommand{\Ssubsubsubsubsectionstar}[1]{\Ssubsubsubsubsection{#1}}

% "starx" means unnumbered but in ToC: (also from scribble/book)
\renewcommand{\Spartstarx}[2]{\Spartstar{#2}\addcontentsline{toc}{part}{#1}}
\renewcommand{\Ssectionstarx}[2]{\Ssectionstar{#2}\addcontentsline{toc}{chapter}{#1}}
\renewcommand{\Ssubsectionstarx}[2]{\Ssubsectionstar{#2}\addcontentsline{toc}{section}{#1}}
\renewcommand{\Ssubsubsectionstarx}[2]{\Ssubsubsectionstar{#2}\addcontentsline{toc}{subsection}{#1}}
\renewcommand{\Ssubsubsubsectionstarx}[2]{\Ssubsubsubsectionstar{#2}\addcontentsline{toc}{subsubsection}{#1}}
\renewcommand{\Ssubsubsubsubsectionstarx}[2]{\Ssubsubsubsubsectionstar{#2}}

\renewcommand{\ChapRefLocal}[3]{chapter~\ref{#1}}
\renewcommand{\ChapRefLocalUC}[3]{Chapter~\ref{#1}}
%% In this case, #2 is the scribble-computed section number, which can
%% be hilariously off. No idea why.
\renewcommand{\SecRefLocal}[3]{section~\ref{#1}}
\renewcommand{\SecRefLocalUC}[3]{Section~\ref{#1}}
\renewcommand{\PartRefLocal}[3]{part~\ref{#1}}
\renewcommand{\PartRefLocalUC}[3]{Part~\ref{#1}}

%% Define a \provideenvironment that is analogous to \providecommand
%% From http://tex.stackexchange.com/questions/20687/does-newenvironment-have-a-provideenvironment-cousin-as-newcommand-has-prov
\makeatletter
\def\provideenvironment{\@star@or@long\provide@environment}
\def\provide@environment#1{%
        \@ifundefined{#1}%
                {\def\reserved@a{\newenvironment{#1}}}%
                {\def\reserved@a{\renewenvironment{dummy@environ}}}%
        \reserved@a
}
\def\dummy@environ{}
\makeatother

%% FigureMulti is only loaded when the @figure form from scriblib/figure
%% is used, so provide first to ensure it is always defined
\provideenvironment{FigureMulti}{}{}
\renewenvironment{FigureMulti}{\begin{figure}\FigureSetRef}{\end{figure}}
\input{package.tex}
\input{def.tex}
\begin{document}
\preDoc


\Sdegree{Doctor of Philosophy}

\Sdepartment{Khoury College of Computer Sciences}

\Suniversity{Northeastern University}

\Slocation{Boston, Mass.}

\Ssubmitdate{November 2020}\titleAndEmptyVersionAndAuthors{Deep and Shallow Types}{}{\SNumberOfAuthors{1}\SAuthor{Ben Greenman}}
\label{t:x28part_x22Deepx5fandx5fShallowx5fTypesx22x29}



\noindent 

\noindent 

\noindent 

\noindent 

\noindent 

\Sapproval{src/approval.pdf}

\Sabstract{The design space of mixed{-}typed languages is lively but disorganized.
On one hand, researchers across academia and industry have contributed language
 designs that allow typed code to interoperate with untyped code.
These design efforts explore a range of goals;
 some improve the expressiveness of a typed language, and
 others strengthen untyped code with a tailor{-}made type system.
On the other hand, experience with type{-}sound designs has revealed major challenges.
We do not know how to measure the performance costs of sound interaction.
Nor do we have criteria that distinguish {``}truly sound{''} mixed{-}typed languages
 from others that ignore type obligations in untyped code.

In this dissertation, I introduce methods for assessing
 mixed{-}typed languages and bring order to the design space.
My first contribution is a performance{-}analysis method that allows language
 implementors to systematically measure the cost of mixed{-}typed interaction.

My second contribution is a design{-}analysis method that allows language designers
 to understand implications of the type system.
The method addresses two central questions: whether typed code can cope with
 untyped values, and whether untyped code can trust static types.
Further distinctions arise by asking whether error outputs can
 direct a programmer to potentially{-}faulty interactions.

I apply the methods to several designs and discover limitations that motivate
 a synthesis of two ideas from the literature:
 deep types and shallow types.
Deep types offer strong guarantees but impose a high cost on interactions.
Shallow types come with weak guarantees but lower worst{-}case costs.
This dissertation proves that deep and shallow types can interoperate
 and shows that a three{-}way mix is often desirable.

Touch!}

\Stableofcontents{}
\Sendfrontmatter{}

\sectionNewpage

\Ssection{What It{'}s All About}{What It{'}s All About}\label{t:x28part_x22Whatx5fItx5fsx5fAllx5fAboutx22x29}

A language that can mix typed and untyped code must balance three conflicting
 dimensions:
\relax{{\renewcommand{\labelitemi}{{\large\decothreeright}} %{\raisebox{0.4ex}{\tiny\(\bullet\)}}
\begin{itemize}
\item \emph{Proofs}:
  Static types should be accurate predictions about the way a program
   behaves at run-time.
  If a type makes a claim about an expression, then other code---typed or untyped---may
   depend on it.
\item\emph{Performance}:
  Adding types to part of a codebase should not cripple its running time.
  On the contrary, a smart compiler should use types to generate
   efficient code.
\item \emph{People}:
  Untyped code must be free to create all sorts of values and
   typed code must be able to interact with many untyped designs.
  Programmers should not have to work around tough constraints on the
   boundary between typed and untyped code.
\end{itemize}}}

\noindent{}The ideal mixed{-}typed language would satisy all three goals,
 letting programmers add descriptive types to any component in a program
 and supporting those types with deep guarantees and fast performance.
This ideal is not here yet.
Friction between the dimensions raises a whole host of problems
 about how to enforce types at run{-}time.
In particular, \emph{performance} is the driving question.
Type guarantees that can (in principle) be enforced against untyped code often bring an
 overwhelming cost, slowing a program down by several orders of magnitude.

Researchers have addressed the performance question with designs that advertise
 low costs, but overall progress towards the ideal is marginal because these
 designs are incomparable.
For one, the performance of a new mixed{-}typed language is intertwined
 with the implementation of its host language;
 comparing performance across different languages is hopeless.
Second, the new designs typically compromise on proofs or people.
Lacking an apples{-}to{-}apples comparison, it is impossible to decide whether
 a language has solved the performance question.

The first half of this dissertation untangles the design space.
I present a method to measure performance, a method to measure type guarantees,
 and basic requirements concerning the expressiveness of such type systems.
I apply these methods and conclude that there are two promising designs:
 deep types via the natural semantics and shallow types via
 the transient semantics.
The impasse leads to my thesis question, which asks whether a language can
 effectively combine both techniques.
In the second half of this dissertation, I provide affirmative support for
 the thesis.

\Ssubsection{Thesis Statement}{Thesis Statement}\label{t:x28part_x22Thesisx5fStatementx22x29}

Deep and shallow types can coexist in a way that preserves their formal
properties
Programmers can combine these types to strengthen shallow{-}type
guarantees, avoid unimportant deep{-}type runtime errors, and lower the
running time of typed/untyped interactions.

\Ssubsection{Dissertation Overview}{Dissertation Overview}\label{t:x28part_x22Dissertationx5fOverviewx22x29}

Looking ahead, the first order of business is to lay down ground rules for
 expressiveness.
My goal is to combine typed and untyped code in a \emph{migratory typing}
 system, in which types accommodate the grown idioms of an
 untyped host language (chapter~\ChapRefLocal{t:x28part_x22chapx3awhyx22x29}{2}{Migratory Typing}).
Languages that fail the expressiveness criteria, however, can still benefit
 from the results.
Chapter~\ChapRefLocal{t:x28part_x22chapx3aperformancex22x29}{3}{Performance Analysis Method} presents the first systematic method for evaluating performance
 and validates this method through an empirical study of two migratory
 typing systems: Typed Racket and Reticulated Python.
Both languages guarantee type soundness, but come with very different
 performance characteristics; more surpringly, they compute incompatible results for
 seemingly{-}equal code.
Chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method} brings these two languages, and several others,
 into a common model for a precise comparison of designs.
The design{-}space analysis motivates a compromise between two semantics:
 natural and transient.
Chapter~\ChapRefLocal{t:x28part_x22chapx3atransientx22x29}{5}{Shallow Racket} presents the first half of the compromise;
 namely, a transient semantics for Typed Racket.
Chapter~\ChapRefLocal{t:x28part_x22chapx3abothx22x29}{6}{Deep and Shallow, Combined} formally proves that deep and shallow
 types can interoperate and reports the performance of a Typed Racket variant
 that supports both natural and transient behavior.
The dissertation ends with a view to future work (chapter~\ChapRefLocal{t:x28part_x22chapx3afuturex22x29}{7}{Future Work})
 and reflections on the wider research context (chapter~\ChapRefLocal{t:x28part_x22chapx3aconclusionx22x29}{8}{Conclusion}).

Overall, I present four major contributions:


\noindent \begin{enumerate}\atItemizeStart

\item the first performance{-}analysis method to systematically explore the
 interactions enabled by a mixed{-}typed language;

\item the first design{-}analysis method to articulate the meaning of types for
 both typed and untyped parts of a codebase;

\item a scaled{-}up transient that handles a rich language of types and
 employs ahead{-}of{-}time optimizations; and

\item the first language that lets programmers migrate untyped code to two
 type{-}sound disciplines: deep and shallow types.\end{enumerate}

\Ssubsection{Specification, Implementation, and Naming}{Specification, Implementation, and Naming}\label{t:x28part_x22Specificationx5fx5fImplementationx5fx5fandx5fNamingx22x29}

This dissertation is about different ways of mixing typed and untyped code
 in a programming language.
Each {``}way{''} starts from a rough idea, comes to life via a formal semantics,
 and is tested against formal specifications.
Different instances of these three concepts need names.

My primary focus is on two rough ideas: deep types and shallow types.
Deep types are nearly as good as static types.
If types in a statically{-}typed language provide a certain guarantee, then
 the deep versions of those types strive for the same guarantee no matter
 what untyped code throws at them.
Shallow types are weaker than deep types, but better than nothing.
A shallow type may provide a temporary guarantee, and may permit more
 behaviors than the corresponding static type.

These two ideas are accompanied by two leading semantics: natural
 and transient (chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method}).
Natural realizes deep types by carefully monitoring the boundaries
 between typed and untyped code{---}either with exhaustive assertions or proxy
 wrappers.
Transient realizes shallow types by rewriting all typed code to
 check the basic shape of every value that might be from untyped.

The two properties that distinguish these semantics, and thereby provide a
 formal distinction between deep and shallow and weaker ideas,
 are complete monitoring and type soundness (chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method}).
Natural satisfies complete monitoring while transient does not.
Both natural and transient satisfy a non{-}trivial type soundness.
Weaker mixings are unsound.

I use informal words to talk about
 different {``}ways of mixing typed and untyped code,{''} including:
 methods, strategies, and approaches.
There is no hope in trying to be authoritative because the research community
 is still seeking a best method for a useful combination.

\Ssubsubsection{Names in Prior Work}{Names in Prior Work}\label{t:x28part_x22Namesx5finx5fPriorx5fWorkx22x29}

\relax{\citet{tgpk-dls-2018}} introduce the names \emph{deep} and \emph{shallow}, but use
 them for the natural and transient implementations.
\relax{\citet{gf-icfp-2018}} use \emph{higher{-}order} for the deep idea and
 \emph{first{-}order} for the shallow idea.

Natural goes by many names.
\relax{\citet{vksb-dls-2014}} and several others call it \emph{guarded} because
 the semantics keeps a firm barrier between typed and untyped code.
\relax{\citet{clzv-ecoop-2018}} introduce the word \emph{behavioral} for both
 the semantics and its characteristic wrapper values.
Foundational papers simply call it gradual typing\relax{~\citep{st-sfp-2006,tf-dls-2006,htf-hosc-2010}}.

The name \emph{natural} comes from \relax{\citet{mf-toplas-2009}}, who use it
 to describe a proxy method for transporting untyped functions into a
 typed context.
Earliers works on higher{-}order contracts\relax{~\citep{ff-icfp-2002}},
 remote procedure calls\relax{~\citep{ok-popl-2003}}, and
 typed foreign function interfaces\relax{~\citep{r-jfp-2008}}
 employ a similar method.
\relax{\citet{nla-popl-2019}} present a semantic argument that natural is indeed
 the only way to enforce the key properties of static types.

\sectionNewpage

\Ssection{Migratory Typing}{Migratory Typing}\label{t:x28part_x22chapx3awhyx22x29}

Migratory typing is a novel approach to an old desire:
 mixing typed and untyped code.
A typed programming language comes with a strict sub{-}language (of types)
 that articulates what a program computes.
For better or worse, code that does not fit the sub{-}language may not run.
An untyped language runs any program in which the primitive computations
 stick to legal values.
The mixed{-}typed idea is to somehow combine some good aspects of both.
A programmer should have some untyped flexibility and some typed guarantees.

Of course, flexibility and guarantees lie at two ends of a tradeoff.
More freedom to run programs means less knowledge about what a new
 program might do, unless there are run{-}time checks to catch extreme behaviors.
Run{-}time checks slow down a computation, thus a mixed{-}typed language needs to
 balance three desires: expressiveness, guarantees, and performance.

Before a language design can address the central 3{-}way tradeoff, its creators
 must decide what kinds of mixing to allow and what goals to strive for.
Migratory typing is one such theory.
The goal is to add static typing onto an independent untyped
 language.
Programmers create a mixed{-}typed program by writing types for
 one chunk of untyped code; that is, by migrating the chunk into the typed
 half of the language.
Both the goal and the method incorporate lessons from earlier mixed{-}typed efforts
 (chapter~\SecRefLocal{t:x28part_x22secx3awhyx3arelatedx22x29}{2.1}{Pre{-}MT: Hits and Misses}), along with basic
 observations about programming (chapter~\SecRefLocal{t:x28part_x22secx3awhyx3aobservationsx22x29}{2.2}{MT: Observations}).
The observations, in particular, motivate design choices that characterize
 migratory typing (chapter~\SecRefLocal{t:x28part_x22secx3awhyx3adecisionsx22x29}{2.3}{MT: Design Choices}).

\Ssubsection{Pre{-}MT: Hits and Misses}{Pre{-}MT: Hits and Misses}\label{t:x28part_x22secx3awhyx3arelatedx22x29}

In the days before migratory typing, language designers explored several ways
 to mix typed and untyped code.
Some mixtures began with an untyped language and allowed
 user{-}supplied type annotations.
Others began with a typed language and added untyped flexibility.
Either way, each design had to decide on run{-}time guarantees for its
 generalized types.

\Ssubsubsection{Type Hints}{Type Hints}\label{t:x28part_x22Typex5fHintsx22x29}

Early Lisps, including MACLISP\relax{~\citep{m-maclisp-1974}} and Common Lisp\relax{~\citep{s-lisp-1990}},
 have compilers that accept type hints.
In MACLISP, for example, a programmer can hint that a function expects two
 floating{-}point numbers and returns one to encourage the compiler to specialize
 the function body (\hyperref[t:x28counter_x28x22figurex22_x22figx3amaclispx2dhintx22x29x29]{figure~\FigureRef{1}{t:x28counter_x28x22figurex22_x22figx3amaclispx2dhintx22x29x29}}).

Any speedup due to type hints, however, comes at a risk.
There is no static type system to prove that hints are sensible claims.
If a hint is nonsense, then the compiled code may behave in unexpected ways.
Similarly, there is no dynamic guarantee that compiled code receives valid
 inputs.
If the function \Scribtexttt{F} in \hyperref[t:x28counter_x28x22figurex22_x22figx3amaclispx2dhintx22x29x29]{figure~\FigureRef{1}{t:x28counter_x28x22figurex22_x22figx3amaclispx2dhintx22x29x29}} is invoked on two
 strings, it may compute an invalid result.
In other words, type hints come with all the perils of types in a C{-}like language.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.0bp}{\makebox[217.6bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3amaclispx2dhintx22x29x29}Figure~1: }{t:x28counter_x28x22figurex22_x22figx3amaclispx2dhintx22x29x29}Example type hint in MACLISP\relax{~\citep{p-maclisp-1983}}.
The compiler may rewrite \Scribtexttt{PLUS} into code that assumes floating{-}point inputs.}}\end{FigureMulti}

\Ssubsubsection{Soft and Set{-}Based Inference}{Soft and Set{-}Based Inference}\label{t:x28part_x22Softx5fandx5fSetx2dBasedx5fInferencex22x29}

In principle, type inference can bring static types to untyped code.
Research on soft typing pursues this goal in an ideal form
 by constructing types for any untyped program.
Soft type systems never raise a type error.
Instead, a soft type checker widens types as needed
 and inserts run{-}time checks to protect implicit down{-}casts\relax{~\citep{f-thesis-1992,w-thesis-1994}}.

The key to the soft typing problem is to adapt inference from equalities
 to inequalities\relax{~\citep{tfffgksst-snapl-2017}}.
In a language such as ML, a type describes exactly how a variable
 may be used.
Any out{-}of{-}bounds use is an error by definition.
Thus ML inference asks for a solution to a system of equalities between
 variables and types.
Inference for an untyped language must relax the equality assumption
 to deal with the less{-}structured design of untyped programs.
Here, the natural types describe sets of values with compatible behavior.
The inference problem asks for types that over{-}approximate the
 behaviors in a set of values.

There are two known methods to solve type inequalities.
Soft inference adds slack variables to types, turns the
 inequalities into equalities, and then uses Hindley{-}Milner style inference\relax{~\citep{f-thesis-1992}}.
Set{-}based inference solves the inequalities by computing a transitive
 closure through constructors over the entire program\relax{~\citep{am-popl-1991,awl-popl-1994,f-thesis-1997,ff-pldi-1997,ffkwf-pldi-1996}}.
Both solutions, unfortunately, reveal major challenges for inference:
\relax{\begin{itemize}
\item
  Types can quickly become unreadable as inference computes supersets based on
   the syntax of a program.
  Worse, small changes to a program can end in large changes to inferred types.
\item
  Type structure depends on the whole program.
  Set-based analysis, in particular, faces serious performance issues
   in larger programs\relax{~\citep{mfsw-hosc-2005}}.
\end{itemize}}

\relax{\citet{w-thesis-1994}} notes that user{-}provided annotations can help with
 brittleness and readability, despite friction with the tenets of soft typing.
\relax{\citet{m-thesis-2006}} improves the performance of set{-}based analysis
 by leveraging contracts at module boundaries.
Their observations anticipate the migratory typing approach to mixed{-}typed code.

\Ssubsubsection{Inference via Dynamic Typing}{Inference via Dynamic Typing}\label{t:x28part_x22Inferencex5fviax5fDynamicx5fTypingx22x29}

Henglein{'}s dynamic typing uses standard types and general{-}purpose coercions to
 compile untyped code to an efficient representation\relax{~\citep{h-scp-1994}}.
The method starts with a conventional typed language and adds three
 related ingredients:
 a universal sum type, called the dynamic type;
 coercions that inject any precisely{-}typed value up to the dynamic type; and
 (partial) coercions that project a dynamically{-}typed value down to a non{-}dynamic type.
This augmented core is the basis of a mixed{-}typed language.
Typed code maps directly to the core with no additional coercions.
Untyped code may require coercions, but a smart compiler can minimize
 their use.
\relax{\citet{h-lfp-1992}} compiles Scheme to a monomorphic type system and is able
 to resolve at least 50\% of the coercions in six benchmarks.
\relax{\citet{hr-fpca-1995}} extend the method to polymophic types and
 implement IEEE Scheme using Standard ML.

Conventional types, however, are not always sufficient to capture untyped
 designs.
For example, \relax{\citet{hr-fpca-1995}} note that Scheme conditionals
 end up with extra coercions into the dynamic type.
The designs can be expressed, but a tailored type system is needed to
 maximize run{-}time efficiency.

\Ssubsubsection{Optional Typing}{Optional Typing}\label{t:x28part_x22Optionalx5fTypingx22x29}

An optional, or pluggable, type system adds a static analysis to an untyped
 language\relax{~\citep{bg-oopsla-1993}}.
The approach is related to type hints in that programmers must add
 annotations to untyped code.
Optional types are supported, however, by a full{-}fledged type checker
 and a no{-}op compiler.
The type checker is the static analysis; it uses types to find basic logical errors.
Compilation erases types to arrive at an untyped program that can safely
 interoperate with the rest of the program.

Despite their widespread adoption (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alandscapex22x29}{4.2}{Assorted Behaviors by Example}),
 optional types are a badge of shame for the research community because
 these types are unsound.
A programmer cannot use optional types to predict the inputs that a function
 will receive, and likewise a compiler cannot use optional types to justify
 transformations.

\emph{History Note:}
Optional typing is one valid way to use Lisp type hints.
A Lisp compiler need not optimize based on type hints, and it may even ignore
 types completely\relax{~\citep{m-maclisp-1974,s-lisp-1990}}.
\relax{\citet{bg-oopsla-1993}} deserve credit not for inventing the optional style,
 but for explaining why it is a practical mode of use.

\Ssubsubsection{Type Dynamic}{Type Dynamic}\label{t:x28part_x22Typex5fDynamicx22x29}

Statically{-}typed languages often need to interact with untyped values,
 perhaps though a database connection, web socket, or interactive prompt.
Both \relax{\citet{acpp-toplas-1991}} and \relax{\citet{lm-fpca-1991}} thus present static
 type systems with a special dynamic type.
Typed code can interact with a untyped value by first testing
 its structure; the type system records observations.

Quasi{-}static typing extends the type{-}dynamic idea with implicit structure
 tests\relax{~\citep{t-popl-1990}}.
Instead of asking the user to write and maintain type{-}testing code, the
 quasi{-}static system generates run{-}time checks.
Consequently, programmers have less incentive to handle the dynamic type
 at the boundary to untrusted code.
The result is a mixed{-}typed language because entire blocks of code may have
 the dynamic type throughout.
Gradual typing emphasizes the mixed{-}typed idea in quasi{-}static typing,
 contributes major technical improvements and design discipline\relax{~\citep{st-sfp-2006,svcb-snapl-2015}},
 and has inspired a large body of static{-}to{-}dynamic research (\href{https://github.com/samth/gradual-typing-bib}{\Snolinkurl{github.com/samth/gradual-typing-bib}}).

Implicit coercions to type dynamic, however, weaken type{-}proofs in a
 gradual or quasi{-}static language.
Rather than showing that components \emph{do} fit together, a gradually{-}typed
 program is something that \emph{can} fit together given good values at each occurrence
 of the dynamic type.
Words such as {``}plausibility{''}\relax{~\citep{t-popl-1990}}
 and {``}consistency{''}\relax{~\citep{st-sfp-2006}} aptly describe the weakened guarantees;
 gradual types can only point out implausibilities and inconsistencies among
 non{-}dynamic types.

\Ssubsection{MT: Observations}{MT: Observations}\label{t:x28part_x22secx3awhyx3aobservationsx22x29}

Migratory typing stands on three observations:
 untyped code exists,
 type annotations improve maintainability,
 and sound types are a worthwhile ideal.
On the surface, these basic opinions simply motivate a typed/untyped mix;
 between the lines, however,
 they suggest requirements for an effective mixed{-}typed language.

\Ssubsubsection{MT{-}o1: untyped code exists}{MT{-}o1: untyped code exists}\label{t:x28part_x22whyx3amtx2do1x22x29}

Untyped code is a fact.
Large companies such as Dropbox, Facebook, and Twitter started as
 untyped projects.
Small teams continue to employ untyped languages; indeed, most repositories on
 GitHub use either JavaScript, Python, PHP, or Ruby (\href{https://githut.info}{\Snolinkurl{githut.info}}).

Once an untyped codebase is off the ground and the lack of reliable type
 information becomes a maintenance bottleneck, programmers have two options.
The extreme option is to change languages.
Twitter, for example, was able to port its Ruby codebase over to Scala\relax{~\citep{twitter-scala}}.
For teams that lack the time and expertise to make such a switch, the alternative
 is to re{-}create any necessary benefits of types.
An exemplar of the second option is Sweden{'}s pension system, which
 depends on a contract{-}laden Perl program\relax{~\citep{sweden-pluto}}.
The contracts ensure that components in this huge program behave as intended.

Research on mixed{-}typed languages can be a great help to teams in this second
 camp, that cannot afford to rewrite their codebase.
General knowledge about how to design a companion type system can reduce
 the development cost of an in{-}house solution like Sweden{'}s contracts.
And a tailor{-}made type system, if one exists, provides an immediate solution
 to maintenance issues.

\Ssubsubsection{MT{-}o2: types communicate}{MT{-}o2: types communicate}\label{t:x28part_x22whyx3amtx2do2x22x29}

Type annotations are an important channel of communication.
For human readers, they describe the high{-}level design of code.
Even the original author of a function can benefit from reading the types
 after some time away from the codebase.
For a compiler, annotations are hints about what the programmer expects.
Any type error messages that can point to part of an annotation
 have a syntactic link to the programmer who needs to deal with the errors.

\Ssubsubsection{MT{-}o3: sound types catch bugs}{MT{-}o3: sound types catch bugs}\label{t:x28part_x22whyx3amtx2do3x22x29}

All static types can find typo{-}level mistakes, but only sound types
 guarantee type{-}specified behavior.
In a mixed{-}typed setting, a guarantee can make a world of difference.
Picture a large untyped codebase made up of several interacting components,
 and suppose that one component behaves strangely.
Adding unsound types to that one component can reveal a syntactic mistake, but nothing more.
Sound types, on the other hand, will halt the program as soon as an incorrect
 value appears in typed code.
If the language can additionally report the source of the untyped value
 and the rationale for the mismatched type expectation, then the programmer
 has two clues about where to begin debugging.

Going beyond soundness, a mixed{-}typed language that satisfies complete
 monitoring guarantees the run{-}time behavior of every type.
If a value flows across a type{-}annotated source position, then future users
 of the value can depend on the type{---}no matter whether these uses are in
 statically{-}typed or untyped code (chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method}).
In other words, silent disagreements between a type and value cannot arise.
Every mismatch stops the program before computations can become further derailed.

\Ssubsection{MT: Design Choices}{MT: Design Choices}\label{t:x28part_x22secx3awhyx3adecisionsx22x29}

Taken broadly, migratory typing studies how to add types to untyped code.
My dissertation builds on a more focused theory that is grounded in the
 following principles.
Typed Racket shares the same theory\relax{~\citep{t-thesis-2010,tfffgksst-snapl-2017}}.
Our aim is to maximize the potential benefits of a mixed{-}typed language,
 in spite of the risk that some goals may prove unattainable.
As always, research is when it can fail.

\Ssubsubsection{MT{-}r1: types for untyped code}{MT{-}r1: types for untyped code}\label{t:x28part_x22whyx3amtx2dr1x22x29}

Migratory typing begins with an independent untyped language and adds
 a companion type system.
The new types and type system must express common idioms from the untyped world;
 in other words, a type system that demands a re{-}organizion of untyped code
 is not acceptable.

\Ssubsubsection{MT{-}r2: require annotations, reject programs}{MT{-}r2: require annotations, reject programs}\label{t:x28part_x22whyx3amtx2dr2x22x29}

Programmers must write type annotations for top{-}level and recursive
 definitions.
Extra annotations may guide type inference.

The type checker will reject ill{-}typed programs instead of creating a
 run{-}time cast to bridge unequal types.
Programmers must deal with the type errors, either by inserting a cast
 or re{-}designing code.

\Ssubsubsection{MT{-}r3: sound types}{MT{-}r3: sound types}\label{t:x28part_x22whyx3amtx2dr3x22x29}

Well{-}typed code must satisfy a non{-}trivial soundness guarantee.
Both deep and shallow types are acceptable, but nothing less.

\Ssubsubsubsectionstarx{Blame}{Blame}\label{t:x28part_x22Blamex22x29}

Sound types catch bugs, but make no claims about actionable error outputs.
Blame is an additional property geared to useful errors
 that tell a programmer where to begin debugging.
To this end, a mixed{-}typed language should try to present meaningful source
 locations along with every run{-}time type mismatch error.

\Ssubsubsection{MT{-}r4: clear boundaries}{MT{-}r4: clear boundaries}\label{t:x28part_x22whyx3amtx2dr4x22x29}

Typed and untyped code must be linked at static and clearly visible API boundaries.
In order for a typed module to interact with an untyped value, the module
 must declare a type specification for the value.
An untyped module does not need to give specifications because any
 typed value that it imports comes with a static specification for correct use.

By contrast, this dissertation is not directly concerned with true gradual
 languages that include a dynamic type\relax{~\citep{svcb-snapl-2015}}.
Such languages can still benefit from my results at an intermediate step,
 after occurrences of the dynamic type have been replaced with precise types
 and casts.
But it is unclear how to communicate intermediate behaviors up to the
 programmer.

Requiring boundaries greatly simplifies and strengthens the type system.
It is simpler because there is no dynamic type; standard definitions of
 types, subtyping, and all the rest suffice for the type checker.
It is stronger because there is no type precision relation to allow
 odd constructions in otherwise{-}typed code.
Untyped code can only sneak in through a boundary;
 refer to chapter~\SecRefLocal{t:x28part_x22secx3atransientx3ablamex2dperformancex22x29}{5.4.4}{Blame Performance} for a contrary
 example in Reticulated Python.

\Ssubsubsubsectionstarx{Macro, Micro}{Macro, Micro}\label{t:x28part_x22Macrox5fx5fMicrox22x29}

Prior works make a distinction between \emph{macro}{-}level and \emph{micro}{-}level
 gradual typing systems\relax{~\citep{tfdfftf-ecoop-2015,tfgnvf-popl-2016}}.
These names express the same idea as my boundary requirement,
 but in terms of granularity and with the term {``}gradual typing{''} broadly
 construed to refer to any sound mixed{-}typed language.
Macro allows interaction between typed and untyped chunks of code\relax{~\citep{tf-dls-2006}}
 whereas micro allows {``}fine{-}grained{''} mixing via a dynamic type\relax{~\citep{st-sfp-2006}}.

Looking back, I think there were two dimensions at play.
First is whether to include a dynamic type.
Second is how to mix: whether to migrate from an untyped host language
 or to add flexibility to a static type system\relax{~\citep{g-snapl-2019}}.
Micro/macro is a useful mnemonic for the first dimension,
 but it is more direct to talk about dynamic/non{-}dynamic and migratory/non{-}migratory
 as two choices in the design of a new mixed{-}typed language.

\Ssubsection{Recent History}{Recent History}\label{t:x28part_x22secx3awhyx3ahistoryx22x29}

\relax{\citet{t-thesis-2010}} developed migratory typing alongside Typed Racket.
The basic ideas arose from work on soft typing\relax{~\citep{f-thesis-1992,w-thesis-1994}},
 higher{-}order contracts\relax{~\citep{f-thesis-2002}},
 and modular set{-}based analysis\relax{~\citep{m-thesis-2006}}.
Subsequent work adapted migratory typing to
 multi{-}paradigm language features:
 compositional flow{-}based reasoning\relax{~\citep{tf-icfp-2010}},
 delimited continuations\relax{~\citep{tst-esop-2013}},
 variable{-}arity polymorphism\relax{~\citep{stf-esop-2009}},
 type{-}driven optimization\relax{~\citep{s-thesis-2015}},
 first{-}class classes\relax{~\citep{t-thesis-2016}},
 units (first{-}class modules)\relax{~\citep{f-thesis-2015}},
 and refinement types\relax{~\citep{k-thesis-2019}}.
Refer to \relax{\citet{tfffgksst-snapl-2017}} for a ten{-}year retrospective.
My dissertation adds one step to this lineage.
I began by studying the most pressing challenge, performance costs, and
 arrived at the combination of deep and shallow types.

\sectionNewpage

\Ssection{Performance Analysis Method}{Performance Analysis Method}\label{t:x28part_x22chapx3aperformancex22x29}

\begin{SInsetFlow}\emph{This chapter is based on joint work with: Matthias Felleisen, Daniel Feltey, Robert Bruce Findler, Zeina Migeed, Max S. New, Asumu Takikawa, Sam Tobin{-}Hochstadt, and Jan Vitek\relax{~\citep{gtnffvf-jfp-2019,gm-pepm-2018,tfgnvf-popl-2016}}. The Typed Racket benchmarks presented in this chapter
have been improved over the years by:
Spenser Bauman, Lukas Lazarek, Cameron Moy, and Sam Sundar.}\end{SInsetFlow}

\noindent{}Sound types come with performance overhead in a mixed{-}typed language
 because soundness is a claim about behavior and the only way to control
 the behavior of untyped code is via run{-}time checks.
These checks impose a cost in proportion to
 the frequency of mixed{-}typed interactions,
 the complexity of the type specifications that govern boundaries,
 and the strength of the soundness guarantee.

Language designers must measure the performance of a mixed{-}typed language
 to judge its overall usefulness in light of its guarantees.
Type{-}sound code that runs too slowly is worthless.
At a finer grain, users need an idea of what overhead to expect when they begin
 experimenting with types.
Implementors need a comprehensive performance summary to
 measure improvements to a language and to compare alternative mixed{-}typed
 designs.
Despite these realities, early reports on mixed{-}typed languages
 typically lack performance evaluation.
A few acknowledge performance issues in passing\relax{~\citep{tf-popl-2008,acftd-scp-2013,vksb-dls-2014}}.
Others show only the performance of fully{-}typed code relative to fully{-}untyped
 code, skipping the novel configurations in between\relax{~\citep{rsfbv-popl-2015,vss-popl-2017}}.
But in their defense, the development of a performance method is a challenge
 in itself.

This chapter presents a systematic and scalable method to assess the performance
 of a mixed{-}typed language.
The method summarizes performance for the exponentially{-}many ways that a programmer
 can mix typed and untyped code by focusing on a binary quality measure.
Informally, a mixture is good if runs within a user{-}supplied overhead limit.
Random sampling can approximate the proportion of good mixtures for programs
 in which exhaustive evaluation is not practical.
As validation, this chapter evaluates the performance of two
 mixed{-}typed languages: Typed Racket and Reticulated Python.

\Ssubsection{Design Criteria}{Design Criteria}\label{t:x28part_x22Designx5fCriteriax22x29}

The goal of performance evaluation is to predict the experiences of future
 users.
Intuition suggests that the users of a mixed{-}typed language will begin
 with an untyped codebase and add types step{-}by{-}step.
Experience with Typed Racket supports the intuition.
Programmers add types in an incremental fashion and experiment with all sorts of combinations.
When typed libraries enter the picture, untyped programmers unknowingly
 create mixed{-}typed applications.
In a typical evolution, programmers compare the performance of the modified
 program with the previous version.
If the current performance is on par with the previous, then all is well.
Otherwise, the easy solutions are: adding more types, and rewinding to a
 less{-}typed version.
These observations and assumptions about users suggest three basic criteria
 for an evaluation method.

\Ssubsubsection{Representative Benchmarks}{Representative Benchmarks}\label{t:x28part_x22Representativex5fBenchmarksx22x29}

An evaluation method has to measure programs, and the results of
 a particular evaluation are limited by the chosen benchmarks.
Benchmark programs that stem from realistic code and exercise a variety
 of features are an important step toward generalizable results.

\Ssubsubsection{Exponential Compression}{Exponential Compression}\label{t:x28part_x22Exponentialx5fCompressionx22x29}

A mixed{-}typed language promises to support exponentially{-}many combinations of
 typed and untyped code.
In Typed Racket, for example, a programmer can add types to any module of a program.
Thus a program with 5 modules leads to
 \relax{$2^5$} possible combinations (\hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex2d0x22x29x29]{figure~\FigureRef{2}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex2d0x22x29x29}}).
Languages that can mix at a finer granularity support \relax{$2^k$} configurations,
 where \relax{$k$} is the number of potentially{-}typed blocks.

Without evidence against certain mixtures, an evaluation
 must collect data for every mixed{-}typed configuration.
These huge datasets call for a way to compress exponentially{-}many
 observations into a compact summary.

\begin{Figure}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.3999999999999915bp}{\makebox[323.20000000000005bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_2.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex2d0x22x29x29}Figure~2: }{t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex2d0x22x29x29}A Racket program with 5 modules supports 32
mixed{-}typed configurations, including the fully{-}untyped and fully{-}typed versions.}}\end{Figure}

\Ssubsubsection{Report Overheads}{Report Overheads}\label{t:x28part_x22Reportx5fOverheadsx22x29}

Because migratory typing starts from an untyped language, programmers
 can always revert to an untyped version of their codebase if types
 prove too expensive.
The existence of this fully{-}untyped baseline helps anchor an evaluation.
If a programmer can tolerate a certain overhead, say 13x,
 then a single number can summarize the good parts of the exponentially{-}large
 configuation space; namely, the percent of configurations that run fast enough.
A second benefit is that overheads make it easy to find points where types
 improve upon the baseline; look for overheads under 1x.

\Ssubsection{Exhaustive Evaluation Method}{Exhaustive Evaluation Method}\label{t:x28part_x22Exhaustivex5fEvaluationx5fMethodx22x29}

An exhaustive evaluation considers all ways that a programmer might
 toggle type annotations.
The method begins with a fully{-}typed codebase,
 measures all possible mixed{-}typed configurations,
 and introduces a compact visualization to summarize the results.

\Ssubsubsection{By Example}{By Example}\label{t:x28part_x22Byx5fExamplex22x29}

A Racket program is a collection of modules.
Technically, there are two kinds of modules in such a collection:
 the \emph{migratable} modules that the program{'}s author has direct
 control over, and the \emph{contextual} modules that come from an
 external library.
A programmer can add types to any migratable module.
Thus a program with \relax{$N$} migratable modules opens a space of \relax{$2^N$}
 mixed{-}typed configurations, and each configuration depends on
 the same contextual modules.

For example, \relax{\textsf{fsm}} is a small Racket program that simulates an economy (chapter~\SecRefLocal{t:x28part_x22secx3atrx3abenchmarksx22x29}{3.5.2}{Benchmarks}).
The main functionality is split across four modules;
 with migratory typing, this leads to sixteen
 mixed{-}typed configurations.
\hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex22x29x29]{Figure~\FigureRef{3}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex22x29x29}} shows all these configurations in a lattice,
 with the untyped configuration on the bottom and the fully{-}typed configuration
 on top.
Nodes in the middle mix typed and untyped code; each row groups all
 configurations with the same number of typed modules.
Lines between nodes represent the addition (or removal) of types from one
 module.

The label below a configuration node reports its overhead relative to
 the untyped configuration on Racket version 6.4.
With these labels, a language implementor can draw several conclusions about
 performance overhead in \relax{\textsf{fsm}}.
A first observation is that the fully{-}typed code runs equally fast as
 the untyped baseline.
This 1x overhead is also the overall best point in the lattice.
Six other configurations run within a 2x overhead, but the rest suffer
 from orders{-}of{-}magnitude slowdowns.
Types in \relax{\textsf{fsm}} can come at a huge cost.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-2.407812499999989bp}{\makebox[270.40000000000003bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_3.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex22x29x29}Figure~3: }{t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex22x29x29}Performance overhead in \relax{\textsf{fsm}}, on Racket v6.4.}}\end{FigureMulti}

\noindent Drawing such conclusions is not easy, however, even for this small program.
Manually analyzing a lattice for programs with eight or more modules is clearly infeasible.
\hyperref[t:x28counter_x28x22figurex22_x22figx3aoverheadx2dplotx2dexamplex22x29x29]{Figure~\FigureRef{4}{t:x28counter_x28x22figurex22_x22figx3aoverheadx2dplotx2dexamplex22x29x29}} presents a graphical alternative,
 an \emph{overhead plot}, that reports configurations{'} overhead relative
 to the untyped baseline.
Overhead plots are cumulative distribution functions.
As the function proceeds left{-}to{-}right for numbers \relax{$D$} along the \relax{$x$}{-}axis,
 the curve shows the proportion of all configurations that run at most
 \relax{$D$} times slower than the untyped configuration.
For short, these are \relax{$D$}{-}deliverable configurations.
On the left, there is always at least one \relax{$1$}{-}deliverable configuration;
 namely, the fully{-}untyped configuration itself.
The question is whether other configurations run fast as well.
To read such a plot quickly, focus on the area under the curve.
A large shaded area implies that a large number of configurations
 have low overhead.

The second most important aspects of an overhead plot are the two values of \relax{$D$}
 where the curve starts and ends.
More precisely, if \relax{$h\!:\!\mathbb{R}^+\!\rightarrow\!\mathbb{N}$} is the CDF
 that counts the proportion of \relax{$D$}{-}deliverable
 configurations in a benchmark, the critical points are the smallest
 overheads \relax{$d_0, d_1$} such
 that \relax{$h(d_0)\!>\!0\%$} and \relax{$h(d_1)\!=\!100\%$}.
An ideal start{-}value would lie between zero and one; if \relax{$d_0\!<\!1$} then
 at least one configuration runs faster than the baseline.
The end{-}value \relax{$d_1$} is the overhead of the slowest{-}running configuration.

Lastly, the slope of a curve corresponds to the likelihood that
 accepting a small increase in performance overhead increases the number
 of deliverable configurations.
A flat curve (zero slope) suggests that the performance of a group of
 configurations is dominated by a common set of type annotations.
Such observations are no help to programmers facing performance issues,
 but may help language implementors fix inefficiencies.

Overhead plots scale to arbitrarily large datasets by compressing
 exponentially{-}many points into a proportion.
Furthermore, plotting two curves on one axis compares relative performance.
\hyperref[t:x28counter_x28x22figurex22_x22figx3arelativex2doverheadx2dplotx2dexamplex22x29x29]{Figure~\FigureRef{5}{t:x28counter_x28x22figurex22_x22figx3arelativex2doverheadx2dplotx2dexamplex22x29x29}} demonstrates two curves
 for \relax{\textsf{fsm}}: on Racket v6.4 and v7.7.
The latter curve shows a huge improvement thanks to collapsible contracts\relax{~\citep{fgsfs-oopsla-2018}}.
Indeed, every \relax{\textsf{fsm}} configuration is \relax{$4$}{-}deliverable on Racket v7.7.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.3999999999999915bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_4.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aoverheadx2dplotx2dexamplex22x29x29}Figure~4: }{t:x28counter_x28x22figurex22_x22figx3aoverheadx2dplotx2dexamplex22x29x29}Overhead plot for \relax{\textsf{fsm}}, on Racket v6.4.
The unlabeled vertical ticks mark, from left{-}to{-}right:
1.2x, 1.4x, 1.6x, 1.8x, 4x, 6x, 8x, 10x, 12x, 14x, 16x, and 18x.}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-1.7468750000000002bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_5.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3arelativex2doverheadx2dplotx2dexamplex22x29x29}Figure~5: }{t:x28counter_x28x22figurex22_x22figx3arelativex2doverheadx2dplotx2dexamplex22x29x29}Overhead plots for \relax{\textsf{fsm}}, on Racket v6.4
 and v7.7.
The blue curve for v6.4 is higher, showing a relative improvement.}}\end{FigureMulti}

\Ssubsubsection{By Definition}{By Definition}\label{t:x28part_x22chapx3aperformancex3adefinitionx22x29}

The exhaustive evaluation method applies to other mixed{-}typed languages
 as well as Typed Racket.
To encourage adaptations, the following definitions highlight key concepts.
The prose uses Reticulated Python as a running example.

In Reticulated, every parameter to a function, every function return position,
 and every class field can be typed or untyped.
This is a much finer \emph{granularity} than Typed Racket{'}s, in which entire
 modules must be typed as a unit.
The added flexibility means that an experimenter must choose whether to explore:
 coarse, module{-}grained mixes;
 fine, function{-}parameter mixes;
 or something in between.

\relax{\vspace{1ex}
}\textbf{Definition} (\emph{granularity}) The \emph{granularity} of an experiment is the syntactic unit at which
 it adds/removes type annotations.\relax{\vspace{1ex}
}

For example, \relax{\citet{tfgnvf-popl-2016}} evaluate Typed Racket at the granularity
 of modules.
\relax{\citet{vss-popl-2017}} evaluate Reticulated at the granularity of whole programs,
 and \relax{\citet{gm-pepm-2018}} evaluate Reticulated at the granularity of whole
 functions and whole class field sets (chapter~\SecRefLocal{t:x28part_x22secx3arpx3aprotocolx22x29}{3.6.1}{Protocol}).

After choosing a granularity, an experimenter must pick a suite of
 programs to measure.
A potential complication is that programs may depend on external libraries
 or other modules that lie outside the realistic scope of the evaluation.

\relax{\vspace{1ex}
}\textbf{Definition} (\emph{migratable, contextual}) The \emph{migratable} code in a program defines its configurations.
The \emph{contextual} code in a program is common across all configurations.\relax{\vspace{1ex}
}

The granularity and the migratable code define the
 \emph{configurations} of a fully{-}typed program.

\relax{\vspace{1ex}
}\textbf{Definition} (\emph{configurations}) Let \relax{$C \tcstep C'$}
 if and only if program \relax{$C'$} can be obtained from program
 \relax{$C$} by annotating one migratable syntactic unit.
Let \relax{$\tcmulti$} be the reflexive, transitive closure of the \relax{$\tcstep$}
 relation.
The \emph{configurations} of a fully{-}typed program \relax{$C_\tau$} are all
 programs \relax{$C$} such that \relax{$C\!\tcmulti C_\tau$}.
Furthermore, \relax{$C_\tau$} is a \emph{fully{-}typed configuration}.
An \emph{untyped configuration} \relax{$C_\lambda$} has the property \relax{$C_\lambda\!\tcmulti C$}
 for all configurations \relax{$C$}.\relax{\vspace{1ex}
}

\noindent{}In terms of prior work, the \relax{$\tcstep$} relation includes all
 possible \emph{type conversion steps}\relax{~\citep{tfgnvf-popl-2016,gtnffvf-jfp-2019}}.
The \relax{$\tcmulti$} relation corresponds to \emph{term precision}\relax{~\citep{svcb-snapl-2015}} as follows:
 \relax{$e_0 \tcmulti\, e_1 \mbox{ only if } e_1 \sqle e_0$}.

An evaluation must measure overhead relative to a useful baseline.
For migratory typing, the correct baseline is the original host{-}language program.

\relax{\vspace{1ex}
}\textbf{Definition} (\emph{baseline}) The \emph{baseline performance} of a program is its running time in the absence
 of migratory typing.\relax{\vspace{1ex}
}

In Typed Racket, the baseline is the performance of Racket running the
 untyped configuration.
In Reticulated, the baseline is Python running the untyped configuration.
Be advised, Python{-}running{-}untyped differs from Reticulated{-}running{-}untyped
 because Reticulated inserts checks in every migratable module that
 it sees\relax{~\citep{vksb-dls-2014}}.

\relax{\vspace{1ex}
}\textbf{Definition} (\emph{performance ratio}) A \emph{performance ratio} is the running time of a configuration
 divided by the baseline performance.\relax{\vspace{1ex}
}

An exhaustive performance evaluation measures the performance of every
 configuration.
To summarize the data, choose a notion of
 {``}good performance{''} and count the proportion of {``}good{''} configurations.
In this spirit, \relax{\citet{tfgnvf-popl-2016}} ask programmers to consider the
 performance overhead they could deliver to clients.

\relax{\vspace{1ex}
}\textbf{Definition} (\emph{\relax{$D$}{-}deliverable}) A configuration is \emph{\relax{$D$}{-}deliverable},
 for some \relax{$D \in \mathbb{R}^{+}$},
 if its performance ratio is no greater than \relax{$D$}.\relax{\vspace{1ex}
}

\Ssubsubsection{Known Limitations}{Known Limitations}\label{t:x28part_x22secx3aperfx3alimitsx22x29}

Evaluation begins with a fixed set of types, but there are usually many
 ways to type a piece of code.
Consider the application of an identity function to a number:

\relax{\medskip}
\raisebox{-0.7999999999999972bp}{\makebox[88.8bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_6.pdf}}}

\noindent{}In Typed Racket, the parameter \Scribtexttt{x} can be given infinitely many
 correct types.
The obvious choices are \Scribtexttt{Integer} and \Scribtexttt{Number},
 but other base types work, including \Scribtexttt{Real} and \Scribtexttt{Natural}.
Untagged unions bring many options: \Scribtexttt{(U Real String)}, \Scribtexttt{(U Real String ({-}{\Stttextmore} Boolean))},
 and so on.
Different choices entail different run{-}time checks, but the method lacks
 a systematic way to explore equally{-}valid typings.

Along the same lines, the definition of granularity does not talk about
 imprecise types.
In Reticulated, the type \Scribtexttt{Function([Str], Int)} has three
 less{-}precise variants that incorporate the dynamic type.
The method only looks at one fully{-}typed variant, but the others may
 have notable performance implications.

Overhead plots (\hyperref[t:x28counter_x28x22figurex22_x22figx3aoverheadx2dplotx2dexamplex22x29x29]{figure~\FigureRef{4}{t:x28counter_x28x22figurex22_x22figx3aoverheadx2dplotx2dexamplex22x29x29}}) rest on two assumptions.
First is that configurations with less than 2x overhead
 are significantly more practical than configurations with a 10x overhead or more.
Hence the plots use a log{-}scaled x{-}axis to encourage
 fine{-}grained comparison in the 1.2x to 1.6x overhead range and to blur the
 distinction among larger numbers.
Second is that configurations with more than 20x
 overhead are completely unusable in practice.
Pathologies like the 1000x slowdowns in \hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex22x29x29]{figure~\FigureRef{3}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex22x29x29}}
 represent a challenge for implementors, but if these overheads suddenly
 dropped to 30x, the configurations would still be useless to developers.

The main limitation of exhaustive evaluation, however, is its exhaustiveness.
With 20 migratable units, an experiment requires over 1 million measurements.
At a module{-}level granularity, this limit is somewhat reasonable because each
 module can be arbitrarily large.
But at function{-}level granularity and finer, the practical limit quickly rules
 out interesting programs.

\Ssubsection{Approximate Evaluation Method}{Approximate Evaluation Method}\label{t:x28part_x22Approximatex5fEvaluationx5fMethodx22x29}

The proportion of \relax{$D$}{-}deliverable configurations in a program can be
 approximated using random sampling.
First, choose several configurations and measure the proportion of
 \relax{$D$}{-}deliverable configurations in the sample.
Next, repeat the experiment several times.
Combining the proportions in a confidence interval provides an estimate
 for the true proportion.

\relax{\vspace{1ex}
}\textbf{Definition} (\emph{\relax{$95$}\%{-}\relax{$r, s$}{-}approximation}) Given \relax{$r$} samples each containing \relax{$s$} configurations chosen uniformly at random,
 a simple random approximation is a \relax{$95\%$} confidence interval for
 the proportion of \relax{$D$}{-}deliverable configurations in each sample.\relax{\vspace{1ex}
}

Intuitively, this method should lead to good results because
 it randomly samples a stable population.
If the true proportion of \relax{$D$}{-}deliverable configurations in a program
 happens to be 10\%, then a random configuration has a 1 in 10
 chance of being \relax{$D$}{-}deliverable.

A statistical justification depends on the law of large numbers
 and the central limit theorem.
Let \relax{$d$} be a predicate that checks whether a configuration
 is \relax{$D$}{-}deliverable.
Since \relax{$d$} is either true or false for every configuration,
 this predicate defines a Bernoulli random variable \relax{$X_d$} with parameter
 \relax{$p$}, where \relax{$p$} is the true proportion of \relax{$D$}{-}deliverable configurations.
Consequently, the expected value of this random variable is \relax{$p$}.
The law of large numbers states that the average of \emph{infinitely}
 many samples of \relax{$X_d$} converges to \relax{$p$}, the true proportion
 of deliverable configurations.
We cannot draw infinitely many samples, but perhaps this convergence
 property means that the average of {``}enough{''} samples is {``}close{''} to \relax{$p$}.
The central limit theorem implies that any sequence of
 such averages is normally distributed around the true proportion.
A \relax{$95\%$} confidence interval generated from sample averages is therefore
 likely to contain the true proportion.

The statistical argument reveals two weaknesses:

\begin{itemize}\atItemizeStart

\item First, there is no guarantee that every confidence interval based on sampling
 contains the true proportion of \relax{$D$}{-}deliverable configurations.
The results can mislead.

\item Second, the confidence intervals could be huge.
A wide interval offers little insight, even if it happens to contain the
 true proportion.
In the extreme, a totally useless interval says that 0\% to 100\% of configurations
 are \relax{$D$}{-}deliverable.\end{itemize}

\noindent{}The argument does say, however, that an interval is very likely to
 be useful if it is based on a huge number of samples each with a huge number
 of configurations.
The challenge is to find parameters that engineer a compromise between
 size and precision.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.6000000000000227bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_7.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atrx3avalidatex2dsamplex22x29x29}Figure~6: }{t:x28counter_x28x22figurex22_x22figx3atrx3avalidatex2dsamplex22x29x29}Typed Racket sample validation.}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.6000000000000227bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_8.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3arpx3avalidatex2dsamplex22x29x29}Figure~7: }{t:x28counter_x28x22figurex22_x22figx3arpx3avalidatex2dsamplex22x29x29}Reticulated sample validation.}}\end{FigureMulti}

By comparing sample data to the ground{-}truth from an exhaustive evaluation,
 I have found that linear sampling gives small and accurate intervals.
\hyperref[t:x28counter_x28x22figurex22_x22figx3atrx3avalidatex2dsamplex22x29x29]{Figures~\FigureRef{6}{t:x28counter_x28x22figurex22_x22figx3atrx3avalidatex2dsamplex22x29x29}} and \hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3avalidatex2dsamplex22x29x29]{\FigureRef{7}{t:x28counter_x28x22figurex22_x22figx3arpx3avalidatex2dsamplex22x29x29}} demonstrate
 on a few Typed Racket and Reticulated programs.
The blue curve and shaded area on each plot is the exhaustive data.
The orange interval is a 95\% confidence interval based on
 \relax{$r\!=\!10$} each containing
 \relax{$s\!=\!10\!*\!N$} configurations,
 where \relax{$N$} is the number of typed units in the benchmark program.
The sample intervals all tightly cover the true proportion
 of \relax{$D$}{-}deliverable configurations.

\Ssubsubsection{Statistical Protocol}{Statistical Protocol}\label{t:x28part_x22Statisticalx5fProtocolx22x29}

For readers interested in reproducing the above results, here are
 additional details about
 the protocol behind \hyperref[t:x28counter_x28x22figurex22_x22figx3atrx3avalidatex2dsamplex22x29x29]{figures~\FigureRef{6}{t:x28counter_x28x22figurex22_x22figx3atrx3avalidatex2dsamplex22x29x29}} and \hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3avalidatex2dsamplex22x29x29]{\FigureRef{7}{t:x28counter_x28x22figurex22_x22figx3arpx3avalidatex2dsamplex22x29x29}}.

To generate one random sample, select \relax{$10\!*\!N$} configurations
 uniformly at random and compute their overhead.
Sampling with replacement gives the same theoretical results as sampling
 without replacement.
The figures employ sampling without replacement in the hope of finding
 new configurations with exceptional overhead.

To generate a confidence interval for the number of \relax{$D$}{-}deliverable
 configurations based on a group of samples, calculate
 the proportion of \relax{$D$}{-}deliverable configurations in each sample and generate
 a 95\% confidence interval from the proportions.
This is the simple index method for computing a
 confidence interval from a sequence of ratios (\href{https://arxiv.org/pdf/0710.2024v1.pdf}{\Snolinkurl{arxiv.org/pdf/0710.2024v1.pdf}}).
A more advanced method may give tighter intervals, if extra precision is needed\relax{~\citep{f-rss-1957}}.

\Ssubsection{Benchmark Selection}{Benchmark Selection}\label{t:x28part_x22Benchmarkx5fSelectionx22x29}

Representative benchmarks are difficult to come by.
My best{-}effort approach is to seek out programs that serve a realistic
 purpose.
Several implement games, and re{-}play a game round.
Others adapt library code with an example use.
All of the forthcoming Typed Racket benchmarks follow this approach (chapter~\SecRefLocal{t:x28part_x22secx3atrx3abenchmarksx22x29}{3.5.2}{Benchmarks}).
Many of the Reticulated benchmarks (chapter~\SecRefLocal{t:x28part_x22secx3arpx3abenchmarksx22x29}{3.6.2}{Benchmarks}), however, come from prior work and
 are smaller scripts in the spirit of the Gabriel benchmarks\relax{~\citep{g-1985}}.

\Ssubsubsection{From Programs to Benchmarks}{From Programs to Benchmarks}\label{t:x28part_x22secx3aconversionx22x29}

To convert a program into a benchmark, we:


\noindent \begin{enumerate}\atItemizeStart

\item partition the program into migratable and contextual code;

\item build a migratable driver module that runs the program and collects timing information;

\item remove any non{-}determinism or I/O actions;

\item find types for the migratable code.\end{enumerate}

The final step, finding types for untyped code, can be difficult.
First, the type checker may require casts or refactorings to deal with
 untyped code.
For example, untyped Racket code may assume that the
 application \Scribtexttt{(string{-}{\Stttextmore}number "42")} returns an integer.
The assumption is correct, but the type checker cannot follow the reasoning
 and needs a run{-}time check.
Reticulated does not have union types, and therefore falls back to \Scribtexttt{Dyn}
 for many common untyped patterns.
An experimenter must choose whether to rewrite the pattern or accept the
 trivial typing.

Second, some deep type boundaries may lack run{-}time support.
Typed Racket cannot enforce the type \Scribtexttt{(U ({-}{\Stttextmore} Real) ({-}{\Stttextmore} Integer))}
 at a boundary because its contracts lack unions for higher{-}order wrappers.
The work{-}around is to rewrite the boundaries or, if possible, simplify
 the types.
For the above, \Scribtexttt{({-}{\Stttextmore} Real)} is a viable choice.

Third, each static import of a struct type into Typed Racket code
 generates a unique datatype.
Typed modules that share instances of an untyped struct must therefore
 reference a common definition.
Typed Racket benchmarks with this issue include additional contextual
 modules, called \emph{adaptor modules}, to provide a canonical import.

\Ssubsection{Application 1: Typed Racket}{Application 1: Typed Racket}\label{t:x28part_x22secx3atrx3aevaluationx22x29}

This section presents an exhaustive evaluation of Typed Racket v7.7
 on a set of twenty{-}one benchmark programs;
 namely, the GTP suite v6.0 (\href{https://docs.racket-lang.org/gtp-benchmarks/index.html}{\Snolinkurl{docs.racket-lang.org/gtp-benchmarks/index.html}}).
The main purpose of this evaluation is to confirm that the
 exhaustive method provides a useful summary of a mixed{-}typed language.
A secondary result is that it reveals performance challenges
 that Typed Racket must overcome.

\Ssubsubsection{Protocol}{Protocol}\label{t:x28part_x22secx3atrx3aprotocolx22x29}

\paragraph{Granularity}
The granularity of this evaluation is \emph{modules}, same as the granularity
 of Typed Racket.
One syntactic unit in the experiment is one entire module.

\paragraph{Data Collection}

For each configuration in each benchmark, a control script compiled
 the whole program, ran once ignoring performance, and ran four more times
 collecting data.
These actions used the standard Racket 7.7 BC bytecode compiler,
 JIT compiler, and runtime settings.
The control script ran on a dedicated Linux machine with a i7{-}4790
 processor.
The processor has 16GB RAM and four cores,
 and ran at 3.60GHz.

\Ssubsubsection{Benchmarks}{Benchmarks}\label{t:x28part_x22secx3atrx3abenchmarksx22x29}

This section summarizes twenty{-}one benchmark programs.
These benchmarks are sorted in order of increasing size, as measured by the
 number of migratable modules.
Each summary comes with four fields:
 \emph{Origin} indicates the benchmark{'}s source,
 \emph{Purpose} describes what it computes,
 \emph{Author} credits the original author,
 and \emph{Depends} lists significant contextual libraries that the benchmark depends on.

\relax{\bigskip}
\relax{\benchmark{\relax{\textsf{sieve}}}{Ben Greenman}{Synthetic}{Generate prime numbers}{Demonstrates a scenario where client code is tightly coupled to higher-order library code.
The library implements a stream data structure; the client builds a stream of prime numbers.}{}{None}

}
\relax{\benchmark{\relax{\textsf{forth}}}{Ben Greenman}{\href{http://docs.racket-lang.org/forth/index.html}{Library}}{Forth interpreter}{Interprets Forth programs.
The interpreter represents calculator commands as a list of first-class objects.}{}{None}

}
\relax{\benchmark{\relax{\textsf{fsm}}, \relax{\textsf{fsmoo}}}{Linh Chi Nguyen}{\href{https://github.com/mfelleisen/sample-fsm}{Economics research}}{Economy simulator}{Simulates the interactions of economic agents via finite-state automata\relax{~\citep{na-eai-2016}}.
This benchmark comes in two flavors: \relax{\textsf{fsm}} stores the agents in a mutable vector and \relax{\textsf{fsmoo}} uses a first-class object.}{}{None}

}
\relax{\benchmark{\relax{\textsf{mbta}}}{Matthias Felleisen}{Educational}{Interactive map}{Builds a map of Boston{'}s subway system and answers reachability queries.
The map interacts with Racket{'}s untyped \Scribtexttt{graph} library.}{}{\href{http://github.com/stchang/graph}{\Scribtexttt{graph}}}

}
\relax{\benchmark{\relax{\textsf{morsecode}}}{John Clements and Neil Van Dyke}{\href{https://github.com/jbclements/morse-code-trainer/tree/master/morse-code-trainer}{Library}}{Morse code trainer}{Computes Levenshtein distances\relax{~\citep{l-spd-1966}} and morse code translations for a fixed sequence of pairs of words.}{}{None}

}
\relax{\benchmark{\relax{\textsf{zombie}}}{David Van Horn}{\href{https://github.com/philnguyen/soft-contract}{Research}}{Game}{Implements a game where players dodge {``}zombie{''} tokens.
Curried functions over symbols implement game entities and repeatedly cross type boundaries.}{}{None}

}
\relax{\benchmark{\relax{\textsf{dungeon}}}{Vincent St. Amour}{Application}{Maze generator}{Builds a grid of wall and floor objects by choosing first-class classes from a list of {``}template{''} pieces.
Originally, the program imported the Racket \Scribtexttt{math} library
 for array operations.
The benchmark uses Racket{'}s vectors instead of the \Scribtexttt{math} library{'}s arrays
 because Typed Racket v6.2 cannot compile the type \Scribtexttt{(Mutable{-}Array (Class))} to a contract.}{}{None}

}
\relax{\benchmark{\relax{\textsf{jpeg}}}{Andy Wingo}{\href{http://github.com/wingo/racket-jpeg}{Library}}{JPEG toolkit}{Parses a bytestream of JPEG data to an internal representation, then serializes the result.}{}{\href{https://docs.racket-lang.org/math/array.html}{\Scribtexttt{math/array}}, \Shref{https://docs.racket-lang.org/r6rs/R6RS_Libraries.html}{(mod-path._rnrs\%2Fbytevectors-6)}{\Scribtexttt{rnrs/bytevectors{-}6}}}

}
\relax{\benchmark{\relax{\textsf{zordoz}}}{Ben Greenman}{\href{http://github.com/bennn/zordoz}{Library}}{Explore bytecode}{Traverses Racket bytecode (\Scribtexttt{{\hbox{\texttt{.}}}zo} files).
The untyped \Scribtexttt{compiler{-}lib} library defines the bytecode data structures.}{}{\Shref{http://docs.racket-lang.org/raco/decompile.html}{\%28mod-path._compiler\%2Fdecompile\%29}{\Scribtexttt{compiler{-}lib}}}

}
\relax{\benchmark{\relax{\textsf{lnm}}}{Ben Greenman}{Synthetic}{Data visualization}{Renders overhead plots.
Two modules are tightly-coupled to Typed Racket libraries.}{}{\href{https://docs.racket-lang.org/plot/}{\Scribtexttt{plot}}, \href{https://docs.racket-lang.org/math/stats.html}{\Scribtexttt{math/statistics}}}

}
\relax{\benchmark{\relax{\textsf{suffixtree}}}{Danny Yoo}{\href{https://github.com/dyoo/suffixtree}{Library}}{String tools}{Implements Ukkonen{'}s suffix tree algorithm\relax{~\citep{u-a-1995}}
 and computes longest common subsequences between strings.}{}{None}

}
\relax{\benchmark{\relax{\textsf{kcfa}}}{Matt Might}{\href{http://matt.might.net/articles/implementation-of-kcfa-and-0cfa/}{Educational}}{Explanation of k-CFA}{Performs 1-CFA on a lambda calculus term that computes \relax{$~2*(1+3) = 2*1 + 2*3$} via Church numerals.
The (mutable) binding environment flows throughout functions in the benchmark.}{}{None}

}
\relax{\benchmark{\relax{\textsf{snake}}}{David Van Horn}{\href{https://github.com/philnguyen/soft-contract}{Research}}{Game}{Implements the Snake game; the benchmark replays a fixed sequence of moves.}{}{None}

}
\relax{\benchmark{\relax{\textsf{take5}}}{Matthias Felleisen}{Educational}{Game}{Manages a card game between AI players.}{}{None}

}
\relax{\benchmark{\relax{\textsf{acquire}}}{Matthias Felleisen}{\href{https://github.com/mfelleisen/Acquire}{Educational}}{Game}{Simulates a board game via message-passing objects.
These objects encapsulate the core data structures and seldom cross module boundaries.}{}{None}

}
\relax{\benchmark{\relax{\textsf{tetris}}}{David Van Horn}{\href{https://github.com/philnguyen/soft-contract}{Research}}{Game}{Replays a pre-recorded game of Tetris.}{}{None}

}
\relax{\benchmark{\relax{\textsf{synth}}}{Vincent St. Amour and Neil Toronto}{\href{http://github.com/stamourv/synth}{Application}}{Music synthesis DSL}{Converts a description of notes and drum beats to \Scribtexttt{WAV} format.
Modules in the benchmark come from two sources, a music library and an array library.}{}{None}

}
\relax{\benchmark{\relax{\textsf{gregor}}}{Jon Zeppieri}{\href{https://docs.racket-lang.org/gregor/index.html}{Library}}{Date and time library}{Provides tools for manipulating calendar dates.
The benchmark builds tens of date values and runs unit tests on these values.}{}{\href{https://docs.racket-lang.org/cldr-core/index.html}{\Scribtexttt{cldr}}, \href{https://docs.racket-lang.org/tzinfo/index.html}{\Scribtexttt{tzinfo}}}

}
\relax{\benchmark{\relax{\textsf{quadT}}, \relax{\textsf{quadU}}}{Matthew Butterick}{\href{https://github.com/mbutterick/quad}{Application}}{Typesetting}{Converts S-expression source code to \Scribtexttt{PDF} format.
The two versions of this benchmark came from the original author.
First, \relax{\textsf{quadU}} is based on a foundational untyped codebase.
Second, \relax{\textsf{quadT}} comes from a migrated, typed codebase with slightly
 different behavior.
Overhead is worse in \relax{\textsf{quadT}}, but the types in \relax{\textsf{quadU}}
 are far less descriptive.
}{}{\href{https://github.com/mbutterick/csp}{\Scribtexttt{csp}}}

}

\hyperref[t:x28counter_x28x22figurex22_x22figx3atrx3astaticx2dbenchmarkx22x29x29]{Figure~\FigureRef{8}{t:x28counter_x28x22figurex22_x22figx3atrx3astaticx2dbenchmarkx22x29x29}} tabulates the size of the migratable
 code in the benchmark programs.
The column labeled \textbf{N} reports the number of migratable modules;
 the configuration space for each program has \relax{$2^N$} points.
The SLOC column reports lines of code in the fully{-}typed configuration.
With type annotations, these benchmarks gain between 10 and 300 lines of
 code.
For details about the graph structure of each benchmark and
 the specific types on boundaries, refer to the GTP web page: \href{https://docs.racket-lang.org/gtp-benchmarks/index.html}{\Snolinkurl{docs.racket-lang.org/gtp-benchmarks/index.html}}.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\begin{SCentered}\begin{tabular}[t]{@{}l@{}l@{}r@{}r@{}r@{}}
\hbox{} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{} \\
\hbox{Benchmark} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{\textbf{N}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{SLOC} \\
\hline \hbox{\relax{\textsf{sieve}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{52} \\
\hbox{\relax{\textsf{forth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{300} \\
\hbox{\relax{\textsf{fsm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{248} \\
\hbox{\relax{\textsf{fsmoo}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{279} \\
\hbox{\relax{\textsf{mbta}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{357} \\
\hbox{\relax{\textsf{morsecode}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{264} \\
\hbox{\relax{\textsf{zombie}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{342} \\
\hbox{\relax{\textsf{dungeon}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{624} \\
\hbox{\relax{\textsf{jpeg}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1599} \\
\hbox{\relax{\textsf{zordoz}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1624} \\
\hbox{\relax{\textsf{lnm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{6} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{636} \\
\hbox{\relax{\textsf{suffixtree}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{6} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{671} \\
\hbox{\relax{\textsf{kcfa}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{296} \\
\hbox{\relax{\textsf{snake}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{8} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{209} \\
\hbox{\relax{\textsf{take5}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{8} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{364} \\
\hbox{\relax{\textsf{acquire}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{9} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2012} \\
\hbox{\relax{\textsf{tetris}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{9} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{357} \\
\hbox{\relax{\textsf{synth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{10} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{974} \\
\hbox{\relax{\textsf{gregor}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{13} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1156} \\
\hbox{\relax{\textsf{quadT}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{14} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7019} \\
\hbox{\relax{\textsf{quadU}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{14} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7055}\end{tabular}\end{SCentered}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atrx3astaticx2dbenchmarkx22x29x29}Figure~8: }{t:x28counter_x28x22figurex22_x22figx3atrx3astaticx2dbenchmarkx22x29x29}Static characteristics of the migratable code in the \relax{\textsc{gtp}} benchmarks.
\textbf{N} = number of components = number of modules.
SLOC = source lines of fully{-}typed code as reported by \href{https://dwheeler.com/sloccount/}{David A{\hbox{\texttt{.}}} Wheeler{'}s \Scribtexttt{sloccount}}.}}\end{FigureMulti}

\Ssubsubsection{Performance Ratios}{Performance Ratios}\label{t:x28part_x22secx3atrx3aratiox22x29}

\begin{Figure}\begin{Centerfigure}\begin{FigureInside}\begin{SCentered}\begin{tabular}[t]{@{}l@{}l@{}r@{}}
\hbox{Benchmark} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{typed/untyped} \\
\hline \hbox{\relax{\textsf{sieve}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.97} \\
\hbox{\relax{\textsf{forth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.65} \\
\hbox{\relax{\textsf{fsm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.54} \\
\hbox{\relax{\textsf{fsmoo}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.88} \\
\hbox{\relax{\textsf{mbta}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.63} \\
\hbox{\relax{\textsf{morsecode}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.73} \\
\hbox{\relax{\textsf{zombie}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.79} \\
\hbox{\relax{\textsf{dungeon}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.99} \\
\hbox{\relax{\textsf{jpeg}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.40} \\
\hbox{\relax{\textsf{zordoz}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.35} \\
\hbox{\relax{\textsf{lnm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.64} \\
\hbox{\relax{\textsf{suffixtree}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.69} \\
\hbox{\relax{\textsf{kcfa}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.04} \\
\hbox{\relax{\textsf{snake}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.96} \\
\hbox{\relax{\textsf{take5}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.97} \\
\hbox{\relax{\textsf{acquire}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.22} \\
\hbox{\relax{\textsf{tetris}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.97} \\
\hbox{\relax{\textsf{synth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.96} \\
\hbox{\relax{\textsf{gregor}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.98} \\
\hbox{\relax{\textsf{quadT}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.99} \\
\hbox{\relax{\textsf{quadU}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.79}\end{tabular}\end{SCentered}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atrx3aratiox22x29x29}Figure~9: }{t:x28counter_x28x22figurex22_x22figx3atrx3aratiox22x29x29}Coarse ratios for the \relax{\textsc{gtp}} benchmarks v6.0 on Racket v7.7.}}\end{Figure}

\noindent \hyperref[t:x28counter_x28x22figurex22_x22figx3atrx3aratiox22x29x29]{Figure~\FigureRef{9}{t:x28counter_x28x22figurex22_x22figx3atrx3aratiox22x29x29}} lists the overhead of fully{-}typed code relative
 to untyped code.
In \relax{\textsf{sieve}}, for example, the typed configuration runs slightly
 faster than untyped.
In \relax{\textsf{mbta}}, the typed configuration is over 1.5x slower
 because of a boundary to an untyped contextual module.

Overall, many benchmarks run significantly faster with types
 (8 of 21).
These programs have few boundaries to untyped contextual modules
 and benefit from type{-}directed compilation.
The highest ratios stay within a modest 2x overhead.

\Ssubsubsection{Overhead Plots}{Overhead Plots}\label{t:x28part_x22secx3atrx3aoverheadx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.6000000000000227bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_9.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a0x22x29x29}Figure~10: }{t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a0x22x29x29}Typed Racket overhead plots (1/3). The \relax{$x$}{-}axis ranges over slowdown factors,
the \relax{$y$}{-}axis counts configurations,
and a point (x, y) shows the proportion of \relax{$x$}{-}deliverable configurations.}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.6000000000000227bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_10.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a1x22x29x29}Figure~11: }{t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a1x22x29x29}Typed Racket overhead plots (2/3).}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.6000000000000227bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_11.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a2x22x29x29}Figure~12: }{t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a2x22x29x29}Typed Racket overhead plots (3/3).}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a0x22x29x29]{Figures~\FigureRef{10}{t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a0x22x29x29}}, \hyperref[t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a1x22x29x29]{\FigureRef{11}{t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a1x22x29x29}}, and \hyperref[t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a2x22x29x29]{\FigureRef{12}{t:x28counter_x28x22figurex22_x22figx3atrx3aoverheadx3a2x22x29x29}}
 present an exhaustive evaluation in a series of overhead plots.
As in \hyperref[t:x28counter_x28x22figurex22_x22figx3aoverheadx2dplotx2dexamplex22x29x29]{figure~\FigureRef{4}{t:x28counter_x28x22figurex22_x22figx3aoverheadx2dplotx2dexamplex22x29x29}}, the plots are cumulative
 distribution functions for the proportion of \relax{$D$}{-}deliverable configurations.

Many curves are quite flat; they demonstrate that migratory typing introduces
 large and widespread performance overhead in the corresponding benchmarks.
Among benchmarks with fewer than six modules, the
 most common shape is a flat line near the 50\% mark.
Such lines imply that the performance of a group of configurations is
 dominated by a single type boundary.
For instance, there is one type boundary in \relax{\textsf{fsmoo}} that adds overwhelming
 slowdown when present; all eight configurations with this boundary have over
 20 overhead.
Benchmarks with six or more modules generally have
 smoother slopes, but five such benchmarks have essentially flat curves.
The overall message is that for many values of \relax{$D$} between 1 and
 20, few configurations are \relax{$D$}{-}deliverable.

In 15 benchmarks, no more than half the configurations
 are \relax{$2$}{-}deliverable.
This is quite bad.
The situation is worse for lower (more realistic) overheads, and rarely
 improve at slightly higher overheads.
Even at a generous 10x factor, no more than half the configurations in
 nine benchmarks are good enough.

The curves{'} endpoints describe the extremes of migratory typing.
The left endpoint gives the percentage of configurations that run at least
 as quickly as the untyped configuration.
With few exceptions, notably \relax{\textsf{lnm}}, these configurations are a low proportion of the total.
The right endpoint shows how many configurations suffer at least 20x overhead.
Ten benchmarks have at least one such configuration.

In summary, the application of the evaluation method projects a negative
 image of Typed Racket{'}s sound migratory typing.
Only a small number of configurations in the benchmark suite run with low
 overhead; a mere 16\% of all configurations are \relax{$1.4$}{-}deliverable on
 Racket v7.7.
Many demonstrate extreme overhead; only 81\% of all configurations are
 \relax{$20$}{-}deliverable on v7.7.

\Ssubsubsection{Threats to Validity}{Threats to Validity}\label{t:x28part_x22secx3atrx3athreatsx22x29}

The concerns raised in chapter~\SecRefLocal{t:x28part_x22secx3aconversionx22x29}{3.4.1}{From Programs to Benchmarks} affect this evaluation.
In particular, each benchmark explores one choice of types.
Different types may lead to different conclusions, as \relax{\textsf{quadT}} and
 \relax{\textsf{quadU}} demonstrate at a small scale.

Some benchmarks use a different modularization than the original program.
The \relax{\textsf{kcfa}} benchmark is modularized according to comments in the original,
 single{-}module program.
The \relax{\textsf{suffixtree}}, \relax{\textsf{synth}}, and \relax{\textsf{gregor}} benchmarks each have a single
 file containing all their data structure definitions, but the original programs
 defined these structures in the same module as the functions on the structures.

\Ssubsection{Application 2: Reticulated Python}{Application 2: Reticulated Python}\label{t:x28part_x22secx3arpx3aevaluationx22x29}

Reticulated Python is the original home of the transient semantics for
 mixed{-}typed programs\relax{~\citep{v-thesis-2019}}.
Transient is a type{-}sound semantics (chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method})
 that does not rely on higher{-}order wrappers or full run{-}time checks.
Instead, transient uses light {``}shape checks{''} throughout typed code.
One would expect fast performance from transient on mixed{-}typed code.
The first{-}ever evaluation, however, only reports data for untyped and fully{-}typed
 programs\relax{~\citep{vss-popl-2017}}.

This section presents a systematic evaluation of
 Reticulated without its experimental blame algorithm\relax{~\citep{gm-pepm-2018}}.
The data offers a big{-}picture view of transient,
 further validates the approximate method,
 and identifies bugs in the measured version of Reticulated.
Overall, transient checks never exceed a 10x slowdown in the benchmarks.

\Ssubsubsection{Protocol}{Protocol}\label{t:x28part_x22secx3arpx3aprotocolx22x29}

\paragraph{Granularity}
The granularity of this evaluation is \emph{function and class fields}.
One syntactic unit in the experiment is either one function,
 one method, or the collection of all fields for one class.
\hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3aexamplex2dclassx22x29x29]{Figure~\FigureRef{13}{t:x28counter_x28x22figurex22_x22figx3arpx3aexamplex2dclassx22x29x29}} demonstrates this granularity with
 a simple Reticulated module.
The class \Scribtexttt{Cash} has two fields and one method that requires three arguments;
 the module also include a function that instantiates a \Scribtexttt{Cash} object with exactly
 5 dollars.
Reticulated permits the removal of every type in the figure, giving
 \relax{$128$} possible configurations.
The granularity for our experiment, however, explores the \relax{$8$} configurations
 obtained by removing types from the field declaration, the method, and/or the
 function each as a complete unit.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.799999999999983bp}{\makebox[265.6000000000001bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_12.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3arpx3aexamplex2dclassx22x29x29}Figure~13: }{t:x28counter_x28x22figurex22_x22figx3arpx3aexamplex2dclassx22x29x29}Reticulated code that leads to \relax{$2^3$} configurations in the experiment, but supports \relax{$2^7$} total.}}\end{FigureMulti}

\paragraph{Data Collection}
The data is exhaustive for benchmarks with at most \relax{$2^{17}$} configurations
 and approximate for larger benchmarks.
The approximations use ten samples
 each containing \relax{$10\!*\!(F + C)$} configurations,
 where \relax{$F$} is the number of functions in the benchmark and
 \relax{$C$} is the number of classes.

All data comes from jobs that we ran on the
 \href{https://kb.iu.edu/d/bezu}{\emph{Karst at Indiana University}}
 computing cluster.
Each job:


\noindent \begin{enumerate}\atItemizeStart

\item reserved all processors on one node;

\item downloaded fresh copies of Python 3.4.3
and Reticulated commit \href{https://github.com/mvitousek/reticulated/commit/e478343ce7c0f2bc50d897b0ad38055e8fd9487d}{\Scribtexttt{e478343}};

\item repeatedly:
selected a random configuration from a random benchmark,
ran the configuration{'}s main module 40 times,
and recorded the result of each run.\end{enumerate}

\noindent Cluster nodes are IBM NeXtScale nx360 M4 servers with two Intel Xeon E5{-}2650 v2
 8{-}core processors, 32 GB of RAM, and 250 GB of local disk storage.
All data collection scripts are online:
 \href{https://github.com/nuprl/retic_performance}{\Snolinkurl{github.com/nuprl/retic_performance}}

\Ssubsubsection{Benchmarks}{Benchmarks}\label{t:x28part_x22secx3arpx3abenchmarksx22x29}

Five benchmarks originate from case studies by \relax{\citet{vksb-dls-2014}}.
Twelve are from the evaluation by \relax{\citet{vss-popl-2017}} on programs from
the Python Performance Benchmark Suite.
The remaining four originate from open{-}source programs.

The following descriptions credit each benchmark{'}s original author,
 state whether the benchmark depends on any contextual modules,
 and briefly summarize its purpose.

\relax{\bigskip}
\relax{\benchmark{\relax{\textsf{fannkuch}}}{Sokolov Yura}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Test integers, vectors}{Implements a classic LISP microbenchmark\relax{~\citep{ar-lp-1994}}.}{}{None}

}
\relax{\benchmark{\relax{\textsf{nqueens}}}{unknown}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Puzzle}{Solves the \href{https://developers.google.com/optimization/puzzles/queens}{\relax{$8$}{-}queens} problem by a brute-force algorithm.}{}{None}

}
\relax{\benchmark{\relax{\textsf{http2}}}{\href{https://github.com/httplib2/httplib2}{Joe Gregorio}}{\href{https://github.com/httplib2/httplib2}{Library}}{HTTP utilities}{Converts a collection of \href{https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier}{Internationalized Resource Identifiers}
to equivalent \href{http://www.asciitable.com/}{ASCII} resource
identifiers.}{}{\href{https://docs.python.org/3/library/urllib.html}{\Scribtexttt{urllib}}}

}
\relax{\benchmark{\relax{\textsf{nbody}}}{Kevin Carson}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Test float ops}{Models the orbits of Jupiter, Saturn, Uranus, and Neptune.}{}{None}

}
\relax{\benchmark{\relax{\textsf{pidigits}}}{unknown}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Test big integer ops}{Microbenchmarks big-integer arithmetic.}{}{None}

}
\relax{\benchmark{\relax{\textsf{spectralnorm}}}{Sebastien Loisel}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Test arithmetic}{Computes the largest singular value of an infinite matrix.}{}{None}

}
\relax{\benchmark{\relax{\textsf{call\_simple}}}{unknown}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Test function calls}{Same as \relax{\textsf{call\_method}}, using functions rather than methods.}{}{None}

}
\relax{\benchmark{\relax{\textsf{float}}}{Factor}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Test float ops}{Microbenchmarks floating-point operations.}{}{\href{https://docs.python.org/3/library/math.html}{\Scribtexttt{math}}}

}
\relax{\benchmark{\relax{\textsf{call\_method}}}{unknown}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Test method calls}{Microbenchmarks simple method calls;
the calls do not use argument lists,
keyword arguments, or tuple unpacking.}{}{None}

}
\relax{\benchmark{\relax{\textsf{go}}}{unknown}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Game}{Implements the game \href{https://en.wikipedia.org/wiki/Go_(game)}{Go}.
This benchmark is split across three files: a migratable module that implements
the game board, a contextual module that defines constants, and a contextual module
that implements an AI and drives the benchmark.}{}{\href{https://docs.python.org/3/library/math.html}{\Scribtexttt{math}}, \href{https://docs.python.org/3/library/random.html}{\Scribtexttt{random}}}

}
\relax{\benchmark{\relax{\textsf{meteor}}}{Daniel Nanz}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Puzzle}{Solves the Shootout benchmarks meteor puzzle.}{}{None}

}
\relax{\benchmark{\relax{\textsf{Espionage}}}{Zeina Migeed}{Synthetic}{Graph algorithm}{Implements Kruskal{'}s spanning-tree algorithm.}{}{\href{https://docs.python.org/3/library/operator.html}{\Scribtexttt{operator}}}

}
\relax{\benchmark{\relax{\textsf{PythonFlow}}}{Alfian Ramadhan}{\href{https://github.com/masphei/PythonFlow}{Synthetic}}{Flow algorithm}{Implements the Ford-Fulkerson algorithm.}{}{\href{https://docs.python.org/3/library/os.html}{\Scribtexttt{os}}}

}
\relax{\benchmark{\relax{\textsf{pystone}}}{Chris Arndt}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Test integer ops}{Implements Weicker{'}s \href{http://www.eembc.org/techlit/datasheets/ECLDhrystoneWhitePaper2.pdf}{Dhrystone} benchmark.}{}{None}

}
\relax{\benchmark{\relax{\textsf{chaos}}}{Carl Friedrich Bolz}{\href{https://github.com/python/performance}{\href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}}}}{Create fractals}{Creates fractals using the \href{https://en.wikipedia.org/wiki/Chaos_game}{chaos game} method.}{}{\href{https://docs.python.org/3/library/math.html}{\Scribtexttt{math}}, \href{https://docs.python.org/3/library/random.html}{\Scribtexttt{random}}}

}
\relax{\benchmark{\relax{\textsf{futen}}}{\href{http://blog.amedama.jp/}{\Scribtexttt{momijiame}}}{\href{https://github.com/momijiame/futen}{Library}}{SSH configuration}{Converts an \href{https://www.openssh.com/}{OpenSSH} configuration
file to an inventory file for the
\href{https://www.ansible.com/}{Ansiable} automation framework.}{}{\href{https://docs.python.org/3/library/fnmatch.html}{\Scribtexttt{fnmatch}}, \Shref{https://docs.python.org/3/library/os.html}{module-os.path}{\Scribtexttt{os{\hbox{\texttt{.}}}path}}, \href{https://docs.python.org/3/library/re.html}{\Scribtexttt{re}}, \href{https://docs.python.org/3/library/shlex.html}{\Scribtexttt{shlex}}, \href{https://docs.python.org/3/library/socket.html}{\Scribtexttt{socket}}}

}
\relax{\benchmark{\relax{\textsf{take5}}}{Maha Alkhairy and Zeina Migeed}{Educational}{Game}{Implements a card game and a simple player AI.}{}{\href{https://docs.python.org/3/library/random.html}{\Scribtexttt{random}}, \href{https://docs.python.org/3/library/copy.html}{\Scribtexttt{copy}}}

}
\relax{\benchmark{\relax{\textsf{slowSHA}}}{Stefano Palazzo}{\href{http://github.com/sfstpala/SlowSHA}{Library}}{Hashing}{Applies the SHA-1 and SHA-512 algorithms to English words.}{}{\href{https://docs.python.org/3/library/os.html}{\Scribtexttt{os}}}

}
\relax{\benchmark{\relax{\textsf{sample\_fsm}}}{Zeina Migeed}{\href{https://github.com/ayaderaghul/sample-fsm}{Economics research}}{Economy simulator}{Adapted from the Typed Racket \relax{\textsf{fsm}} benchmark.}{}{\href{https://docs.python.org/3/library/itertools.html}{\Scribtexttt{itertools}}, \href{https://docs.python.org/3/library/os.html}{\Scribtexttt{os}}, \href{https://docs.python.org/3/library/random.html}{\Scribtexttt{random}}}

}
\relax{\benchmark{\relax{\textsf{aespython}}}{\href{http://caller9.com/}{Adam Newman}, \href{https://github.com/serprex}{Demur Remud}}{\href{https://github.com/serprex/pythonaes}{Library}}{Encryption}{Implements the \href{http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf}{Advanced Encryption Standard}.}{}{\href{https://docs.python.org/3/library/os.html}{\Scribtexttt{os}}, \href{https://docs.python.org/3/library/struct.html}{\Scribtexttt{struct}}}

}
\relax{\benchmark{\relax{\textsf{stats}}}{\href{https://connects.catalyst.harvard.edu/Profiles/display/Person/12467}{Gary Strangman}}{\href{https://github.com/seperman/python-statlib/blob/master/statlib/pstat.py}{Library}}{Statistics}{Implements first-order statistics functions; in other words, transformations
 on either floats or (possibly-nested) lists of floats.
The original program consists of two modules.
The benchmark is modularized according to comments in the program{'}s source
 code to reduce the size of each module{'}s configuration space.}{}{\href{https://docs.python.org/3/library/copy.html}{\Scribtexttt{copy}}, \href{https://docs.python.org/3/library/math.html}{\Scribtexttt{math}}}

}

\begin{Figure}\begin{Centerfigure}\begin{FigureInside}\begin{SCentered}\begin{tabular}[t]{@{}l@{}l@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}}
\hbox{} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{} \\
\hbox{Benchmark} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{\textbf{N}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{SLOC} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{modules} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{functions} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{classes} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{methods} \\
\hline \hbox{\relax{\textsf{fannkuch}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{41} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} \\
\hbox{\relax{\textsf{nqueens}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{37} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} \\
\hbox{\relax{\textsf{http2}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{86} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} \\
\hbox{\relax{\textsf{nbody}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{101} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} \\
\hbox{\relax{\textsf{pidigits}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{33} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} \\
\hbox{\relax{\textsf{spectralnorm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{31} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} \\
\hbox{\relax{\textsf{call\_simple}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{6} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{113} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{6} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} \\
\hbox{\relax{\textsf{float}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{6} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{36} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3} \\
\hbox{\relax{\textsf{call\_method}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{115} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} \\
\hbox{\relax{\textsf{go}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{80} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} \\
\hbox{\relax{\textsf{meteor}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{8} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{100} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{8} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} \\
\hbox{\relax{\textsf{Espionage}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{12} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{93} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} \\
\hbox{\relax{\textsf{PythonFlow}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{12} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{112} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{11} \\
\hbox{\relax{\textsf{pystone}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{14} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{177} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{11} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} \\
\hbox{\relax{\textsf{chaos}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{15} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{190} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{12} \\
\hbox{\relax{\textsf{futen}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{15} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{221} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{8} \\
\hbox{\relax{\textsf{take5}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{16} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{130} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{11} \\
\hbox{\relax{\textsf{slowSHA}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{17} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{210} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{10} \\
\hbox{\relax{\textsf{sample\_fsm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{19} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{148} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{8} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{9} \\
\hbox{\relax{\textsf{aespython}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{34} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{403} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{6} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{29} \\
\hbox{\relax{\textsf{stats}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{79} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1118} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{13} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{79} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{{-}}\end{tabular}\end{SCentered}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3arpx3astaticx2dbenchmarkx22x29x29}Figure~14: }{t:x28counter_x28x22figurex22_x22figx3arpx3astaticx2dbenchmarkx22x29x29}Static summary of the migratable code in the Reticulated benchmarks.
\textbf{N} = number of components = functions + classes + methods.
SLOC = source lines of code as reported by \href{https://dwheeler.com/sloccount/}{David A{\hbox{\texttt{.}}} Wheeler{'}s \Scribtexttt{sloccount}}.}}\end{Figure}

\hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3astaticx2dbenchmarkx22x29x29]{Figure~\FigureRef{14}{t:x28counter_x28x22figurex22_x22figx3arpx3astaticx2dbenchmarkx22x29x29}} tabulates information about the size and
 structure of the migratable portions of these benchmarks.
The six columns report the number of migratable units (\textbf{N} = num. functions + methods + classes), lines of code (SLOC), number of modules, number of function definitions, number of classes, and number of method definitions.
Most benchmarks are small, with 1{--}3 modules and fewer than 200 lines of code.
The number of mixed{-}typed configurations in the experiment, however, is
 prohibitively large.
The relatively small \relax{\textsf{sample\_fsm}} describes half a million configurations.
For the largest two benchmarks, \relax{\textsf{aespython}} and \relax{\textsf{stats}}, exhaustive
 measurement is out of the question.

\Ssubsubsection{Performance Ratios}{Performance Ratios}\label{t:x28part_x22secx3arpx3aratiox22x29}

\begin{Figure}\begin{Centerfigure}\begin{FigureInside}\begin{SCentered}\begin{tabular}[t]{@{}l@{}l@{}r@{}r@{}r@{}r@{}r@{}}
\hbox{Benchmark} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{retic/python} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{typed/retic} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{typed/python} \\
\hline \hbox{\relax{\textsf{fannkuch}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.14} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.01} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.15} \\
\hbox{\relax{\textsf{nqueens}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.25} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.57} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.96} \\
\hbox{\relax{\textsf{http2}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.07} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.18} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.63} \\
\hbox{\relax{\textsf{nbody}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.78} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.01} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.80} \\
\hbox{\relax{\textsf{pidigits}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.02} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.02} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.05} \\
\hbox{\relax{\textsf{spectralnorm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.01} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.47} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{6.98} \\
\hbox{\relax{\textsf{call\_simple}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.00} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.10} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.11} \\
\hbox{\relax{\textsf{float}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.18} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.52} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.32} \\
\hbox{\relax{\textsf{call\_method}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.48} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.74} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.79} \\
\hbox{\relax{\textsf{go}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.77} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.97} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.44} \\
\hbox{\relax{\textsf{meteor}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.56} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.37} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.13} \\
\hbox{\relax{\textsf{Espionage}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.87} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.79} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5.14} \\
\hbox{\relax{\textsf{PythonFlow}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.38} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.04} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.23} \\
\hbox{\relax{\textsf{pystone}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.36} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.06} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.79} \\
\hbox{\relax{\textsf{chaos}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.08} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.77} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.69} \\
\hbox{\relax{\textsf{futen}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.58} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.06} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.68} \\
\hbox{\relax{\textsf{take5}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.21} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.14} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.38} \\
\hbox{\relax{\textsf{slowSHA}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.66} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.18} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.96} \\
\hbox{\relax{\textsf{sample\_fsm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.80} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.16} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{6.07} \\
\hbox{\relax{\textsf{aespython}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3.41} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.74} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5.93} \\
\hbox{\relax{\textsf{stats}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.09} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.39} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.52}\end{tabular}\end{SCentered}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3arpx3aratiox22x29x29}Figure~15: }{t:x28counter_x28x22figurex22_x22figx3arpx3aratiox22x29x29}Performance ratios for three important points in
a configuration space: fully{-}typed code (typed), untyped code run through
Reticulated (retic), and untyped code run via Python (python).}}\end{Figure}

\noindent The table in \hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3aratiox22x29x29]{figure~\FigureRef{15}{t:x28counter_x28x22figurex22_x22figx3arpx3aratiox22x29x29}} lists the endpoints of migratory typing in
 Reticulated.
From left to right, these are:
 the performance of the untyped configuration relative to the Python baseline (the retic/python ratio),
 the performance of the fully{-}typed configuration relative to the untyped configuration (the typed/retic ratio),
 and the overall delta between fully{-}typed and Python (the typed/python ratio).

For example, the row for \relax{\textsf{futen}} reports a retic/python ratio of \relax{$1.58$}.
This means that the average time to run the untyped configuration of the
 \relax{\textsf{futen}} benchmark using Reticulated is that much slower than the
 average time of running the same code using Python.
The typed/retic ratio for \relax{\textsf{futen}} states that the fully{-}typed configuration
 is \relax{$1.06$} times slower than the untyped configuration.

Migrating a benchmark to Reticulated, or from untyped to fully{-}typed, always
 adds performance overhead.
This overhead is always within one order of magnitude.


Fourteen benchmarks have retic/python ratios that are larger
 than their typed/retic ratios.
One would expect retic/python ratios close to 1 because
 untyped Reticulated need not differ from Python.
But Reticulated duplicates some of Python{'}s run{-}time checks.
For example, Reticulated checks that a method is bound before proceeding
 with method dispatch.

\Ssubsubsection{Overhead Plots}{Overhead Plots}\label{t:x28part_x22secx3arpx3aoverheadx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.6000000000000227bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_13.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a0x22x29x29}Figure~16: }{t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a0x22x29x29}Reticulated overhead plots (1/3). The \relax{$x$}{-}axis ranges over slowdown factors,
the \relax{$y$}{-}axis counts configurations,
and a point (x, y) shows the proportion of \relax{$x$}{-}deliverable configurations.}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.6000000000000227bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_14.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a1x22x29x29}Figure~17: }{t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a1x22x29x29}Reticulated overhead plots (2/3).}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.6000000000000227bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_15.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a2x22x29x29}Figure~18: }{t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a2x22x29x29}Reticulated overhead plots (3/3).}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a0x22x29x29]{Figures~\FigureRef{16}{t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a0x22x29x29}}, \hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a1x22x29x29]{\FigureRef{17}{t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a1x22x29x29}}, and \hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a2x22x29x29]{\FigureRef{18}{t:x28counter_x28x22figurex22_x22figx3arpx3aoverheadx3a2x22x29x29}} summarize the overhead of migratory typing in the
 benchmark programs.
Each plot reports the percent of \relax{$D$}{-}deliverable configurations (\relax{$y$}{-}axis)
 for values of \relax{$D$} between \relax{$1$}x overhead and \relax{$10$}x overhead (\relax{$x$}{-}axis).
The heading above a plot states the benchmark{'}s name and indicates whether the
 data is exhaustive or approximate.
Exhaustive plots show the total number of configurations.
Approximate plots show the number of samples
 and the number of randomly{-}selected configurations in each sample.

The curves for the approximate data{---}\relax{\textsf{sample\_fsm}}, \relax{\textsf{aespython}}, and \relax{\textsf{stats}}{---}are intervals
 rather than fixed{-}width lines.
For instance, the height of an interval at \relax{$x\!=\!4$} is the range of the
 \relax{$95$}\%{-}\relax{$10, [10(F+C)]$}{-}approximation
 for the number of \relax{$4$}{-}deliverable configurations.
These intervals are thin because there is little variance in the proportion
 of \relax{$D$}{-}deliverable configurations across the ten
 samples, but the \relax{\textsf{sample\_fsm}} curve is slightly thicker than the
 \relax{\textsf{aespython}} curve.

Curves in these figures typically cover a large area and reach the
 top of the \relax{$y$}{-}axis at a low value of \relax{$D$}.
This value is always less than \relax{$10$}.
In other words, every configuration in the
 experiment is \relax{$10$}{-}deliverable.
For many benchmarks, the maximum overhead is significantly lower.
Indeed, eight benchmarks are nearly \relax{$2$}{-}deliverable.

None of the configurations in the experiment run faster than the Python baseline.
This is to be expected, given the retic/python ratios in \hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3aratiox22x29x29]{figure~\FigureRef{15}{t:x28counter_x28x22figurex22_x22figx3arpx3aratiox22x29x29}} and the
 fact that Reticulated translates type annotations into run{-}time checks.

Fourteen benchmarks have relatively smooth slopes.
The plots for the other four
 benchmarks have wide, flat segments.
These flat segments are due to functions that are frequently executed
 in the benchmarks{'} traces; all configurations in which one of these functions
 is typed incur a significant performance overhead.

Eighteen benchmarks are roughly \relax{$T$}{-}deliverable, where \relax{$T$} is
 the typed/python ratio listed in \hyperref[t:x28counter_x28x22figurex22_x22figx3arpx3aratiox22x29x29]{figure~\FigureRef{15}{t:x28counter_x28x22figurex22_x22figx3arpx3aratiox22x29x29}}.
In these benchmarks, the fully{-}typed configuration is one of the slowest configurations.
The notable exception is \relax{\textsf{spectralnorm}}, in which the fully{-}typed configuration
 runs faster than \relax{$38\%$} of all configurations.
Unfortunately, this speedup comes from a soundness bug that we discovered
 thanks to this performance evaluation.
Reticulated
 at commit \href{https://github.com/mvitousek/reticulated/commit/e478343ce7c0f2bc50d897b0ad38055e8fd9487d}{\Scribtexttt{e478343}} does not type{-}check the contents of tuples
 (\href{https://github.com/mvitousek/reticulated/issues/36}{\Scribtexttt{mvitousek/reticulated \#36}}).

\Ssubsubsection{Threats to Validity}{Threats to Validity}\label{t:x28part_x22secx3arpx3athreatsx22x29}

We have identified five sources of systematic bias.
Three have been noted above:
 the decision to measure one set of type annotations (chapter~\SecRefLocal{t:x28part_x22secx3aperfx3alimitsx22x29}{3.2.3}{Known Limitations}),
 the coarse granularity (chapter~\SecRefLocal{t:x28part_x22secx3arpx3aprotocolx22x29}{3.6.1}{Protocol}),
 and the imprecision of Reticulated types (chapter~\SecRefLocal{t:x28part_x22secx3aconversionx22x29}{3.4.1}{From Programs to Benchmarks}).
Here, we can offer a few details on type{-}expressiveness.
The \relax{\textsf{take5}} benchmark contains one function that must stay untyped because
 it accepts optional arguments (\href{https://github.com/mvitousek/reticulated/issues/32}{\Scribtexttt{mvitousek/reticulated \#32}}).
The \relax{\textsf{go}} benchmark uses dynamic typing because Reticulated cannot validate
 its use of a recursive class definition.
Two other benchmarks, \relax{\textsf{pystone}} and \relax{\textsf{stats}},
 use dynamic typing to overcome Reticulated{'}s lack of
 untagged union types.

A third issue is that the experiment uses rather small benchmarks.
The PyPI Ranking (\href{http://pypi-ranking.info/alltime}{\Snolinkurl{pypi-ranking.info/alltime}}, accessed 2018) shows that widely{-}used
 Python packages have far more functions and methods.
The
\href{https://github.com/simplejson/simplejson}{\Scribtexttt{simplejson}}
library contains over \relax{$50$} functions and methods, the
\href{https://github.com/kennethreitz/requests}{\Scribtexttt{requests}}
library contains over \relax{$200$}, and the
\href{https://github.com/pallets/jinja/tree/master/jinja2}{\Scribtexttt{Jinja2}}
library contains over \relax{$600$}.

Fourth and last, the \relax{\textsf{aespython}}, \relax{\textsf{futen}}, \relax{\textsf{http2}}, and \relax{\textsf{slowSHA}} benchmarks read from a file
 within their timed computation.
Despite the unpredictable running times of system calls,
 we believe our results are representative.

\Ssubsection{Additional Visualizations}{Additional Visualizations}\label{t:x28part_x22Additionalx5fVisualizationsx22x29}

The method presented in this chapter targets our most effective answer
 to the question of how to evaluate the performance of a mixed{-}typed language.
In particular, the notion of \relax{$D$}{-}deliverable configurations is a
 clear and scalable way to summarize performance.
But a mixed{-}typed language has other interesting properties.
This section presents visualizations that help answer different, targeted
 questions.

\Ssubsubsection{Exact Runtime Plots}{Exact Runtime Plots}\label{t:x28part_x22secx3aperfx3aexactx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.3999999999999915bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_16.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aexamplex2dexactx2dplotx22x29x29}Figure~19: }{t:x28counter_x28x22figurex22_x22figx3aexamplex2dexactx2dplotx22x29x29}Number of type annotations vs. Running time on the Reticulated \relax{\textsf{nqueens}} benchmark.The \relax{$x$}{-}axis ranges over the number of active typed units,
the \relax{$y$}{-}axis shows exact running times,
and a point (x, y) shows one running time for one configuration with \relax{$x$}
types.}}\end{FigureMulti}

\noindent The raw data behind an overhead plot is a sequence of running times for
 every configuration.
An overhead plot summarizes the running times into an average, and uses
 these averages to group configurations into buckets.
Unfortunately, this method hides outliers in the data
 and syntactic relations (think back to the lattice, \hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex2d0x22x29x29]{figure~\FigureRef{2}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex2d0x22x29x29}})
 among configurations.

\hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dexactx2dplotx22x29x29]{Figure~\FigureRef{19}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dexactx2dplotx22x29x29}} addresses both concerns.
Instead of summarizing one configuration with its average runtime,
 the plot contains one point for every running time in the dataset.
These points are spread left{-}to{-}right in one of the three
 columns of the figure.
If a plot like this does not consist of distinct, horizontal lines, the
 underlying dataset may have irregular running times.
Each column contains all configurations that have the same number of types.
In terms of the configuration lattice (\hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex2d0x22x29x29]{figure~\FigureRef{2}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dlatticex2d0x22x29x29}}),
 the left{-}most column contains the bottom level and each successive column
 present a higher levels.
At a glance, \hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dexactx2dplotx22x29x29]{figure~\FigureRef{19}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dexactx2dplotx22x29x29}} therefore shows the overall
 effect of adding types.

\Ssubsubsection{Relative Scatterplots}{Relative Scatterplots}\label{t:x28part_x22Relativex5fScatterplotsx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.0bp}{\makebox[193.6bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_17.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aexamplex2dscatterplotx22x29x29}Figure~20: }{t:x28counter_x28x22figurex22_x22figx3aexamplex2dscatterplotx22x29x29}Scatterplot comparing \relax{\textsf{morsecode}} configurations before
and after collapsible contracts.
The \relax{$x$}{-}axis ranges over collapsible overhead and the \relax{$y$}{-}axis
 ranges over baseline overhead.
A point \relax{$(x, y)$} is a head{-}to{-}head comparison;
 points above the diagonal are better for collapsible.}}\end{FigureMulti}

\noindent Collapsible contracts are a new representation for deep run{-}time type
 checks\relax{~\citep{fgsfs-oopsla-2018}}.
The representation greatly improves some mixed{-}typed programs, but can
 slow down others.
To assess the implementation of collapsible,
 we used a scatterplot technique due to Spenser Bauman\relax{~\citep{bbst-oopsla-2017}}.
\hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dscatterplotx22x29x29]{Figure~\FigureRef{20}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dscatterplotx22x29x29}} shows one representative example from our work.
Each point in the scatterplot shows how collapsible affects one configuration.
Points above the diagonal line are improved;
 points below the line get worse with collapsible contracts.
More precisely, a point \relax{$(X, Y)$} shows the overhead in both systems.
The first coordinate, \relax{$X$}, is the overhead with collapsible.
The \relax{$Y$} coordinate is the baseline overhead, without collapsible.
If collapsible always led to a lower overhead, then all
 point would lie above the \relax{$X=Y$} line (because \relax{$X < Y$}).

\Ssubsubsection{Best{-}Path Plots}{Best{-}Path Plots}\label{t:x28part_x22Bestx2dPathx5fPlotsx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-2.640624999999983bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_18.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aexamplex2dpathx22x29x29}Figure~21: }{t:x28counter_x28x22figurex22_x22figx3aexamplex2dpathx22x29x29}Overhead plots for \relax{\textsf{suffixtree}} comparing the base slowdown to
the best{-}possible improvement after adding types to 1 (top) and 2 (bottom)
modules.}}\end{FigureMulti}

\noindent The plots in chapter~\SecRefLocal{t:x28part_x22secx3atrx3aevaluationx22x29}{3.5}{Application 1: Typed Racket} paint a bleak picture of
 Typed Racket.
Many benchmarks have many configurations that run far slower than the
 untyped code.
A natural question, though, is whether these results are brittle.
If a programmer can escape the slow configurations by converting one or
 two more modules, then the bleak conclusion may be unwarranted.

\hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dpathx22x29x29]{Figure~\FigureRef{21}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dpathx22x29x29}} presents two plots for the \relax{\textsf{suffixtree}} benchmark
 that compare the original data against the best{-}possible performance after
 converting additional modules.
In the top plot, a configuration is \relax{$X$}{-}deliverable in the orange curve
 if it can reach a \relax{$X$}{-}deliverable configuration from the blue curve after
 adding types to one module.
Similarly, the bottom plot shows the best{-}possible performance after typing
 two untyped modules.

The plots show that significant improvements are possible, but not guaranteed
 even in the best case.
Other large benchmarks typically show similar patterns\relax{~\citep{gtnffvf-jfp-2019}}.

\sectionNewpage

\Ssection{Design Analysis Method}{Design Analysis Method}\label{t:x28part_x22secx3adesignx3aintroductionx22x29}

\label{t:x28part_x22chapx3adesignx22x29}

\begin{SInsetFlow}\emph{This chapter is based on joint work with: Christos Dimoulas and Matthias Felleisen\relax{~\citep{gf-icfp-2018,gfd-oopsla-2019,gdf-jfp-2020}}.}\end{SInsetFlow}

Over the years, researchers have developed several languages that mix typed and untyped code.
Typed Racket and Reticulated are but two implementations in a wide space.
To a first approximation, the designs fall into four broad strategies:

\begin{itemize}\atItemizeStart

\item \emph{Optional} typing adds a best{-}effort static analysis but
 ignores type annotation at runtime\relax{~\citep{bg-oopsla-1993,bat-ecoop-2014}}.

\item \emph{Transient} inserts shape checks in type{-}checked code
 to guarantee that operations cannot not {``}go wrong{''} due to
 untyped values\relax{~\citep{vss-popl-2017,v-thesis-2019}}.
A shape check validates a top{-}level value contstructor with respect to a
 top{-}level type constructor, which is just enough for this notion of safety.

\item \emph{Natural} enforces types with higher{-}order checks
 and thereby ensures the full integrity of types\relax{~\citep{st-sfp-2006,tf-dls-2006}}.

\item \emph{Concrete} requires that every value is tagged with a type and
maintains integrity with simple checks\relax{~\citep{wzlov-popl-2010, mt-oopsla-2017}}.\end{itemize}

\noindent \noindent{}In addition, though, researchers have proposed and implemented
 hybrid techniques\relax{~\citep{g-popl-2015, svctg-esop-2015, gf-icfp-2018, bfnorsvw-oopsla-2009, rzv-ecoop-2015}}.
An outstanding and unusual exemplar
 of this kind is Pyret, a language targeting the educational realm (\href{https://www.pyret.org}{\Scribtexttt{pyret{\hbox{\texttt{.}}}org}}).

Each of these type{-}enforcement strategies picks a tradeoff among
 static guarantees, expressiveness, and run{-}time costs (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3ajunglex22x29}{4.2}{Assorted Behaviors by Example}).
If stringent constraints on untyped code are acceptable,
 then \emph{concrete} offers strong and inexpensive guarantees.
If the goal is to interoperate with an untyped language that
 does not support wrapper/proxy values,
 then \emph{transient} may offer the strongest possible guarantees.
If performance is not an issue,
 then \emph{natural} is the perfect choice.

Unfortunately, the literature provides little guidance to programmers and
 language designers on how to compare different semantics.
Standard meta{-}theoretical tools do not articulate what is gained
 and lost in each tradeoff (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3apropertiesx22x29}{4.3}{Towards a Formal Comparison}).
The gradual guarantee\relax{~\citep{svcb-snapl-2015}}, for example, is trivially
 satisfied by any optionally{-}typed language.
Simply put, the field lacks an apples{-}to{-}apples way of comparing different
 type{-}enforcement strategies and considering their implications for programmers.

This chapter introduces a framework for systematically comparing the behavioral
 guarantees offered by different mixed{-}typed semantics.
Because each semantics is essentially a method of enforcing static types,
 the comparison begins with a common mixed{-}typed syntax.
This surface syntax is then assigned multiple semantics,
 each of which follows a distinct protocol for enforcing type specifications.
With this semantic framework, one can directly observe the possible behaviors
 for a single program.

The chosen models illustrate \emph{natural} (\relax{$\nscr$}), \emph{transient} (\relax{$\tscr$}),
 \emph{optional} (also known as \emph{erasure}, \relax{$\escr$}),
 and three other strategies (\relax{$\cscr$}, \relax{$\fscr$}, \relax{$\ascr$}) that demenstrate how to fill design gaps.
The comparison excludes two classes of prior work:
 \emph{concrete}, because of the constraints it places on untyped code (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3aantix2dconcretex22x29}{4.2.2}{Validating an Untyped Data Structure}),
 and mixed{-}typed languages that must analyze untyped code to interoperate with it.
Our focus is on strategies that can deal with untyped code
 as a {``}dusty deck{''} without needing to recompile the untyped world each time a new type boundary appears.

\relax{\begin{table}[t]
  \caption{Informal sketch of the design-space analysis.}
  \label{tbl:contributions}

  {\deftablemacros{}
   \hfill\(\begin{array}{l@{\qquad}c@{\hsep}c@{\hsep}c@{\hsep}c@{\hsep}c@{\hsep}c}
     & \nscr\hphantom{\LE} & \cscr\hphantom{\LE} & \fscr\hphantom{\LE} & \tscr\hphantom{\EQ} & \ascr\hphantom{\LE} & \escr
     \\[1.0ex] \textrm{type soundness}
        &     \tblY &     \tblY &     \tblY &     \tblY &     \tblY &     \tblN
     \\ \textrm{complete monitoring}
        &     \tblY &     \tblY &     \tblN &     \tblN &     \tblN &     \tblN
     \\ \textrm{blame soundness}
        &     \tblY &     \tblY &     \tblY &     \tblN &     \tblY &     \tblY
     \\ \textrm{blame completeness}
        &     \tblY &     \tblY &     \tblN &     \tblN &     \tblY &     \tblN
     \\ \textrm{error preorder}
     & \nscr\LE & \cscr\LE & \fscr\LE & \tscr\EQ & \ascr\LE & \escr
   \end{array}\)\hfill}
\end{table}}

Table~\ref{tbl:contributions} sketches the results of the evaluation (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechnicalx22x29}{4.5}{Technical Development}).
The six letters in the top row correspond to different type{-}enforcement strategies,
 and thus different semantics, for the common surface language.
As to be expected, \relax{\nname} (\relax{$\nscr$}) accepts the fewest programs without raising a run{-}time
 type mismatch, and \relax{\ename} (\relax{$\escr$}) accepts the greatest number
 of programs;
 the symbols \relax{$\sbehaviorle$} and \relax{$\sbehavioreq$} indicate these
 behavioral differences.
Lower rows introduce additional properties that underlie our comparison.
Type soundness guarantees the validity of types in typed code.
Complete monitoring guarantees that the type system moderates all boundaries between
 typed and untyped code{---}even boundaries that arise at run{-}time.
Blame soundness ensures that when a run{-}time check goes wrong, the error message
 points to boundaries that are relevant to the problem.
Blame completeness guarantees that error messages come with \emph{all} relevant
 information.
For both blame soundness and completeness, \emph{relevance} is determined by an
 independent (axiomatic) specification that tracks values as they cross
 boundaries between typed and untyped code (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alawsx22x29}{4.4.4.1}{How to lift a reduction relation}).

In sum, the five properties enable a uniform analysis of existing strategies
 and can guide the search for new strategies. Indeed, the synthetic
 \relax{\aname} semantics (\relax{$\ascr$}) demonstrates how a semantics can
 fail complete monitoring but guarantee sound and complete blame.

\Ssubsection{Chapter Outline}{Chapter Outline}\label{t:x28part_x22Chapterx5fOutlinex22x29}

Sections \relax{\ref{sec:design:jungle}} through \relax{\ref{sec:design:basic}} explain the
 \emph{what}, \emph{why}, and \emph{how} of our design{-}space analysis.
There is a huge body of work on mixed{-}typed language that desperately
 needs organizing principles (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3ajunglex22x29}{4.2}{Assorted Behaviors by Example}).
Past attempts to organize fall short; by contrast,
 the properties that frame table~\ref{tbl:contributions} offer an expressive and scalable
 basis for comparison (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3apropertiesx22x29}{4.3}{Towards a Formal Comparison}).
These properties guide an apples{-}to{-}apples method that begins
 with a common surface language and studies different semantics (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3abasicx22x29}{4.4}{Evaluation Framework}).
In particular, this chapter analyzes six semantics based on six ideas for
 enforcing static types.

Chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechnicalx22x29}{4.5}{Technical Development} presents the six semantics and the key results.
Expert readers may wish to begin there and refer back to chapter~\SecRefLocal{t:x28part_x22secx3adesignx3abasicx22x29}{4.4}{Evaluation Framework}
 as needed.
An appendix contains a complete formal account of our results.

\Ssubsection{Assorted Behaviors by Example}{Assorted Behaviors by Example}\label{t:x28part_x22secx3adesignx3alandscapex22x29}

\label{t:x28part_x22secx3adesignx3ajunglex22x29}

\label{sec:design:jungle}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{tikzpicture}
  \def\embeddingskip{2cm}
  \renewcommand{\cite}[1]{}
  \node (E)
    [align=left]
    {\textstrat{\ename{}}};
  \node (EBOX)
    [left=of E.south west,anchor=north west,xshift=2.5em,draw=black!70!white,rectangle,rounded corners=5pt,align=center]
    {ActionScript\cite{rch-popl-2012}\({}^{\mtlangann}\) \quad
     Common Lisp\({}^{\mtlangann}\) \quad
     mypy\({}^{\mtlangann}_{\dynlangann}\) \quad
     Flow\cite{cvgrl-oopsla-2017}\({}^{\mtlangann}_{\dynlangann}\) \quad
     Hack\({}^{\mtlangann}_{\dynlangann}\) \quad
     \\[0.4ex]
     Pyre\({}^{\mtlangann}_{\dynlangann}\) \quad
     Pytype\({}^{\mtlangann}_{\dynlangann}\) \quad
     RDL\cite{rtsf-sac-2013}\({}^{\mtlangann}_{\dynlangann}\) \quad
     Strongtalk\cite{bg-oopsla-1993}\({}^{\mtlangann}\) \quad
     TypeScript\cite{bat-ecoop-2014}\({}^{\mtlangann}_{\dynlangann}\)
     \\[0.4ex]
     Typed Clojure\cite{bdt-esop-2016}\({}^{\mtlangann}\) \quad
     Typed Lua\cite{mmi-dls-2015}\({}^{\mtlangann}\)};

  \node (NBOX)
    [below=of EBOX.south west,anchor=north west,xshift=0.5em,yshift=-1ex,draw=black!70!white,rectangle,rounded corners=5pt,align=center]
    {Gradualtalk\cite{acftd-scp-2013}\({}^{\mtlangann}_{\dynlangann}\) ~~
     Grift\({}_{\dynlangann}\) \\[0.4ex]
     Pycket\cite{bbst-oopsla-2017}\({}^{\mtlangann}\) \quad
     TPD\cite{wmwz-ecoop-2017}\({}^{\mtlangann}\) \\[0.4ex]
     Typed Racket\cite{tf-popl-2008}\({}^{\mtlangann}\)};

  \node (N)
    [right=of NBOX.north west,anchor=south west,xshift=-2.5em]
    {\textstrat{\nname}};

  \node (TBOX)
    [right=of NBOX.north east,xshift=-1em,anchor=north west,yshift=2ex,draw=black!70!white,rectangle,rounded corners=5pt,align=center]
    {Grace\cite{rmhn-ecoop-2019} ~~
     Pallene\cite{gi-sblp-2018}\({}^{\mtlangann}\) \\[0.4ex]
     Reticulated\cite{vss-popl-2017}\({}^{\mtlangann}_{\dynlangann}\)};

  \node (T)
    [right=of TBOX.north west,anchor=south west,xshift=-2.5em]
    {\textstrat{\tname}};

  \node (CBOX)
    [right=of TBOX.north east,xshift=-0.5em,yshift=-8.5ex,anchor=north west,draw=black!70!white,rectangle,rounded corners=5pt,align=center]
    {\csharp{}  \quad
     Dart 2 \\[0.4ex]
     Nom\cite{mt-oopsla-2017}\({}_{\dynlangann}\) ~
     SafeTS\cite{rsfbv-popl-2015} \\[0.4ex]
     {TS\({}^*\)}\cite{sfrbcsb-popl-2014}};

  \node (C)
    [right=of CBOX.north west,anchor=south west,xshift=-2.5em]
    {\textstrat{Concrete}};

  \node (EC)
    [draw=black!80!white,dashed,ellipse,left=of EBOX.south east,xshift=0.9em,yshift=-1ex,anchor=north,align=center]
    {\(\!\!\!\)StrongScript\cite{rzv-ecoop-2015}\(\!\!\!\)\\[0.4ex]
     Thorn\cite{wzlov-popl-2010}};

  \node (ET)
    [draw=black!80!white,dashed,ellipse,left=of TBOX.south west,xshift=4.5ex,yshift=-2ex,x radius=10em,anchor=north west,align=center]
    {~Pyret~};

\end{tikzpicture}

\hbox{$\displaystyle\mtlang$ = migratory, $\displaystyle\dynlang$ = gradual}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3alandscapex22x29x29}Figure~22: }{t:x28counter_x28x22figurex22_x22figx3alandscapex22x29x29}Landscape of mixed{-}typed languages}}\end{FigureMulti}

There are many mixed{-}typed languages.
\hyperref[t:x28counter_x28x22figurex22_x22figx3alandscapex22x29x29]{Figure~\FigureRef{22}{t:x28counter_x28x22figurex22_x22figx3alandscapex22x29x29}} arranges a few of their names into a rough picture
 of the design space.
Each language enables some kind of mix between typed and untyped code.
Languages marked with a star (\relax{$\dynlang{}$}) come with a special dynamic
 type, often styled as \relax{$\star$}, or \relax{$\mathbf{?}$}, that allows partially{-}defined types\relax{~\citep{svcb-snapl-2015}}.
Technically, the type system supports implicit down{-}casts from the dynamic
 type to any other type{---}unlike, say, \relax{\texttt{Object}} in Java.
Languages marked with a cross (\relax{$\mtlang{}$}) add a tailor{-}made type system to
 an untyped language, but may require types for an entire module at a time\relax{~\citep{tfffgksst-snapl-2017}}.
Other languages satisfy different goals.

For the most part, these mixed{-}typed languages fit into the broad forms
 introduced in chapter~\ChapRefLocal{t:x28part_x22secx3adesignx3aintroductionx22x29}{4}{Design Analysis Method}.
\relax{\ename} is by far the most popular strategy; perhaps because of its
 uncomplicated semantics and ease of implementation\relax{~\citep{s-lisp-1990,rtsf-sac-2013,mmi-dls-2015,bdt-esop-2016}}.
The \relax{\nname} languages come from academic teams that are interested in
 types that offer strong guarantees\relax{~\citep{tf-popl-2008,acftd-scp-2013,wmwz-ecoop-2017,bbst-oopsla-2017}}.
\relax{\tname} is gaining traction as a compromise between types and performance\relax{~\citep{vss-popl-2017,rmhn-ecoop-2019,gi-scp-2020}},
 and Concrete has generated interest among industry teams\relax{~\citep{bmt-ecoop-2010,dart-types}}
 as well as academics\relax{~\citep{sfrbcsb-popl-2014,rsfbv-popl-2015,mt-oopsla-2017}}.
Nevertheless, several languages explore a hybrid approach.
StrongScript and Thorn offer a choice of concrete and erased types\relax{~\citep{wzlov-popl-2010,rzv-ecoop-2015}}.
Pyret uses \relax{\nname}{-}style checks to validate fixed{-}size data and \relax{\tname}{-}style checks
 for recursive types (e.g. lists) and higher{-}order types
 (personal communication with Benjamin Lerner and Shriram Krishnamurthi).
The literature presents additional languages, as formal semantics without implementations, that defy a broad categorization.
\relax{\citet{cl-icfp-2017}} drop certain wrappers.
\relax{\citet{svctg-esop-2015}} give a monotonic semantics for references.

Our goal is a systematic comparison of type guarantees across the wide design space.
Such a comparison is possible because, despite the variety, the different guarantees
 arise from choices about how to enforce types at the boundaries between
 type{-}checked code and arbitrary dynamically{-}typed code.
To illustrate, the following three subsections discuss type boundary examples in the
 context of for languages:
  Flow\relax{~\citep{cvgrl-oopsla-2017}},
  Reticulated\relax{~\citep{vss-popl-2017}},
  Typed Racket\relax{~\citep{tfffgksst-snapl-2017}},
  and Nom\relax{~\citep{mt-oopsla-2017}}.
Flow is a migratory typing system for JavaScript,
 Reticulated equips Python with gradual types,
 Typed Racket extends Racket,
 and Nom is a new gradual{-}from{-}the{-}start object{-}oriented language.

\Ssubsubsection{Enforcing a Base Type}{Enforcing a Base Type}\label{t:x28part_x22Enforcingx5fax5fBasex5fTypex22x29}

One of the simplest ways that a mixed{-}typed interaction can go awry
 is for untyped code to send incorrect input to a typed context that
 expects a flat value.
The first example illustrates one such interaction:

\begin{equation}\label{eq:example-atom}\raisebox{-0.20000000000000284bp}{\makebox[97.6bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_19.pdf}}}\end{equation}

\noindent{}The typed function on top expects an integer.
The untyped context on the bottom imports this function \relax{$f$} and applies \relax{$f$} to
 itself; thus the typed function receives a function rather than an integer.
The question is whether the program halts
 or invokes the typed function \relax{$f$} on a nonsensical input.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.39999999999997726bp}{\makebox[256.91562500000003bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_20.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aexamplex2datomx22x29x29}Figure~23: }{t:x28counter_x28x22figurex22_x22figx3aexamplex2datomx22x29x29}\relax{\Programref{eq:example-atom}} translated to four languages}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2datomx22x29x29]{Figure~\FigureRef{23}{t:x28counter_x28x22figurex22_x22figx3aexamplex2datomx22x29x29}} translates the program to four languages.
Each white box represents type{-}checked code and each grey box represents
 untyped and, ideally, un{-}analyzed code that is linked in at run{-}time.
Nom is an exception, however, because it cannot interact with truly untyped code (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3aantix2dconcretex22x29}{4.2.2}{Validating an Untyped Data Structure}).
Despite the differences in syntax and types, each clearly defines a
 typed function that expects an integer on the top
 and applies the function to itself in an untyped context on the bottom.

In Flow, the program does not detect a type mismatch.
The typed function receives a function from untyped JavaScript and surprisingly computes a string
 (\Scribtexttt{ECMA{-}262} edition 10, \relax{\S} \Shref{https://www.ecma-international.org/ecma-262/}{sec-addition-operator-plus}{12{\hbox{\texttt{.}}}8{\hbox{\texttt{.}}}3}).
In the other three languages, the program halts with
a \emph{boundary error} message that alerts the programmer to the
 mismatch between two chunks of code.

Flow does not detect the run{-}time type mismatch because it follows the
 \emph{erasure}, or optional typing, approach to type enforcement.
\relax{\ename} is hands{-}off;
 types have no effect on the behavior of a program.
These static{-}only types help find logical mistakes and enable type{-}directed IDE tools,
 but disappear during compilation.
Consequently, the author of a typed Erasure function cannot assume that it
 receives only well{-}typed input.

The other languages enforce static types with some kind of dynamic check.
For base types, the check validates the shape of incoming data.
The checks for other types reveal differences among these non{-}trivial type enforcement strategies.

\Ssubsubsection{Validating an Untyped Data Structure}{Validating an Untyped Data Structure}\label{t:x28part_x22secx3adesignx3aantix2dconcretex22x29}

The second example is about pairs. It asks what
 happens when typed code declares a pair type and receives an untyped pair:

\begin{equation}\label{eq:example-pair}\raisebox{-0.20000000000000284bp}{\makebox[153.6bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_21.pdf}}}\end{equation}

\noindent{}The typed function on top expects a pair of integers and uses the
 first element of the input pair as a number.
The untyped code on the bottom applies this function to a pair that contains a
 string and an integer.

\hyperref[t:x28counter_x28x22figurex22_x22figx3aexamplex2dpairx22x29x29]{Figure~\FigureRef{24}{t:x28counter_x28x22figurex22_x22figx3aexamplex2dpairx22x29x29}} translates this idea into
 Reticulated, Typed Racket, and Nom.
The encodings in Reticulated and Typed Racket
 define a pair in untyped code and impose a type in typed code.
The encoding in Nom is different;
 the typed code expects an instance of one data structure but
 the untyped code provides something else.
This shape mismatch leads to a run{-}time error.

Nom cannot express \relax{\programref{eq:example-pair}} directly
 because the language does not allow partially{-}typed values.
There is no common pair constructor that: (1) untyped code can use without
 constraints and (2) typed code can receive at a particular type.
All type structure must be specified with the data structure.
On one hand, this requirement greatly simplifies run{-}time validation
 because the outermost shape of any value determines the shape of its elements.
On the other hand, it imposes a significant burden on the programmer.
To add refined static type checking at the use{-}sites of an untyped data structure,
 a programmer must either add a cast to each use in typed code
 or edit the untyped code for a new data definition.
Because Nom and other concrete languages require this kind of type structure in
 untyped code\relax{~\citep{wzlov-popl-2010,rzv-ecoop-2015,mt-oopsla-2017,dart-types}},
 the model in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechnicalx22x29}{4.5}{Technical Development} does not support them.

Both Reticulated and Typed Racket raise an error on \relax{\programref{eq:example-pair}},
 but for substantially different reasons.
Typed Racket rejects the untyped pair at the boundary to the typed context
 because the pair does not fully match the declared type.
Reticulated accepts the value at the boundary because it is a pair,
 but raises an exception at the elimination form \Scribtexttt{y[0]} because typed code
 expects an integer result but receives a string.
These sample behaviors are indicative of a wider difference;
 Typed Racket eagerly checks the contents of data structures
 while Reticulated lazily validates use{-}sites.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.1999999999999318bp}{\makebox[240.115625bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_22.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aexamplex2dpairx22x29x29}Figure~24: }{t:x28counter_x28x22figurex22_x22figx3aexamplex2dpairx22x29x29}\relax{\Programref{eq:example-pair}} translations}}\end{FigureMulti}

\Ssubsubsection{Uncovering the Source of a Mismatch}{Uncovering the Source of a Mismatch}\label{t:x28part_x22secx3adesignx3alyingx2dtypex22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.1999999999999318bp}{\makebox[282.40000000000003bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_23.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29}Figure~25: }{t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29}Using Typed Racket to define an API}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.5999999999999659bp}{\makebox[310.4000000000001bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_24.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3areticx2dexamplex22x29x29}Figure~26: }{t:x28counter_x28x22figurex22_x22figx3areticx2dexamplex22x29x29}Using Reticulated to define an API}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29]{Figures~\FigureRef{25}{t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29}} and \hyperref[t:x28counter_x28x22figurex22_x22figx3areticx2dexamplex22x29x29]{\FigureRef{26}{t:x28counter_x28x22figurex22_x22figx3areticx2dexamplex22x29x29}} present excerpts
 from realistic programs that mix typed and untyped code.
These examples follow the same general structure:
 an untyped client interacts with an untyped library via a thin layer of typed code.
Both programs also signal run{-}time errors, but for different reasons and
 with different implications for the programmer.

\hyperref[t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29]{Figure~\FigureRef{25}{t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29}} consists of an untyped library,
 an \emph{incorrect} layer of type annotations,
 and an untyped client of the types.
The module on top, \Scribtexttt{net/url},
 is a snippet from an untyped library that has been part of Racket for two decades
 (\href{https://github.com/racket/net}{\Scribtexttt{github{\hbox{\texttt{.}}}com/racket/net}}).
The typed module on the middle{-}right defines types for part of the untyped library.
Lastly, the module at the bottom of the figure imports the typed library and calls
 the library function \Scribtexttt{call/input{-}url}.

Operationally, the library function flows from \Scribtexttt{net/url}
 to the typed module and then to the client.
When the client calls this function, it sends
 client data to the untyped library code via the typed module.
The client application clearly relies on the type specification from \Scribtexttt{typed/net/url} because
 the first argument is a URL structure,
 the second is a function that accepts a string,
 and the third is a function that maps an input port to an HTML representation.
Unfortunately for the client, the type declaration in \hyperref[t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29]{figure~\FigureRef{25}{t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29}}
 is buggy.
The library applies the first callback of
 \Scribtexttt{call/input{-}url} to a URL struct,
 rather than a string as the developer expects.

Fortunately for the developer, Typed Racket compiles types to contracts and
 thereby catches the mismatch.
Here, the compilation of \Scribtexttt{typed/net/url} generates a
 contract for \Scribtexttt{call/input{-}url}.
The generated contract ensures that the untyped client provides three
 type{-}matching argument values and that the library applies the callback to a
 string.
When the \Scribtexttt{net/url} library eventually applies the callback
 function to a URL structure, the function contract for the callback halts
 the program.
The blame message says that \Scribtexttt{net/url} broke the
 contract on the back{-}channel from it to \Scribtexttt{client}, but warns the
 developer on the last line with {``}assuming the contract is correct.{''}
A quick look confirms that the contract{---}that is, the type
 from which the contract is derived{---}is wrong.

\hyperref[t:x28counter_x28x22figurex22_x22figx3areticx2dexamplex22x29x29]{Figure~\FigureRef{26}{t:x28counter_x28x22figurex22_x22figx3areticx2dexamplex22x29x29}} presents an arrangement of three Transient
 Reticulated modules, similar to the code in \hyperref[t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29]{figure~\FigureRef{25}{t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29}}.
The module on the top exports a function that retrieves data from a URL
(adapted from the \Scribtexttt{requests} library, \href{https://github.com/psf/requests}{\Scribtexttt{github{\hbox{\texttt{.}}}com/psf/requests}}).
This function accepts several optional and keyword arguments.
The typed adaptor module on the right formulates types for one valid use of the
 function; a client may supply a URL as a string and a timeout as a pair of floats.
These types are correct, but the client module on the bottom sends
 a tuple that contains an integer and a string.

Reticulated{'}s runtime checks ensure that the typed function receives a
 string and a tuple, but do not validate the tuple{'}s contents.
These same arguments then pass to the untyped \Scribtexttt{get} function in the
 \Scribtexttt{requests} module.
When the untyped \Scribtexttt{get} eventually uses the string
 \Scribtexttt{"zero"} as a float, Python raises an exception that
 originates from the \Scribtexttt{requests} module{---}possibly leading the programmer to
 search for a bug in the library.

In this example, the programmer is lucky because the call to the typed
 version of \Scribtexttt{get} is still visible on the stack trace,
 providing a hint that this call might be at fault.
If Python were to properly implement tail calls, or if the library accessed
 the pair some time after returning control to the client, this hint would disappear.

In sum, types in Transient Reticulated do not monitor all channels of
 communication between modules.
A value may cross a type boundary without a full check, making it difficult
 to discover type{-}value mismatches or pinpoint their source.
Reticulated mitigates this problem with a global map from heap
 addresses to source locations.
The analysis in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechnicalx22x29}{4.5}{Technical Development} demonstrates, however,
 that this map can result in incorrect blame.

\Ssubsection{Towards a Formal Comparison}{Towards a Formal Comparison}\label{t:x28part_x22secx3adesignx3apropertiesx22x29}

The design of a type{-}enforcement strategy is a multi{-}faceted problem.
A strategy determines many aspects of behavior:
 whether mismatches between type specifications and value flows are discovered;
 whether the typed portion of the code is really statically typed, in a conventional sense;
 what typed APIs mean for untyped client code;
 and whether an error message can pinpoint which type specification does not
 match which value.
All of these decisions imply consequences for the programmer and the language
designer.

The examples in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3ajunglex22x29}{4.2}{Assorted Behaviors by Example} show that
 various languages choose different points in this multi{-}faceted design space.
But, examples can only motivate a systematic analysis; they
 cannot serve as the basis of such an endeavor.
The selection of example programs and their translation across languages
 require too much insight.
Worse, the examples tell us little about the broader implications of each
 choice; at best they can demonstrate issues.

A systematic analysis needs a suite of formal properties that capture the
consequences of design choices for the working developer and language designer.
Such properties must
    apply to a wide (if not the full) spectrum of design options,
    articulate benefits of type specifications to typed and untyped code alike, and
    come with proof techniques that scale to complex language features.

\noindent{}The literature on gradual typing suggests few adequate properties.
Our analysis therefore brings new properties to the toolbox.

\Ssubsubsection{Comparative Properties in Prior Work}{Comparative Properties in Prior Work}\label{t:x28part_x22secx3adesignx3aoldx2dpropertiesx22x29}

\emph{Type soundness} is one formal property that meets the above criteria.
A type soundness theorem can be tailored to a range of type systems,
 such a theorem has meaning for typed and untyped code,
 and the syntactic proof technique scales to a variety of language features\relax{~\citep{wf-ic-1994}}.
The use of type soundness in the gradual typing literature, however, does not
 promote a level comparison.
Consider the four example languages from the previous section.
\relax{\citet{cvgrl-oopsla-2017}} present a model of Flow and prove a conventional
 type soundness theorem under the assumption that all code is statically{-}typed.
\relax{\citet{vss-popl-2017}} prove a type soundness theorem for Reticulated Python;
 a reader will eventually notice that the theorem talks about the \emph{shape}
 of values not their types.
\relax{\citet{mt-oopsla-2017}} prove a full type soundness theorem for Nom,
 which implements the concrete approach.
\relax{\citet{tf-dls-2006}} prove a full type soundness theorem for a prototypical
 Typed Racket that includes a weak blame property.
To summarize, the four advertised type soundness theorems differ in several
regards:  one focuses on the typed half of the language;
 a second proves a claim about a loose relationship between values and types;
 a third is a truly conventional type soundness theorem;
 and the last one incorporates a claim about the quality of error messages.

\relax{\citet{svcb-snapl-2015}} propose the \emph{gradual guarantee} as a test to
 identify languages that enable smooth transitions between typed and
 untyped. They and others show that the gradual guarantee holds for
 relatively simple type languages and syntactic constructs; proving that it
 generalizes to complex type systems is the subject of active
 research\relax{~\citep{isi-icfp-2017, tlt-popl-2019, nja-popl-2020}}.
 The guarantee itself, however, does not tell apart the behaviors in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3ajunglex22x29}{4.2}{Assorted Behaviors by Example}.
Both Reticulated and Nom come with published proofs of the gradual
 guarantee\relax{~\citep{vss-popl-2017,mt-oopsla-2017}}.
Typed Racket states the guarantee as an explicit design goal.
Even Flow, thanks to its lack of dynamic checks, satisfies the criteria for
 a smooth transition.

The \relax{\kafka{}} framework is able to
 distinguish behaviors but lacks a meta{-}theoretical analysis\relax{~\citep{clzv-ecoop-2018}}.
The sole theorem in the paper states type soundness for a statically{-}typed
 evaluation language.
Different behaviors arise, however, from four translations of a mixed{-}typed
 surface language into this evaluation language.
One can observe the behaviors, but the model does not characterize them.

\relax{\citet{nla-popl-2019}} distinguish gradual typing systems via \emph{equivalence preservation}.
Starting from a set of axioms for typed expressions{---}for
 example, \relax{$\beta$} and \relax{$\eta$} equations{---}they ask whether interactions with
 untyped code can violate the axioms.
Equivalence preservation does define a spectrum;
 the \relax{\nname} semantics preserves \relax{$\eta$} for pairs and functions,
 and a lazy variant (\relax{\cname}) fails for pairs.
But, this spectrum is rather coarse.
The \relax{\tname} and \relax{\ename} behaviors are indistinguishable under
 equivalence preservation because both fail to preserve the axioms.
Furthermore, the type{-}centric nature of the equivalences offers no direct
 information to the untyped side.
Authors of untyped code can at best deduce that the behavior of their programs
 cannot be affected by certain changes in typed libraries.
As a final remark, techniques for proving equivalence preservation are an
 active area of research but results so far indicate that they require a lot of
 ingenuity to adapt from one linguistic setting to another.

Another well{-}studied property is the \emph{blame theorem}\relax{~\citep{tf-dls-2006, wf-esop-2009, afsw-popl-2011,
svctg-esop-2015, w-snapl-2015, vss-popl-2017}}.
Despite the authoritative name, this property is not the final word on blame.
It states that a run{-}time mismatch may occur only when an untyped value enters
a typed, or more{-}precisely typed, context; a typed value cannot trigger an error by
crossing to less{-}typed code.  The property is a useful design principle, but
does not distinguish the various semantics in the literature.
To its credit, the blame theorem does justify the slogan {``}well typed programs can{'}t be blamed{''}
 for a \relax{\nname} semantics under the assumption that all boundary types are correct.
The slogan does not apply, however, to a semantics such as \relax{\tname} that lets a
value cross a boundary without a complete type check.
Nor does it hold for incorrect types that were retroactively added to an
untyped program; refer to \hyperref[t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29]{figure~\FigureRef{25}{t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29}} for
one example and \relax{\citet{dnff-icfp-2016}} for further discussion.

\Ssubsubsection{Our Analysis}{Our Analysis}\label{t:x28part_x22Ourx5fAnalysisx22x29}

The primary formal property has to be type soundness, because it tells a
programmer that evaluation is well{-}defined in each component of a mixed{-}typed programs.

The second property, \emph{complete monitoring}, asks whether types
guard all statically{-}declared and dynamically{-}created channels of
communication between typed and untyped code. That is, whether every interaction
between typed and untyped code is mediated by run{-}time checks.

When a run{-}time check discovers a mismatch between a type specification and
a flow of values and the run{-}time system issues an error message, the
question arises how informative the message is to a debugging programmer.
\emph{Blame soundness} and \emph{blame completeness} ask whether a
mixed{-}typed semantics can identify the responsible parties when a run{-}time
type mismatch occurs.  Soundness asks for a subset of the potential
culprits; completeness asks for a superset.

Furthermore, the differences among type soundness theorems and the
gap between type soundness and complete monitoring suggests the
question how many errors an enforcement regime discovers. The answer is an
\emph{error preorder} relation, which compares semantics in terms of
the run{-}time mismatches that they discover.

Individually, each property characterizes a particular aspect of a
type{-}enforcement semantics. Together, the properties inform us about the
nature of the multi{-}faceted design space that this semantics problem opens
up. And in general, this work should help with the articulation of
consequences of design choices for the working developer.

\Ssubsection{Evaluation Framework}{Evaluation Framework}\label{t:x28part_x22secx3adesignx3abasicx22x29}

\label{sec:design:basic}

This section introduces the basic ideas of the evaluation framework;
 detailed formal definitions are deferred to chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechnicalx22x29}{4.5}{Technical Development}.
To formulate different type{-}enforcement strategies on an equal footing,
 the framework begins with one mixed{-}typed surface language (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3abasicx3asurfacex22x29}{4.4.1}{Surface Language})
 and models strategies as distinct semantics (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3asemanticx2dframeworkx22x29}{4.4.2}{Semantic Framework}).
The properties listed above support an analysis.
Type soundness (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3abasicx3atsx22x29}{4.4.3}{Type Soundness}) and complete monitoring (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3acmx22x29}{4.4.4}{Complete Monitoring})
 characterize the type mismatches that a semantics detects.
Blame soundness and blame completeness (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3aownershipx22x29}{4.4.5}{Blame Soundness, Blame Completeness})
 measure the quality of error messages.
The error preorder (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3abasicx3apreorderx22x29}{4.4.6}{Error Preorder}) enables direct behavioral comparisons.

\Ssubsubsection{Surface Language}{Surface Language}\label{t:x28part_x22secx3adesignx3abasicx3asurfacex22x29}

The surface multi{-}language combines two independent pieces in the
 style of \relax{\citet{mf-toplas-2009}}.
Statically{-}typed expressions constitute one piece;
 dynamically{-}typed expressions are the other half.
Technically, these expression languages are identified by two
 judgments: typed expressions \relax{$\sexpr_0$} satisfy \relax{$\sWT \sexpr_0 : \stype_0$}
 for some type \relax{$\stype_0$}, and untyped expressions \relax{$\sexpr_1$} satisfy
 \relax{$\sWT \sexpr_1 : \tdyn$} for the dynamic type.
Boundary expressions connect the two languages syntactically and
 enable run{-}time interactions.

Note that \relax{$\tdyn$} is not the flexible dynamic type that is compatible with
 any static type\relax{~\citep{t-popl-1990,st-sfp-2006}},
 rather, it is the uni{-}type that describes all well{-}formed untyped
 expressions\relax{~\citep{mf-toplas-2009}}.
Consequently, there is no need for a type precision judgment in the surface language
 because all mixed{-}typed interactions occur through boundary expressions.
How to add a dynamic type is a separate dimension that is orthogonal to the
 question of how to enforce types; with or without such a type,
 our results apply to the language{'}s type{-}enforcement strategy.
Whether the dynamic type is useful is a question for another time\relax{~\citep{g-snapl-2019}}.

The core statically{-}typed (\relax{$\svaluestat$}) and dynamically{-}typed (\relax{$\svaluedyn$})
 values are mirror images, and consist of integers, natural numbers, pairs, and functions.
This common set of values is the basis for typed{-}untyped communication.
Types \relax{$\stype$} summarize values:

\relax{\smallskip
  \qquad%
  \begin{langarray}
    \svaluestat & \BNFeq &
      \sint \mid \snat \mid \wideas{\epair{\svaluestat}{\svaluestat}}{\epair{\svaluedyn}{\svaluedyn}} \mid \efun{\tann{\svar}{\stype}}{\sexprstat}
    \\
    \svaluedyn & \BNFeq &
      \sint \mid \snat \mid \epair{\svaluedyn}{\svaluedyn} \mid \efun{\svar}{\sexprdyn}
    \\[1ex]
    \stype & \BNFeq &
      \tint \mid \tnat \mid \tfun{\stype}{\stype} \mid \tpair{\stype}{\stype}
  \end{langarray}
\smallskip}

These value sets are relatively small, but suffice to illustrate the behavior of
 gradual types for the basic ingredients of a full language.
First, the values include
 atomic data, finite structures, and higher{-}order values.
Second, the natural numbers \relax{$\snat$} are a subset of the integers \relax{$\sint$} to
 motivate a subtyping judgment for the typed half of the language.
Subtyping helps the model distinguish between two type{-}sound methods of
 enforcing types (declaration{-}site vs. use{-}site) and demonstrates how the
 model can scale to include true union types, which must be part of any type
 system for originally{-}untyped code\relax{~\citep{tf-icfp-2010,cl-icfp-2017,tfffgksst-snapl-2017}}.

Surface expressions include function application, primitive operations, and
 boundaries.
The details of the first two are fairly standard (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3asurfacex2dlanguagex22x29}{4.5.1}{Surface Syntax, Types, and Ownership}),
 but note that function application comes with an explicit \relax{$\sapp$} operator (\relax{$\sapp~\sexpr_0~\sexpr_1$}).
Boundary expressions are the glue that enables mixed{-}typed programming.
A program starts with named chunks of code, called components.
Boundary expressions link these chunks together with a static type
 to describe the types of values that may cross the boundary.
Suppose that a typed component named \relax{$\sowner_0$} imports and applies an
 untyped function from component \relax{$\sowner_1$}:

\relax{%% 2020-09-24 : still using tikz to get the fonts right
\begin{equation}
  \label{eq:bnd:e0}
  \begin{minipage}{27mm}
    {\hfill\(\sowner_1\)~~}\\[-3mm]
    \begin{mdframed}[style=dynframestyle,userdefinedwidth=27mm]\(
      \efun{\svar_0}{\ssum~\svar_0~2}
    \)\end{mdframed}
  \end{minipage}\begin{minipage}{24mm}\begin{tikzpicture}
    \node (A) {};
    \node (B) [right of=A,xshift=3em] {};
    \draw[->] (A)
      edge [bend left]
      node [above] {\raisebox{0pt}[0pt]{$\tfun{\tnat}{\tnat}$}}
      node [below,yshift=-3mm] {\raisebox{0pt}[0pt]{$f$}}
      (B);
  \end{tikzpicture}\end{minipage}\begin{minipage}{11mm}
    {\hfill\(\sowner_0\)~~~}\\[-3mm]
    \begin{mdframed}[style=staframestyle,userdefinedwidth=11mm]\(f~9\)\end{mdframed}
  \end{minipage}
\end{equation}}

\noindent{}The surface language can model the composition of these components with a boundary
 expression that embeds an untyped function in a typed context.
The boundary expression is annotated with a \emph{boundary specification}
 \relax{$\obnd{\sowner_0}{\tfun{\tnat}{\tnat}}{\sowner_1}$} to explain that
 component \relax{$\sowner_0$} expects a function from sender \relax{$\sowner_1$}:

\relax{\begin{displayrrarray}
  % note: purposefully avoiding the application type annotation
  \eqref{eq:bnd:e0} ~=~ \sapp~(\edynb{\obnd{\sowner_0}{\tfun{\tnat}{\tnat}}{\sowner_1}}{(\efun{\svar_0}{\ssum~\svar_0~2})})~9
\end{displayrrarray}}

\noindent{}In turn, this two{-}component expression may be imported into a larger
 untyped component.
The sketch below shows an untyped component in the center that imports
 two typed components:
 a new typed function on the left and the expression \relax{\eqref{eq:bnd:e0}}
 on the right.

\relax{\begin{equation}
  %% 2020-09-24 : still using tikz to get the fonts right
  \label{eq:bnd:e1}
  \begin{minipage}{42mm}
    {\hfill\(\sowner_3\)~~~}\\[-3mm]
    \begin{mdframed}[style=staframestyle,userdefinedwidth=42mm]\(
      \efun{\tann{\svar_1}{\tpair{\tint}{\tint}}}{\sfst~\svar_1}
    \)\end{mdframed}
  \end{minipage}\begin{minipage}{32mm}\begin{tikzpicture}
    \node (A) {};
    \node (B) [right of=A,xshift=5em] {};
    \node (vspace) [below of=A,yshift=7mm] {};
    \draw[->] (A)
      edge [bend left]
      node [above] {\raisebox{0pt}[0pt]{$\tfun{(\tpair{\tint}{\tint})}{\tint}$}}
      node [below,yshift=-2mm] {\raisebox{0pt}[0pt]{$g$}}
      (B);
  \end{tikzpicture}\end{minipage}\begin{minipage}{10mm}
    {\hfill\(\sowner_2\)~~}\\[-3mm]
    \begin{mdframed}[style=dynframestyle,userdefinedwidth=10mm]\(g~x\)\end{mdframed}
  \end{minipage}\begin{minipage}{17mm}\begin{tikzpicture}
    \node (A) {};
    \node (B) [right of=A,xshift=1em] {};
    \draw[<-] (A)
      edge [bend left]
      node [above] {\raisebox{0pt}[0pt]{$\tnat$}}
      node [below,yshift=-2mm] {\raisebox{0pt}[0pt]{$x$}}
      (B);
  \end{tikzpicture}\end{minipage}\begin{minipage}{7mm}
    \raisebox{-6mm}{\eqref{eq:bnd:e0}}
  \end{minipage}
\end{equation}}

\noindent{}When linearized to the surface language, this term becomes:

\relax{\begin{displayrrarray}
  \eqref{eq:bnd:e1} ~=~ \sapp~(\estab{\obnd{\sowner_2}{\tfun{\tpair{\tint}{\tint}}{\tint}}{\sowner_3}}{(\efun{\tann{\svar_1}{\tpair{\tint}{\tint}}}{\sfst~\svar_1})})
  \\[0.5ex]
  \hphantom{\eqref{eq:bnd:e1} ~=~ \sapp~}(\estab{\obnd{\sowner_2}{\tnat}{\sowner_0}}{\eqref{eq:bnd:e0}})
\end{displayrrarray}}

Technically, a boundary expression combines a boundary specification \relax{$\sbnd$}
 and a sender expression.
The specification includes the names of the client and sender components,
 in that order, along with a type to describe values that are intended to cross
 the boundary.
Names, such as \relax{$\sowner_0$}, come from some countable set \relax{$\sowner$}.
The boundary types guide the static type checker, but are mere suggestions
 unless a semantics decides to enforce them:

\relax{\smallskip
  \qquad%
  \begin{langarray}
    \sexprstat & \BNFeq &
      \ldots \mid \edynb{\sbnd}{\sexprdyn}
    \\
    \sexprdyn & \BNFeq &
      \ldots \mid \estab{\sbnd}{\sexprstat}
  \end{langarray}
  \qquad
  \begin{langarray}
    \sbnd & \BNFeq &
      \obnd{\sowner}{\stype}{\sowner}
    \\
    \sowner & \BNFeq &
      \textrm{\scountable{} set of names}
  \end{langarray}
\smallskip}

The typing judgments for typed and untyped expressions require a mutual
 dependence to handle boundary expressions.
A well{-}typed expression may include any well{-}formed untyped code.
Conversely, a well{-}formed untyped expression may include any typed expression
 that matches the specified annotation:

\relax{\smallskip
{\hfill
  \begin{minipage}{0.45\columnwidth}
    {\noindent\parbox[t]{\columnwidth}{{\fbox{$\stypeenv \sWT \sexpr : \stype$}}\\[-4mm]
    \begin{mathpar}
      \inferrule*{
        \stypeenv_0 \sWT \sexpr_0 : \tdyn
      }{
        \stypeenv_0 \sWT \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sexpr_0} : \stype_0
      }
    \end{mathpar}}}
  \end{minipage}\begin{minipage}{0.45\columnwidth}
    {\noindent\parbox[t]{\columnwidth}{{\fbox{$\stypeenv \sWT \sexpr : \tdyn$}}\\[-4mm]
    \begin{mathpar}
      \inferrule*{
        \stypeenv_0 \sWT \sexpr_0 : \stype_0
      }{
        \stypeenv_0 \sWT \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sexpr_0} : \tdyn
      }
    \end{mathpar}}}
  \end{minipage}
\hfill}\smallskip}

Each surface{-}language component must have a name,
 drawn from a set \relax{$\sowner$} of labels.
These names must be \emph{coherent} according to a judgment that validates an
 expression relative to a current name and a mapping from variables to names
 (\relax{\hyperref[fig:surface-ownership]{$\sownerenv; \sowner \sWL \sexpr$}}, chapter~\SecRefLocal{t:x28part_x22secx3adesignx3asurfacex2dlanguagex22x29}{4.5.1}{Surface Syntax, Types, and Ownership}).
All boundary specifications must have a client name that matches the current
 name, and variables bound in one component cannot appear free in a different
 one.

The purpose of the names is to enable a notion of \emph{ownership}, or responsibility.
As an expression reduces to a value, ownership determines which components are
 responsible for the current expression and all subexpressions.
Since component names appear in the surface syntax, they can help explain
 a run{-}time mismatch in terms of source{-}code boundaries.
Suppose a program halts due to a mismatch between a type and a value.
If one component is responsible for the value and the language can find both the
 client with the type expectation and source of the incompatible value, then a
 programmer knows exactly where to start debugging.

\Ssubsubsection{Semantic Framework}{Semantic Framework}\label{t:x28part_x22secx3adesignx3asemanticx2dframeworkx22x29}

The surface language enables the construction of mixed{-}typed expressions.
The next step is to assign behaviors to these programs via formal semantics
 that differ only in the way they enforce boundary types.

The first ingredient of a semantics is the set of result values \relax{$\svalue$} that
 expressions may reduce to.
A result set typically extends the core typed and untyped values mentioned above
 (\relax{$\svalue \supseteq \svaluestat \cup \svaluedyn$}).
Potential reasons for the extended value set include the following:


\noindent \begin{enumerate}\atItemizeStart

\item to permit untyped values in typed code, and vice versa;

\item to track the identity of values on a heap;

\item \label{val:monitor}
to associate a value with a delayed type{-}check; and

\item \label{val:trace}
to record the boundaries that a value has previously crossed.\end{enumerate}

\noindent Reasons \ref{val:monitor} and \ref{val:trace} introduce two kinds of
 wrapper value.
A guard wrapper, written \relax{$\emon{\sbnd}{\svalue}$}, associates a boundary
 specification with a value to achieve delayed type checks.
A trace wrapper, written \relax{$\ehist{\sblist}{\svalue}$}, attaches a list of
 boundaries to a value as metadata.
Guards are similar to boundary expressions; they separate a context
 component from a value component.
Trace wrappers simply annotate values.

Note that a language with the dynamic type will need a third
  wrapper for basic values that have been assigned type dynamic.
We conjecture that this wrapper is the only change needed to transfer our
 positive results.
Our negative results do not require changes for the dynamic type because
 such a language can express all our {``}precisely{-}typed{''} counterexample terms.

Second, a semantics must give reduction rules for boundary expressions.
These rules initiate a type{-}enforcement strategy.
For example, the \relax{\nname} semantics (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechx3anaturalx22x29}{4.5.5}{\relax{\nname} and its Properties})
 enforces full types via classic techniques\relax{~\citep{ff-icfp-2002,mf-toplas-2009}}.
It admits the following two reductions.
Note a filled triangle (\relax{$\snreddyn$}) describes a step in untyped
 code and an open triangle (\relax{$\snredsta$}) is for statically{-}typed code:

\relax{\begin{displayrrarray}
  \rrnum{a} \estab{\obnd{\sowner_0}{\tnat}{\sowner_1}}{42}
  & \nredND
  & 42
\end{displayrrarray}}

\relax{\begin{displayrrarray}
  \rrnum{b} \edynb{\obnd{\sowner_0}{(\tfun{\tint}{\tnat})}{\sowner_1}}{(\efun{\svar_0}{{-8}})}
  & \nredNS
  \\\qquad\qquad\zerowidth{\emon{\obnd{\sowner_0}{(\tfun{\tint}{\tnat})}{\sowner_1}}{(\efun{\svar_0}{{-8}})}}
\end{displayrrarray}}

\noindent{}The first rule lets a typed number enter an untyped context.
The second rule gives typed code access to an untyped function through a newly{-}created
 guard wrapper.
Guard wrappers are a \emph{higher{-}order} tool for enforcing higher{-}order types.
As such, wrappers require elimination rules.
The \relax{\nname} semantics includes the following rule to unfold
 the application of a typed, guarded function into two boundaries:

\relax{\begin{displayrrarray}
   \rrnum{c} \sapp~{(\emon{\obnd{\sowner_0}{(\tfun{\tint}{\tnat})}{\sowner_1}}{(\efun{\svar_0}{{-8}})})}~{1}
   & \nredNS
   \\\qquad\qquad\zerowidth{\edynb{\obnd{\sowner_0}{\tnat}{\sowner_1}}{(\sapp~{(\efun{\svar_0}{{-8}})}~{(\estab{\obnd{\sowner_1}{\tint}{\sowner_0}}{1})})}}
\end{displayrrarray}}

\noindent{}Other semantics have different behavior at boundaries and
 different supporting rules.
The \relax{\tname} semantics (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechx3atransientx22x29}{4.5.8}{\relax{\tname} and its Properties}) takes a \emph{first{-}order}
 approach to boundaries.
Instead of using wrappers, it checks shapes at a boundary and guards
 elimination forms with shape{-}check expressions.
For example, the following simplified reduction demonstrates a successful check:

\relax{\begin{displayrrarray}
  \rrnum{d} \echecktwo{(\tpair{\tnat}{\tnat})}{\epair{{-1}}{{-2}}}{}
  & \nredTX
  & {\epair{{-1}}{{-2}}}
\end{displayrrarray}}

\noindent{}The triangle is filled gray (\relax{$\nredXsym$}) because \relax{\tname} is defined
 via one notion of reduction that handles both typed and untyped code.

These two points, values and checking rules, are the distinctive aspects of
 a semantics.
Other ingredients can be shared:
 errors, evaluation contexts, and interpretation of primitive operations.
Indeed, chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechx3aevalx22x29}{4.5.2}{Three Evaluation Syntaxes} defines three evaluation
 languages{---}higher{-}order, first{-}order, and erasure{---}that abstract over the
 common ingredients.

\Ssubsubsection{Type Soundness}{Type Soundness}\label{t:x28part_x22secx3adesignx3abasicx3atsx22x29}

Type soundness asks whether evaluation is well{-}defined, and whether
  a surface{-}language type predicts aspects of the result.
Since there are two kinds of surface expression, soundness has two parts:
 one for statically{-}typed code and one for dynamically{-}typed code.

For typed code, the question is whether code can trust the
 types of its subexpressions.
If an expression with static type \relax{$\stype_0$} reduces to a value,
 the question is what (if anything) the type \relax{$\stype_0$} predicts about that value.
There are a range of possible answers.
At one end, the result value may match the full type \relax{$\stype_0$} according
 to an evaluation{-}language typing judgment.
The other extreme is that the result is a well{-}formed value of indeterminate
 shape.
In both cases, the programmer knows that typed code cannot reach an undefined
 state during evaluation.

For untyped code, there is one surface type.
If an expression reduces to a value, then uni{-}type soundness can only guarantee
 that the result is a well{-}formed value of indeterminate shape.
The practical benefit of such a theorem is that untyped code cannot reach
 an undefined state through mixed{-}typed interactions.

Both parts combine into the following rough definition, where the
 function \relax{$\sXproj$} and judgment \relax{$\sWTX$} are parameters.
The function maps surface types to observations that one can make about a result;
 varying the choice of \relax{$\sXproj$} offers a spectrum of soundness for typed code.
The judgment \relax{$\sWTX$} matches a value with a description.

\relax{\definitionsketch{$\sXproj{}$-\textrm{type soundness}}{
  \begin{minipage}[t]{0.50\columnwidth}
    If\/ $\sexpr_0$ has static type\/ $\stype_0$ (\/$\sWT \sexpr_0 : \stype_0$),\\
     then one of the following holds:
     \vspace{-1ex}
    \begin{itemize}
      \item
        $\sexpr_0$ reduces to a value\/ $\svalue_0$\\ and\/ $\sWTX \svalue_0 : \fXproj{\stype_0}$
      \item
        $\sexpr_0$ reduces to an allowed error
      \item
        $\sexpr_0$ reduces endlessly.
    \end{itemize}
  \end{minipage}\begin{minipage}[t]{0.48\columnwidth}
    If\/ $\sexpr_0$ is untyped ($\sWT \sexpr_0 : \tdyn$),\\
     then one of the following holds:
     \vspace{-1ex}
    \begin{itemize}
      \item
        $\sexpr_0$ reduces to a value\/ $\svalue_0$\\ and\/ $\sWTX \svalue_0 : \tdyn$
      \item
        $\sexpr_0$ reduces to an allowed error
      \item
        $\sexpr_0$ reduces endlessly.
    \end{itemize}
  \end{minipage}
}}

\Ssubsubsection{Complete Monitoring}{Complete Monitoring}\label{t:x28part_x22secx3adesignx3acmx22x29}

Complete monitoring tests whether a mixed{-}typed semantics has control over
 every interaction between typed and untyped code.
If the property holds, then a programmer can rely on the language to run
 checks at the proper points, for example, between the library and client
 demonstrated in \hyperref[t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29]{figure~\FigureRef{25}{t:x28counter_x28x22figurex22_x22figx3atrx2dexamplex22x29x29}}.
Concretely, if a value passes through the type \relax{$(\tfun{\tint}{\tint})$}
 then complete monitoring guarantees that the language has control over
 every input to the function and every result that the function computes,
 regardless of whether these interactions occur in a typed or untyped context.

Because all such interactions originate at the boundaries
 between typed and untyped code,
 a simplistic way to formalize complete monitoring is to ask whether each
 boundary comes with a full run{-}time check when possible and an error otherwise.
A language that meets this strict requirement certainly has full control.
However, other good designs fail.
Suppose typed code expects a pair of integers and a semantics initially
 admits any pair at the boundary but eventually checks that the pair contains integers.
Despite the incomplete check at the boundary, this delayed{-}checking semantics eventually
 performs all necessary checks and should satisfy a complete monitoring theorem.
Higher{-}order values raise a similar question because a single run{-}time check
 cannot prove that a function value always behaves a certain way.
Nevertheless, a language that checks every call and return is in full control
 of the interactions between a function and its context.

Our definition of complete monitoring translates these ideas about
 interactions and control into statements about \emph{ownership labels}\relax{~\citep{dfff-popl-2011}}.
At the start of an evaluation, no interactions have occurred yet and every
 expression has one owner: the enclosing component.
The reduction of a boundary term is the semantics of an interaction in which
 a value flows from one sender component to a client.
At this point, the sender loses full control over the value.
If the value fully matches the type expectations of the client, then the loss
 of control is no problem and the client gains full ownership.
Otherwise, the sender and client may have to assume joint ownership of the value,
 depending on the nature of the reduction relation.
If a semantics can create a value with multiple owners, then it admits that
 a component may lose full control over its interactions with other components.

Technically, an ownership label \relax{${}^{\sowner_0}$} names one source{-}code component.
Expressions and values come with at least one ownership label;
 for example, \relax{$\obars{42}{\sowner_0}$} is an integer with one owner
 and \relax{$\obars{\obars{\obars{42}{\sowner_0}}{\sowner_1}}{\sowner_2}$} is an
 integer with three owners, written \relax{$\obbars{42}{\fconcat{\sowner_0}{\fconcat{\sowner_1}{\sowner_2}}}$} for short.
A complete monitoring theorem requires two ingredients that manage these labels.
First, a reduction relation \relax{$\samplerred$}
 must propagate ownership labels to reflect interactions and checks.
Second, a single{-}ownership judgment \relax{$\sWL$} must test whether every value in an
 expression has a unique owner.
To satisfy complete monitoring, reduction must preserve single{-}ownership.

The key single{-}ownership rules deal with labeled expressions and boundary terms:

\relax{\smallskip
\lbl{\fbox{$\sownerenv; \sowner \sWL \sexpr$}}{\begin{mathpar}
    \inferrule*{
      \sownerenv_0; \sowner_0 \sWL \sexpr_0
    }{
      \sownerenv_0; \sowner_0 \sWL \obars{\sexpr_0}{\sowner_0}
    }

    \inferrule*{
      \sownerenv_0; \sowner_1 \sWL \sexpr_0
    }{
      \sownerenv_0; \sowner_0 \sWL \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sexpr_0}
    }

\end{mathpar}}}

\noindent{}Values such as \relax{$\obbars{42}{\fconcat{\sowner_0}{\sowner_1}}$}
 represent a communication that slipped past the run{-}time checking protocol,
 and therefore fail to satisfy single ownership.
\textbf{Sneak Preview:} One way that a semantics can transfer a higher{-}order value
without creating a joint{-}ownership is by providing controlled access through
a wrapper.
The client owns the wrapper, and the sender retains ownership of the enclosed value.

\relax{\definitionsketch{\textrm{complete monitoring}}{
  For all\/ ${}\sWL \sexpr_0$,
  any reduction\/ $\sexpr_0 \samplerred \sexpr_1$
  implies\/ ${}\sWL \sexpr_1$.
}\smallskip}

The definition of complete monitoring is deceptively simple because it assumes
 a reduction relation that correctly propagates labels.
In practice, a language comes with an unlabeled reduction relation,
 and it is up to a researcher to design a lifted relation that handles labeled terms.
Lifting requires insight to correctly transfer labels
 and to ensure that labels do not change the behavior of programs.
If labels do not transfer correctly, then a complete monitoring theorem becomes
 meaningless.
And if the lifted relation depends on labels to compute a result, then
 a complete monitoring theorem says nothing about the original reduction relation.

\Ssubsubsubsectionstarx{How to lift a reduction relation}{How to lift a reduction relation}\label{t:x28part_x22secx3adesignx3alawsx22x29}

\label{sec:design:laws}

The models in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechnicalx22x29}{4.5}{Technical Development} present six reduction relations
 for a mixed{-}typed language.
Each relation needs a lifted version to support an attempt at a complete
 monitoring proof.
These lifted reduction relations are deferred to an appendix,
 but come about semi{-}automatically through the
 following informal guidelines, or {``}natural laws,{''} for labeling.

Each law describes a way that labels may be transferred or dropped
 during evaluation.
To convey the general idea, each law also comes with a brief illustration, namely,
 an example reduction and a short comment.
The example reductions use a hypothetical \relax{$\samplerrarrow$} relation
 over the surface language.
Recall that \relax{$\sstat$} and \relax{$\sdyn$} are boundary terms; they link two
 components, a context and an enclosed expression, via a type.
When reading an example, accept the transitions
 \relax{$\sexpr\!\samplerrarrow\!\sexpr$} as axioms and focus on how the labels change
 in response.

\relax{{\begin{enumerate}
    %% NOTE when editing laws, remember there is an 8th in technical.tex for transient
    \itemsep1ex
    \item \label{law:base}
      If a base value reaches a boundary with a matching base type,
      then the value must drop its current labels as it crosses the boundary.
      %% NOTE before we said 'may drop' to avoid being too-restrictive,
      %%  but if 'may' is possible there's an argument that Natural is not
      %%  a complete monitor ... nor any semantics that lets base values cross.
      %% 'must' is less confusing and avoids this interpretation
    \subitem\hfill $\newcommand{\thevalue}{0}
              \obars{\estab{\obnd{\sowner_0}{\tnat}{\sowner_1}}{\obbars{\thevalue}{\fconcat{\sowner_2}{\sowner_1}}}}{\sowner_0}
              \samplerrarrow \obars{\thevalue}{\sowner_0}$
    \subitem\hfill
      \emph{The value\/ $0$ fully matches the type\/ $\tnat$.}

    %[law of no-check transfer]
    \item \label{law:cross}
      Any other value that crosses a boundary must acquire the label of
      the new context.
    \subitem\hfill
      $\newcommand{\thevalue}{\epair{{-2}}{1}}
                \obars{\estab{\obnd{\sowner_0}{\tnat}{\sowner_1}}{\obars{\thevalue}{\sowner_1}}}{\sowner_0}
                \samplerrarrow \obbars{\thevalue}{\fconcat{\sowner_1}{\sowner_0}}$
    \subitem\hfill
      \emph{The pair\/ $\epair{{-2}}{1}$ does not match the type\/ $\tnat$.}

    \item \label{law:pos}
      Every value that flows out of a value $\svalue_0$
      acquires the labels of $\svalue_0$ and the context.
    \subitem\hfill
      $\obars{\ssnd~{\obbars{\epair{\obars{1}{\sowner_0}}{\obars{2}{\sowner_1}}}{\fconcat{\sowner_2}{\sowner_3}}}}{\sowner_4}
       \samplerrarrow \obbars{2}{\fconcat{\sowner_1}{\fconcat{\sowner_2}{\fconcat{\sowner_3}{\sowner_4}}}}$
    \subitem\hfill
      \emph{The value\/ $2$ flows out of the pair\/ $\epair{1}{2}$.}

    \item \label{law:neg}
      Every value that flows into a function $\svalue_0$ acquires the label
      of the context and the reversed labels of $\svalue_0$.
    \subitem\hfill
      $\newcommand{\thevalue}{\epair{8}{6}}
       \obars{\sapp~{\obbars{\efun{\svar_0}{\sfst~{\svar_0}}}{\fconcat{\sowner_0}{\sowner_1}}}~{\obars{\thevalue}{\sowner_2}}}{\sowner_3}
       \samplerrarrow$
    \subitem\hfill
       $\newcommand{\thevalue}{\epair{8}{6}}
        \obars{\obbars{\sfst~{\obbars{\thevalue}{\fconcat{\sowner_2}{\fconcat{\sowner_3}{\fconcat{\sowner_1}{\sowner_0}}}}}}{\fconcat{\sowner_0}{\sowner_1}}}{\sowner_3}$
    \subitem\hfill
      \emph{The argument value\/ $\epair{8}{6}$ is input to the function.}
    \subitem\hfill
      \emph{The substituted body flows out of the function, and}
    \subitem\hfill
      \emph{by \lawref{law:pos} acquires the function's labels.}

    \item \label{law:new}
      A primitive operation ($\sdelta$) may remove labels on incoming base values.
    \subitem\hfill
      $\obars{\ssum~{\obars{2}{\sowner_0}}~{\obars{3}{\sowner_1}}}{\sowner_2}
       \samplerrarrow \obars{5}{\sowner_2}$
    \subitem\hfill
      \emph{Assuming\/ $\sdelta(\ssum, 2, 3) = 5$.}

    \item \label{law:dup}
      Consecutive equal labels may be dropped.
    \subitem\hfill
      $\obbars{0}{\fconcat{\sowner_0}{\fconcat{\sowner_0}{\fconcat{\sowner_1}{\sowner_0}}}} \eeq \obbars{0}{\fconcat{\sowner_0}{\fconcat{\sowner_1}{\sowner_0}}}$

    \item \label{law:error}
      Labels on an error term may be dropped.
    \subitem\hfill
      $\obars{\edynb{\obnd{\sowner_0}{\tint}{\sowner_1}}{(\ssum~{9}~{\obars{\divisionbyzeroerror}{\sowner_1}})}}{\sowner_0}
       \samplerrarrow \divisionbyzeroerror$

  \end{enumerate}}}

\noindent{}Note: \relax{\lawref{law:neg}} talks about functions, but generalizes to
 reference cells and other values that accept input.

To show how these laws generate a lifted reduction relation,
 the following rules lift the examples from chapter~\SecRefLocal{t:x28part_x22secx3adesignx3asemanticx2dframeworkx22x29}{4.4.2}{Semantic Framework}.
Each rule accepts input with any sequence of labels (\relax{$\sownerlist$}),
 pattern{-}matches the important ones, and shuffles via the guidelines.
The first rule (a{'}) demonstrates a base{-}type boundary (\relax{\lawref{law:base}}).
The second (b{'}) demonstrates a higher{-}order boundary (\relax{\lawref{law:cross}}); the
 new guard on the right{-}hand side implicitly inherits the context label.
The third rule (c{'}) sends an input (\relax{\lawref{law:neg}}) and creates new application
 and boundary expressions.
The fourth rule (d{'}) applies \relax{\lawref{law:pos}} for an output.

\relax{\begin{displayrrarray}
  \rrnum{a'} \obars{\estab{\obnd{\sowner_0}{\tnat}{\sowner_1}}{\obbars{42}{\sownerlist_2}}}{\sowner_3}
  & \nredND &
  \obars{42}{\sowner_3}
\end{displayrrarray}}

\relax{\begin{displayrrarray}
  \rrnum{b'} \obars{\edynb{\obnd{\sowner_0}{(\tfun{\tint}{\tnat})}{\sowner_1}}{\obbars{\efun{\svar_0}{\obbars{{-8}}{\sownerlist_2}}}{\sownerlist_3}}}{\sowner_4}
  & \nredNS &
  \\[0.5ex]\qquad\zerowidth{\obars{\emon{\obnd{\sowner_0}{(\tfun{\tint}{\tnat})}{\sowner_1}}{\obbars{\efun{\svar_0}{\obbars{{-8}}{\sownerlist_2}}}{\sownerlist_3}}}{\sowner_4}}
\end{displayrrarray}}

\relax{\begin{displayrrarray}
  \rrnum{c'} \obars{\sapp~{\obbars{\emon{\obnd{\sowner_0}{(\tfun{\tint}{\tnat})}{\sowner_1}}{\obars{\svalue_0}{\sowner_2}}}{\sownerlist_3}}~{\obbars{1}{\sownerlist_4}}}{\sowner_5}
  & \nredNS &
  \\[0.5ex]\qquad\zerowidth{\obars{\edynb{\obnd{\sowner_0}{\tnat}{\sowner_1}}{\obars{\sapp\,{\svalue_0}\,{(\estab{\obnd{\sowner_1}{\tint}{\sowner_0}}{\obbars{1}{\fconcat{\sownerlist_4}{\fconcat{\sowner_5}{\frev{\sownerlist_3}}}}})}}{\sowner_2}}}{\sowner_5}}
\end{displayrrarray}}

\relax{\begin{displayrrarray}
  \rrnum{d'} \obars{\echecktwo{(\tpair{\tnat}{\tnat})}{\obbars{\epair{\obbars{{-1}}{\sownerlist_0}}{\obbars{{-2}}{\sownerlist_1}}}{\sownerlist_2}}{}}{\sowner_3}
  & \nredTX
  \\[0.5ex]\qquad\qquad\zerowidth{\obbars{\epair{\obbars{{-1}}{\sownerlist_0}}{\obbars{{-2}}{\sownerlist_1}}}{\fconcat{\sownerlist_2}{\sowner_3}}}
\end{displayrrarray}}

Although the design of a lifted reduction relation is a challenge
 for every language,
 the laws in this section bring across the intuition behind prior
 formalizations of complete monitoring\relax{~\citep{dfff-popl-2011,dtf-esop-2012,tsdtf-oopsla-2012,mdffc-oopsla-2016}}
 and should help guide future work.

\Ssubsubsection{Blame Soundness, Blame Completeness}{Blame Soundness, Blame Completeness}\label{t:x28part_x22secx3adesignx3aownershipx22x29}

Blame soundness and blame completeness
 ask whether a semantics can identify the responsible parties
 in the event of a run{-}time mismatch.
A type mismatch occurs when a typed context receives an unexpected value.
The value may be the result of a boundary expression or an elimination form,
 and the underlying issue may lie with either the value,
 the current type expectation, or some prior communication.
In any event, a programmer needs to know which components previously handled
 the value to begin debugging.
A semantics offers information by blaming a set of boundaries (\relax{$\sbset$});
 the meta{-}question is whether those boundaries have any connection to the
 value at hand.

Suppose that a reduction halts on the value \relax{$\svalue_0$} and blames
 the set \relax{$\sbset_0$} of boundaries.
Ideally, the names in these boundaries should list exactly the components that
 have handled this value.
Ownership labels let us state the question precisely.
The lifted variant of the same reduction provides an independent specification
 of the responsible components; namely, the owners that get attached to
 \relax{$\svalue_0$} as it crosses boundaries.
Relative to this source{-}of{-}truth, blame soundness asks whether the
 names in \relax{$\sbset_0$} are a subset of the true owners.
Blame completeness asks for a superset of the true owners.

A semantics can trivially satisfy blame soundness alone by reporting an empty
 set of boundaries.
Conversely, the trivial way to achieve blame completeness is to blame
 every boundary for every possible mismatch.
The real challenge is to satisfy both or implement a pragmatic tradeoff.

\relax{\definitionsketch{\textrm{blame soundness}}{
  For all reductions that end in a mismatch for value\/ $\svalue_0$
  blaming boundaries\/ $\sbset_0$,
  the names in\/ $\sbset_0$
  are a \textbf{\emph{subset}} of the labels on\/ $\svalue_0$.
}}

\relax{\definitionsketch{\textrm{blame completeness}}{
  For all reductions that end in a mismatch for value\/ $\svalue_0$
  blaming boundaries\/ $\sbset_0$,
  the names in\/ $\sbset_0$
  are a \textbf{\emph{superset}} of the labels on\/ $\svalue_0$.
}\smallskip}

The propagation laws above (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alawsx22x29}{4.4.4.1}{How to lift a reduction relation}) specify one way
 to manage ownership labels.
But other ground{-}truth strategies are possible,
 and may provide insights about semantics that fail to be blame{-}sound and
 blame{-}complete with the standard labeling.
As a case in point, the \relax{\tname} semantics (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechx3atransientx22x29}{4.5.8}{\relax{\tname} and its Properties}) uses heap addresses
 to allow mixed{-}typed interaction without wrapper expressions.
The evaluation of a function, for example, draws a fresh heap address \relax{$\eloc_0$}
 and stores the function on a value heap (\relax{$\vstore$}).

\relax{\begin{displayrrarray}
  \conf{(\efun{\svar_0}{\svar_0})}{\vstore_0}{\bstore_0}
  &  \nredTX
  &  \conf{\eloc_0}{(\eset{\vrecord{\eloc_0}{(\efun{\svar_0}{\svar_0})}} \cup \vstore_0)}{(\eset{\brecord{\eloc_0}{\semptymap}} \cup {\bstore_0})}\!\!\!\!
  \\\sidecond{where $\ffresh{\eloc_0}{\vstore_0\mbox{ and }\bstore_0}$}
\end{displayrrarray}}

\noindent{}When the pointer \relax{$\eloc_0$} crosses a boundary,
 the semantics records the crossing on a blame heap (\relax{$\bstore$}).
The blame heap provides a set of boundaries if a type mismatch occurs,
 but this set is typically unsound because it conflates different
 pointers to the same value.
Propagating labels onto the heap, however, enables a conjecture
 that \relax{\tname} blames only boundaries that are relevant to the address of the
 incompatible value.

\Ssubsubsection{Error Preorder}{Error Preorder}\label{t:x28part_x22secx3adesignx3abasicx3apreorderx22x29}

Whereas the preceding properties characterize the semantics independently of each other,
 an \emph{error preorder relation} allows direct comparisons.
Strategies that perform many eager run{-}time checks have a lower position in
 the order.

One semantics lies below another in this preorder,
 written \relax{$\xsym \sbehaviorle \ysym$},
 if it raises errors on at least as many well{-}formed input expressions.
Put another way,
 \relax{$\xsym{} \sbehaviorle \ysym{}$}
 if and only if the latter reduces at least as many expressions to a result value.
Note that semantics do not need to raise the same error when they both agree
 that a program is faulty.
When two semantics agree about which expressions raise run{-}time errors,
 the notation \relax{$\xsym{} \sbehavioreq \ysym{}$} shows that they lie below one
 another.

\relax{\definitionsketch{\textrm{error preorder }$\sbehaviorle$}{
  $\xsym \sbehaviorle \ysym$
  iff\/ $\eset{\sexpr_0 \mid \fexists{\svalue_0}{\sexpr_0 \rredX \svalue_0}} \subseteq \eset{\sexpr_1 \mid \fexists{\svalue_1}{\sexpr_1 \rredY \svalue_1}}$.
}}

\relax{\definitionsketch{\textrm{error equivalence }$\sbehavioreq$}{
  $\xsym \sbehavioreq \ysym$
  iff\/ $\xsym \sbehaviorle \ysym$
  and\/ $\ysym \sbehaviorle \xsym$.
}}

\Ssubsection{Technical Development}{Technical Development}\label{t:x28part_x22secx3adesignx3atechnicalx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{{ %\newcommand{}{}
  \tikzstyle{every node}=[align=center]
  \begin{tikzpicture}
    \node (00) [text width=6em] {Surface stx.\\\sectionref{sec:design:surface-language}};
    \draw [line width=0.50mm] (00.south west)--(00.south east);
    \node (01) [text width=4em,below of=00,yshift=-0.1cm] {\raisebox{-2.5mm}{($\sWT \sexpr : \stype$)}\\{~}};

    \node (00top) [right of=01,xshift=2mm,inner sep=0mm,minimum size=0mm] {};
    \node (00mid) [below of=00top,yshift=-2cm,inner sep=0mm,minimum size=0mm] {};

    \node (10) [text width=7.5em,right of=00,xshift=2.6cm] {Evaluation stx.\\\sectionref{sec:design:tech:eval}};
    \draw [line width=0.50mm] (10.south west)--(10.south east);
    \node (11) [text width=10em,below of=10,yshift=-0.1cm] {Higher Ord. ($\sWTfull\!\sexpr\!:\!\stype$)\\\sectionref{sec:design:tech:eval:HO}};
    \node (12) [text width=8em,below of=11,yshift=-2.00cm] {Flat ($\sWTtag \sexpr : \stag$)\\\sectionref{sec:design:tech:eval:FO}};
    \node (13) [text width=8em,below of=12,yshift=-0.95cm] {Erased ($\sWTnone \sexpr : \tdyn$)\\\sectionref{sec:design:tech:eval:E}};

    \node (20) [right of=10,xshift=10mm] {};
    \node (21) [draw,ellipse,x radius=0mm,below of=20,yshift=-1.1cm,outer sep=2mm] {$({\snredsta},{\snreddyn})$\\\(\!\!\!\!\!\!\)sec.~\ref{sec:design:tech:common-HO}\(\!\!\!\!\!\!\)};

    \node (20mid) [right of=21,xshift=3mm,inner sep=0mm,minimum size=0mm] {};
    \node (20bot) [below of=20mid,inner sep=0mm,minimum size=0mm] {};
    \node (20bot2) [below of=20bot,yshift=1mm,inner sep=0mm,minimum size=0mm] {};
    \node (20bot3) [below of=20bot2,yshift=8mm,inner sep=0mm,minimum size=0mm] {};

    \node (30) [text width=6em,right of=20,xshift=2.0cm] {Semantics\\{~}};
    \draw [line width=0.50mm] (30.south west)--(30.south east);
    \node (31) [text width=6em,below of=30,yshift=-0.1cm] {$\nscr{}$ (${\nredNS}$,${\nredND}$)\\\sectionref{sec:design:tech:natural}};
    \node (32) [text width=6em,below of=31] {$\cscr{}$ (${\nredCS}$,${\nredCD}$)\\\sectionref{sec:design:tech:conatural}};
    \node (33) [text width=6em,below of=32] {$\fscr{}$ (${\nredFS}$,${\nredFD}$)\\\sectionref{sec:design:tech:forgetful}};
    \node (34) [text width=6em,below of=33] {$\tscr{}$ (\wideas{\nredTX$)$}{{\nredFS}$,${\nredFD}}\\\sectionref{sec:design:tech:transient}};
    \node (35) [text width=6em,below of=34] {$\ascr{}$ (${\nredAS}$,${\nredAD}$)\\\sectionref{sec:design:tech:amnesic}};
    \node (36) [text width=6em,below of=35] {$\escr{}$ (\wideas{\nredEX$)$}{{\nredFS}$,${\nredFD}}\\\sectionref{sec:design:tech:erasure}};

    \draw[->,dashed] (00) -- (10);
    \draw[->,dashed] (10) -- (30);

    \draw[black!75!white,->] (01) -- (11);
    \draw[black!75!white] (00top) -- (00mid);
    \draw[black!75!white,->] (00mid) -- (12);
    \draw[black!75!white,->] (00mid) |- (13);
    \draw[black!75!white,->] (11) |- (21);
    \draw[black!75!white,->] (20mid) |- (31);
    \draw[black!75!white,->] (21) -- (32);
    \draw[black!75!white] (20mid) -- (20bot);
    \draw[black!75!white,->] (20bot) -- (33);
    \draw[black!75!white,-] (20bot) -- (20bot2);
    \draw[black!75!white,-] (20bot2) arc(90:270:0.10) (20bot3);
    \draw[black!75!white,->] (20bot3) |- (35);
    \draw[black!75!white,->] (12) -- (34);
    \draw[black!75!white,->] (13) -- (36);

  \end{tikzpicture}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atechnicalx2doutlinex22x29x29}Figure~27: }{t:x28counter_x28x22figurex22_x22figx3atechnicalx2doutlinex22x29x29}Map of basic definitions in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechnicalx22x29}{4.5}{Technical Development}}}\end{FigureMulti}

This section presents the main technical details of our analysis: the model,
 the six semantics, and the properties that each semantics satisfies.
Because this is a long and intricate section, \hyperref[t:x28counter_x28x22figurex22_x22figx3atechnicalx2doutlinex22x29x29]{figure~\FigureRef{27}{t:x28counter_x28x22figurex22_x22figx3atechnicalx2doutlinex22x29x29}} gives an outline.
The discussion begins with one surface syntax (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3asurfacex2dlanguagex22x29}{4.5.1}{Surface Syntax, Types, and Ownership})
 and proceeds with three target languages that can run surface programs (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechx3aevalx22x29}{4.5.2}{Three Evaluation Syntaxes}).
Each target comes with a target type system; type soundness relates
 surface types to target types.
Chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechx3acommonx2dHOx22x29}{4.5.4}{Common Higher{-}Order Notions of Reduction} presents notions of reduction that are shared
 among several languages.
The final sections state the six base semantics and their properties.

Several properties depend on a lifted semantics that propagates
 ownership labels in accordance with the guidelines from chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alawsx22x29}{4.4.4.1}{How to lift a reduction relation}.
This means that the map in \hyperref[t:x28counter_x28x22figurex22_x22figx3atechnicalx2doutlinex22x29x29]{figure~\FigureRef{27}{t:x28counter_x28x22figurex22_x22figx3atechnicalx2doutlinex22x29x29}} is only half
 of the formal development; each syntax and semantics has a parallel, lifted version.
Chapter~\SecRefLocal{t:x28part_x22secx3adesignx3asurfacex2dlanguagex22x29}{4.5.1}{Surface Syntax, Types, and Ownership} presents the lifted surface syntax, but other
 sections give only the most important details regarding ownership.
Full definitions appear in the appendix.

\Ssubsubsection{Surface Syntax, Types, and Ownership}{Surface Syntax, Types, and Ownership}\label{t:x28part_x22secx3adesignx3asurfacex2dlanguagex22x29}

\label{sec:design:surface-language}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{\ssurfacelang}}{
  \begin{tabular}{l@{~}l}
    \begin{langarray}
      \sexpr & \BNFeq &
        \svar \mid \sint \mid \snat \mid
        \epair{\sexpr}{\sexpr} \mid
        \efun{\svar}{\sexpr} \mid
      \\ & &
        \efun{\tann{\svar}{\stype}}{\sexpr} \mid
      \\ & &
        \eapp{\stoptional}{\sexpr}{\sexpr} \mid
      \\ & &
        \eunopt{\stoptional}{\sexpr} \mid
      \\ & &
        \ebinopt{\stoptional}{\sexpr}{\sexpr} \mid
      \\ & &
        \edynb{\sbnd}{\sexpr} \mid
        \estab{\sbnd}{\sexpr}
      \\
      \stype & \BNFeq &
        \tint \mid \tnat \mid \tfun{\stype}{\stype} \mid \tpair{\stype}{\stype}
      \\
      \stoptional & \BNFeq &
        \stype \mid \tdyn
    \end{langarray}
    &
    \begin{langarray}
      \sbnd & \BNFeq &
        \obnd{\sowner}{\stype}{\sowner}
      \\
      \sbset & \BNFeq &
        \powerset{\sbnd}
      \\
      \sowner & \BNFeq &
        \textrm{\scountable{} set of names}
      \\
      \sownerlist & \BNFeq &
        \textrm{sequences of names}
      \\
      \stypeenv & \BNFeq &
        \snil \mid \fcons{\tann{\svar}{\stoptional}}{\stypeenv}
      \\
      \sint & \BNFeq & \integers
      \\
      \snat & \BNFeq & \naturals
      \\
      \sunop & \BNFeq &
        \sfst \mid \ssnd
      \\
      \sbinop & \BNFeq &
        \ssum \mid \squotient
    \end{langarray}
  \end{tabular}
}

\bigskip
\lbl{\fbox{$\stypeenv \sWT \sexpr : \stype$}~\missingrules{}}{
  \begin{mathpar}
    \inferrule*{
      \tann{\svar_0}{\stype_0} \in \stypeenv_0
    }{
      \stypeenv_0 \sWT \svar_0 : \stype_0
    }

    \inferrule*{
      \fcons{\tann{\svar_0}{\stype_0}}{\stypeenv_0} \sWT \sexpr_0 : \stype_1
    }{
      \stypeenv_0 \sWT \efun{\tann{\svar_0}{\stype_0}}{\sexpr_0} : \tfun{\stype_0}{\stype_1}
    }

    \inferrule*{
      \stypeenv_0 \sWT \sexpr_0 : \stype_1
      \\\\
      \sDelta(\sunop, \stype_1) \subteq \stype_0
    }{
      \stypeenv_0 \sWT \eunopt{\stype_0}{\sexpr_0} : \stype_0
    }

    \inferrule*{
      \stypeenv_0 \sWT \sexpr_0 : \tfun{\stype_1}{\stype_2}
      \\
      \stypeenv_0 \sWT \sexpr_1 : \stype_1
      \\\\
      \stype_2 \subteq \stype_0
    }{
      \stypeenv_0 \sWT \eapp{\stype_0}{\sexpr_0}{\sexpr_1} : \stype_0
    }

    \inferrule*{
      \stypeenv_0 \sWT \sexpr_0 : \tdyn
    }{
      \stypeenv_0 \sWT \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sexpr_0} : \stype_0
    }

  \end{mathpar}
}

\bigskip
\lbl{\fbox{$\stypeenv \sWT \sexpr : \tdyn$}~\missingrules{}}{
  \begin{mathpar}
    \inferrule*{
      \tann{\svar_0}{\tdyn} \in \stypeenv_0
    }{
      \stypeenv_0 \sWT \svar_0 : \tdyn
    }

    \inferrule*{
      \fcons{\tann{\svar_0}{\tdyn}}{\stypeenv_0} \sWT \sexpr_0 : \tdyn
    }{
      \stypeenv_0 \sWT \efun{\svar_0}{\sexpr_0} : \tdyn
    }

    \inferrule*{
      \stypeenv_0 \sWT \sexpr_0 : \stype_0
    }{
      \stypeenv_0 \sWT \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sexpr_0} : \tdyn
    }

  \end{mathpar}
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3asurfacex2dlanguagex22x29x29}Figure~28: }{t:x28counter_x28x22figurex22_x22figx3asurfacex2dlanguagex22x29x29}Surface syntax and typing rules}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3asurfacex2dlanguagex22x29x29]{Figure~\FigureRef{28}{t:x28counter_x28x22figurex22_x22figx3asurfacex2dlanguagex22x29x29}} presents the syntax and typing judgments for
 the common syntax sketched in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3abasicx3asurfacex22x29}{4.4.1}{Surface Language}.
Expressions \relax{$\sexpr$} include variables, integers, pairs, functions,
 primitive operations, applications, and boundary expressions.
The primitive operations consist of pair projections
 and arithmetic functions, to model interactions with a runtime system.
A \relax{$\sdyn$} boundary expression embeds a dynamically{-}typed expression into
 a statically{-}typed context,
 and a \relax{$\ssta$} boundary expression embeds a typed expression in an untyped context.

A type specification \relax{$\stoptional$} is either a static type \relax{$\stype$}
 or the symbol \relax{$\tdyn$} for untyped code.
Fine{-}grained mixtures of \relax{$\stype$} and \relax{$\tdyn$}, such as \relax{$\tpair{\tint}{\tdyn}$},
 are not permitted; the model describes two parallel syntaxes
 that are connected through boundary expressions (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3abasicx3asurfacex22x29}{4.4.1}{Surface Language}).
A statically{-}typed expression \relax{$\sexpr_0$} is one where the judgment
 \relax{$\stypeenv_0 \sWT \sexpr_0 : \stype_0$} holds for some type environment
 and type.
This judgment depends on a standard notion of subtyping (\relax{$\subteq$}) that is
 based on the relation \relax{$\tnat \subteq \tint$}, is covariant for pairs and
 function codomains, and is contravariant for function domains.
The metafunction \relax{$\sDelta$} determines the output type of a primitive operation.
For example the sum of two natural numbers is a natural (\relax{$\sDelta(\ssum, \tnat, \tnat) = \tnat$})
 but the sum of two integers returns an integer.
A dynamically{-}typed expression \relax{$\sexpr_1$} is one for which
 \relax{$\stypeenv_1 \sWT \sexpr_1 : \tdyn$} holds for some environment.

Every function application and operator application comes with a type
 specification \relax{$\stoptional$} for the expected result.
These annotations serve two purposes:
 to determine the behavior of the \relax{\tname} and \relax{\aname} semantics,
 and to tell apart statically{-}typed and dynamically{-}typed redexes.
An implementation could easily infer valid annotations.
The model keeps them explicit to easily formulate examples where subtyping
 affects behavior; for instance, the source{-}language terms
 \relax{$\eunopt{\tnat}{\sexpr_0}$} and
 \relax{$\eunopt{\tint}{\sexpr_0}$} may lead to different run{-}time checks.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{  \lbl{\fbox{Ownership Syntax}}{
    \begin{langarray}
      \sexpr & \BNFeq &
        \svar \mid \sint \mid \snat \mid
        \epair{\sexpr}{\sexpr} \mid
        \efun{\svar}{\sexpr} \mid
        \efun{\tann{\svar}{\stype}}{\sexpr} \mid
        \eapp{\stoptional}{\sexpr}{\sexpr} \mid
        \eunopt{\stoptional}{\sexpr} \mid
      \\ & &
        \ebinopt{\stoptional}{\sexpr}{\sexpr} \mid
        \edynb{\sbnd}{\obars{\sexpr}{\sowner}} \mid
        \estab{\sbnd}{\obars{\sexpr}{\sowner}} \mid
        \obars{\sexpr}{\sowner}
      \\
      \sowner & \BNFeq &
        \textrm{\scountable{} set}
      \\
      \sownerenv & \BNFeq &
        \snil \mid \fcons{\tann{\svar}{\sowner}}{\sownerenv}
    \end{langarray}
  }

\bigskip
  \lbl{\fbox{$\fwellformed{\sexpr}{\stoptional}$}}{\(\begin{array}{l} % well-formed expression
    \fwellformed{\obars{\sexpr_0}{\sowner_0}}{\stype_0}
    \\\mbox{\quad if}~\,\sowner_0 \sWLsingle \obars{\sexpr_0}{\sowner_0}
      \mbox{ and } \cdot \sWT \sexpr_0 : \stype_0
    \\
    \fwellformed{\obars{\sexpr_0}{\sowner_0}}{\tdyn}
    \\\mbox{\quad if}~\,\sowner_0 \sWLsingle \obars{\sexpr_0}{\sowner_0}
      \mbox{ and } \cdot \sWT \sexpr_0 : \tdyn
  \end{array}\)}

\bigskip
\lbl{\fbox{$\sownerenv; \sowner \sWLsingle \sexpr$}}{\begin{mathpar}
  \inferrule*{
    \tann{\svar_0}{\sowner_0} \in \sownerenv_0
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \svar_0
  }

  \inferrule*{
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \sint_0
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\sowner_0}}{\sownerenv_0}; \sowner_0 \sWLsingle \sexpr_0
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \efun{\svar_0}{\sexpr_0}
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\sowner_0}}{\sownerenv_0}; \sowner_0 \sWLsingle \sexpr_0
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \efun{\tann{\svar_0}{\stype_0}}{\sexpr_0}
  }

  \inferrule*{
    \sownerenv_0; \sowner_0 \sWLsingle \sexpr_0
    \\
    \sownerenv_0; \sowner_0 \sWLsingle \sexpr_1
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \epair{\sexpr_0}{\sexpr_1}
  }

  \inferrule*{
    \sownerenv_0; \sowner_0 \sWLsingle \sexpr_0
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \eunopt{\stoptional}{\sexpr_0}
  }

  \inferrule*{
    \sownerenv_0; \sowner_0 \sWLsingle \sexpr_0
    \\
    \sownerenv_0; \sowner_0 \sWLsingle \sexpr_1
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \ebinopt{\stoptional}{\sexpr_0}{\sexpr_1}
  }

  \inferrule*{
    \sownerenv_0; \sowner_0 \sWLsingle \sexpr_0
    \\
    \sownerenv_0; \sowner_0 \sWLsingle \sexpr_1
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \eapp{\stoptional}{\sexpr_0}{\sexpr_1}
  }

  \inferrule*{
    \sownerenv_0; \sowner_1 \sWLsingle \sexpr_0
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sexpr_0}
  }

  \inferrule*{
    \sownerenv_0; \sowner_1 \sWLsingle \sexpr_0
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sexpr_0}
  }

  \inferrule*{
    \sownerenv_0; \sowner_0 \sWLsingle \sexpr_0
  }{
    \sownerenv_0; \sowner_0 \sWLsingle \obars{\sexpr_0}{\sowner_0}
  }

  \end{mathpar}
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3asurfacex2downershipx22x29x29}Figure~29: }{t:x28counter_x28x22figurex22_x22figx3asurfacex2downershipx22x29x29}Ownership syntax and single{-}owner consistency}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3asurfacex2downershipx22x29x29]{Figure~\FigureRef{29}{t:x28counter_x28x22figurex22_x22figx3asurfacex2downershipx22x29x29}} extends the surface syntax
 with ownership labels and introduces a single{-}owner ownership consistency relation.
These labels record the component from which an expression originates.
The extended syntax brings one addition,
 labeled expressions \relax{$\obars{\sexpr}{\sowner}$},
 and a requirement that boundary expressions label their inner component.
The single{-}owner consistency judgment (\relax{$\sownerenv; \sowner \sWLsingle \sexpr$}) ensures
 that every subterm of an expression has a unique owner.
This judgment is parameterized by a mapping from variables to labels
 (\relax{$\sownerenv$}) and a context label (\relax{$\sowner$}).
Every variable reference must occur in a context that matches the variable{'}s
 map entry,
 every labeled expression must match the context,
 and every boundary expressions must have a client name that matches the
 context label.
For example, the expression
 \relax{$\obars{\edynb{\obnd{\sowner_0}{\tnat}{\sowner_1}}{\obars{\svar_0}{\sowner_1}}}{\sowner_0}$}
 is consistent under a mapping that contains \relax{$\tann{\svar_0}{\sowner_1}$}
 and the \relax{$\sowner_0$} context label.
The expression \relax{$\obars{\obars{42}{\sowner_0}}{\sowner_1}$}, also written
 \relax{$\obbars{42}{\fconcat{\sowner_0}{\sowner_1}}$} (\hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dmetax22x29x29]{figure~\FigureRef{31}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dmetax22x29x29}}),
 is inconsistent for any parameters.

Labels correspond to component names but come from a distinct set.
Thus the expression \relax{$(\edynb{\obnd{\sowner_0}{\tnat}{\sowner_1}}{\obars{\svar_0}{\sowner_1}})$}
 contains two names, \relax{$\sowner_0$} and \relax{$\sowner_1$}, and one label \relax{${}^{\sowner_1}$} that
 matches the inner component name.
The distinction separates an implementation from a specification.
A semantics, or implementation, manipulates component names to explain
 errors.
Labels serve as a specification to assess whether a semantics uses component names in a sensible way.
If the two could mix, then the specification would be a biased measure.

Lastly, a surface expression is well{-}formed
 (\relax{$\fwellformed{\sexpr}{\stoptional}$}) if it satisfies a typing judgment{---}either
 static or dynamic{---}and single{-}owner consistency under some labeling and context label \relax{$\sowner_0$}.
The theorems below all require well{-}formed expressions.

\Ssubsubsection{Three Evaluation Syntaxes}{Three Evaluation Syntaxes}\label{t:x28part_x22secx3adesignx3atechx3aevalx22x29}

\label{sec:design:tech:eval}

Each semantics requires a unique evaluation syntax, but overlaps among
 these six languages motivate three common definitions.
A \emph{higher{-}order} evaluation syntax supports type{-}enforcement strategies
 that require wrappers.
A \emph{flat} syntax, with simple checks rather than wrappers,
 supports \relax{\tname}.
And an \emph{erased} syntax supports the compilation of typed and
 untyped code to a common untyped host.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{  \lbl{\fbox{\sevallang}~extends \hyperref[fig:surface-language]{\ssurfacelang}}{
    \begin{langarray}
      \eerr & \BNFeq &
        \tagerrorD \mid
        \tagerrorS \mid
        \divisionbyzeroerror \mid
        \boundaryerror{\sbset}{\svalue}
      \\
      \sexpr & \BNFeq &
        \ldots \mid \eerr
      \\
      \stag & \BNFeq &
        \kint \mid \knat \mid \kpair \mid \kfun
      \\
      \ctx & \BNFeq &
        \ctxhole \!\mid
        \eapp{\stoptional}{\ctx\!}{\sexpr} \!\mid
        \eapp{\stoptional}{\svalue\!}{\ctx} \!\mid
        \epair{\ctx}{\sexpr} \!\mid
        \epair{\svalue}{\ctx} \!\mid
        \eunopt{\stoptional}{\!\ctx\!} \mid
      \\ & &
        \ebinopt{\stoptional}{\ctx}{\svalue} \mid
        \ebinopt{\stoptional}{\svalue}{\ctx} \mid
        \edynb{\sbnd}{\ctx} \mid
        \estab{\sbnd}{\ctx}
    \end{langarray}
  }

  \bigskip
\begin{flushleft}
    \(\tagof{\stype_0}
         {} \feq
          \left\{\begin{array}{ll}
            \knat & \quad\mbox{if $\stype_0 \eeq \tnat$}
            \\
            \kint & \quad\mbox{if $\stype_0 \eeq \tint$}
            \\
            \kpair & \quad\mbox{if $\stype_0 \in \tpair{\stype}{\stype}$}
            \\
            \kfun & \quad\mbox{if $\stype_0 \in \tfun{\stype}{\stype}\!\!$}
          \end{array}\right.\)

    \bigskip
    \( \fshallow{\stag_0}{\svalue_0}
         {} \feq
          \left\{\begin{array}{l@{~~}l}
            \makebox[2pt][l]{$\ftrue$}
            \\ & \mbox{\makebox[\widthof{or}][l]{if} $\stag_0 \eeq \knat$ and $\svalue_0 \in \snat$}
            \\ & \mbox{or $\stag_0 \eeq \kint$ and $\svalue_0 \in \sint$}
            \\ & \mbox{or $\stag_0 \eeq \kpair$ and}
            \\ & \quad\, \svalue_0 \in \epair{\svalue}{\svalue} \cup{}
            \\ & \zerowidth{\qquad\, \quad (\emon{\obnd{\sowner}{(\tpair{\stype}{\stype})}{\sowner}}{\svalue})}
            \\ & \mbox{or $\stag_0 \eeq \kfun$ and}
            \\ & \quad\, \svalue_0 \in (\efun{\svar}{\sexpr}) \cup (\efun{\tann{\svar}{\stype}}{\sexpr}) \cup{}
            \\ & \zerowidth{\qquad\, \quad (\emon{\obnd{\sowner}{(\tfun{\stype}{\stype})}{\sowner}}{\svalue})}
            \\
            \zerowidth{\fshallow{\stag_0}{\svalue_1}}
            \\ & \mbox{\makebox[\widthof{or}][l]{if} $\svalue_0 \eeq \ehist{\sbset_0}{\svalue_1}$}
            \\
            \zerowidth{\ffalse}
            \\ & \mbox{otherwise}
          \end{array}\right.  \)

\bigskip
    \( \sdelta(\sunop, \epair{\svalue_0}{\svalue_1})
        {} \feq
          \left\{\begin{array}{l@{~~}l}
            \makebox[2pt][l]{$\svalue_0$}
             & \quad\mbox{if $\sunop \eeq \tinst{\sfst}{\toptional}$}
            \\
            \zerowidth{\svalue_1}
             & \quad\mbox{if $\sunop \eeq \tinst{\ssnd}{\toptional}$}
          \end{array}\right.\)

    \bigskip
    \( \sdelta(\sbinop, \sint_0, \sint_1)
        {} \feq
           \left\{\begin{array}{l@{~~~}l}
             \makebox[2pt][l]{$\sint_0 + \sint_1$}
             \\ & \mbox{if $\sbinop \eeq \tinst{\ssum}{\stoptional}$}
             \\
             \zerowidth{\divisionbyzeroerror}
             \\ & \mbox{if $\sbinop \eeq \tinst{\squotient}{\stoptional}$}
             \\ & \mbox{and $\sint_1 \eeq 0$}
             \\
             \zerowidth{\floorof{\sint_0 / \sint_1}}
             \\ & \mbox{if $\sbinop \eeq \tinst{\squotient}{\stoptional}$}
             \\ & \mbox{and $\sint_1 \neq 0$}
           \end{array}\right.\)
\end{flushleft}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dcommonx22x29x29}Figure~30: }{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dcommonx22x29x29}Common evaluation syntax and metafunctions}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{flushleft}
  \(\frev{\sbset_0}
    {} \feq~
      \eset{\obnd{\sowner_1}{\stype_0}{\sowner_0}
    \,{}\mid \obnd{\sowner_0}{\stype_0}{\sowner_1} \in \sbset_0}\)

  \bigskip
  \(\fbsetsenders{\sbset_0}
    {} \feq~
    \eset{\sowner_1 \mid \obnd{\sowner_0}{\stype_0}{\sowner_1} \in \sbset_0}
  \)

  \bigskip
  \(\frev{\fconcat{\sowner_0}{\fconcat{\cdots}{\sowner_n}}}
    {} \feq~
      {\fconcat{\sowner_n}{\fconcat{\cdots}{\sowner_0}}}\)

  \bigskip
  \(\fvalueowners{\svalue_0}
     {} \feq
    \left\{\begin{array}{ll}
      \eset{\sowner_0} \cup \fvalueowners{\svalue_1}
       & \mbox{if $\svalue_0 \eeq \obars{\svalue_1}{\sowner_0}$}
      \\
      \fvalueowners{\svalue_1}
       & \mbox{if $\svalue_0 \eeq \ehist{\sbset_0}{\svalue_1}$}
      \\
      \eset{}
       & \mbox{otherwise}
    \end{array}\right.\)\\


\bigskip
\(\obbars{\sexpr_0}{\fconcat{\sowner_n}{\fconcat{\cdots}{\sowner_1}}} \eeq \sexpr_1
   \quad\sabbreveq\quad
  \sexpr_1 \eeq \obars{\cdots \obars{\sexpr_0}{\sowner_n} \cdots}{\sowner_1}\)
\end{flushleft}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dmetax22x29x29}Figure~31: }{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dmetax22x29x29}Metafunctions for boundaries and labels}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dcommonx22x29x29]{Figure~\FigureRef{30}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dcommonx22x29x29}} defines common aspects
 of the evaluation syntaxs.
These include errors \relax{$\eerr$}, shapes (or, constructors) \relax{$\stag$},
 evaluation contexts, and evaluation metafunctions.

A program evaluation may signal four kinds of errors:


\noindent \begin{enumerate}\atItemizeStart

\item A dynamic tag error (\relax{$\tagerrorD{}$}) occurs when
 an untyped redex applies an elimination form to a mis{-}shaped input.
For example, the first projection of an integer signals a tag error.

\item An invariant error (\relax{$\tagerrorS{}$}) occurs when the shape of a typed
 redex contradicts static typing; a {``}tag error{''} in typed code is one
 way to reach an invariant error.
One goal of type soundness is to eliminate such contradictions.

\item A division{-}by{-}zero error (\relax{$\divisionbyzeroerror$}) may be raised by an
 application of the \relax{$\squotient$} primitive;
 a full language will contain many similar primitive errors.

\item A boundary error (\relax{$\boundaryerror{\sbset}{\svalue}$})
 reports a mismatch between two components.
One component, the sender, provided the enclosed value.
A second component rejected the value.
The set of witness boundaries suggests potential sources for the fault;
 intuitively, this set should include the client{--}sender boundary.
The error \relax{$\boundaryerror{\eset{\obnd{\sowner_0}{\stype_0}{\sowner_1}}}{\svalue_0}$},
 for example,
 says that a mismatch between value \relax{$\svalue_0$} and type \relax{$\stype_0$} prevented
 the value sent by the \relax{$\sowner_1$} component from entering the \relax{$\sowner_0$} component.\end{enumerate}

The four shapes, \relax{$\stag$}, correspond both to type constructors and to value
 constructors.
Half of the correpondence is defined by the \relax{$\tagof{\cdot}$} metafunction,
 which maps a type to a shape.
The \relax{$\sshallow$} metafunction is the other half;
 it checks the top{-}level shape of a value.

Both metafunctions use an \relax{$\,\cdot \in \cdot\,$} judgment,
 which holds if a value is a member of a set.
The claim \relax{$\svalue_0 \in \snat$}, for example,  holds when the value \relax{$\svalue_0$}
 is a member of the set of natural numbers.
By convention, a variable without a subscript typically refers to a set
 and a term containing a set describes a comprehension.
The term \relax{$(\efun{\svar}{\svalue})$}, for instance, describes the
 set \relax{$\eset{(\efun{\svar_i}{\svalue_j}) \mid \svar_i \in \svar \wedge \svalue_j \in \svalue}$}
 of all functions that return some value.

The \relax{$\sshallow$} metafunction also makes reference to two value constructors
 unique to the higher{-}order evaluation syntax:
 guard \relax{$(\emon{\sbnd}{\svalue})$} and trace \relax{$(\ehist{\sbset}{\svalue})$} wrappers.
A guard has a shape determined by the type in its boundary.
A trace is metadata, so \relax{$\sshallow$} looks past it.
Chapter~\SecRefLocal{t:x28part_x22secx3adesignx3asemanticx2dframeworkx22x29}{4.4.2}{Semantic Framework} informally justifies the design, and
 \hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dhox22x29x29]{figure~\FigureRef{32}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dhox22x29x29}} formally introduces these wrapper values.

The final components of \hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dcommonx22x29x29]{figure~\FigureRef{30}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dcommonx22x29x29}} are the \relax{$\delta$}
 metafunctions.
These provide a standard, partial specification of the primitive operations.

\hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dmetax22x29x29]{Figure~\FigureRef{31}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dmetax22x29x29}} lists extra metafunctions for boundaries
 and ownership labels.
For boundaries, \relax{$\srev$} flips every client and sender name in
 a set of specifications.
Both \relax{\tname} and \relax{\aname} reverse boundaries at function calls.
If a function \$f\$ crosses one set \relax{$\sbset_0$} of boundaries,
 then an input to \$f\$ crosses the reversed boundaries \relax{$\frev{\sbset_0}$}
 before entering the function.
The \relax{$\sbsetsenders$} metafunction extracts the sender names from the
 right{-}hand side of every boundary specification in a set.
For labels, \relax{$\srev$} reverses a sequence.
The \relax{$\svalueowners$} metafunction collects the labels around an unlabeled
 value stripped of any trace{-}wrapper metadata.
Guard wrappers are not stripped because they represent boundaries.
Lastly, the abbreviation \relax{$\obbars{\cdot}{\cdot}$} captures a list of boundaries.
The term
 \relax{$\obbars{4}{\fconcat{\sowner_0}{\sowner_1}}$}
 is short for \relax{$\obars{\obars{4}{\sowner_0}}{\sowner_1}$}
 and \relax{$\obbars{5}{\sownerlist_0}$} matches \relax{$5$} with \relax{$\sownerlist_0$} bound to
 the empty list.

\Ssubsubsubsectionstarx{Higher{-}Order Syntax, Path{-}Based Ownership Consistency}{Higher{-}Order Syntax, Path{-}Based Ownership Consistency}\label{t:x28part_x22secx3adesignx3atechx3aevalx3aHOx22x29}

\label{sec:design:tech:eval:HO}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{\syntaxho{}}~extends \hyperref[fig:evaluation-common]{\sevallang}}{
  \begin{langarray}
    \sexpr & \BNFeq &
      \ldots \mid
      \eprehist{\sbset}{\sexpr}
    \\
    \svalue & \BNFeq &
      \sint \mid \snat \mid \epair{\svalue}{\svalue} \mid
      \efun{\svar}{\sexpr} \mid \efun{\tann{\svar}{\stype}}{\sexpr} \mid
      \emon{\sbnd}{\svalue} \mid
      \ehist{\sbset}{\svalue}
  \end{langarray}
}

\bigskip
\lbl{\fbox{$\stypeenv \sWTfull \sexpr : \stype$}~\missingrules{}, extends \hyperref[fig:surface-language]{$\,\stypeenv \sWT \sexpr : \stype$}}{
  \begin{mathpar}
    \inferrule*{
      \stypeenv_0 \sWTfull \svalue_0 : \tdyn
    }{
      \stypeenv_0 \sWTfull \emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0} : \stype_0
    }

    \inferrule*{
    }{
      \stypeenv_0 \sWTfull \eerr : \stype_0
    }

  \end{mathpar}
}

\bigskip
\lbl{\fbox{$\stypeenv \sWTfull \sexpr : \tdyn$}~\missingrules{}, extends \hyperref[fig:surface-language]{$\,\stypeenv \sWT \sexpr : \tdyn$}}{
  \begin{mathpar}
    \inferrule*{
      \stypeenv_0 \sWTfull \svalue_0 : \stype_0
    }{
      \stypeenv_0 \sWTfull \emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0} : \tdyn
    }

    \inferrule*{
      \stypeenv_0 \sWTfull \svalue_0 : \tdyn
    }{
      \stypeenv_0 \sWTfull \ehist{\sbset_0}{\svalue_0} : \tdyn
    }

    \inferrule*{
    }{
      \stypeenv_0 \sWTfull \eerr : \tdyn
    }

  \end{mathpar}
}

\lbl{\fbox{$\sownerenv; \sowner \sWLsingle \sexpr$}~\missingrules{}, extends \hyperref[fig:surface-ownership]{$\,\sownerenv; \sowner \sWLsingle \sexpr$}}{\begin{mathpar}
    \inferrule*{
      \sownerenv_0; \sowner_1 \sWLsingle \svalue_0
    }{
      \sownerenv_0; \sowner_0 \sWLsingle \emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    }

    \inferrule*{
      \sownerenv_0; \sowner_0 \sWLsingle \svalue_0
    }{
      \sownerenv_0; \sowner_0 \sWLsingle \ehist{\sbset_0}{\svalue_0}
    }
\end{mathpar}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dhox22x29x29}Figure~32: }{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dhox22x29x29}Higher{-}Order syntax, typing rules, and ownership consistency}}\end{FigureMulti}

The higher{-}order evaluation syntax (\hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dhox22x29x29]{figure~\FigureRef{32}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dhox22x29x29}}) introduces the two wrapper values
 described in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3asemanticx2dframeworkx22x29}{4.4.2}{Semantic Framework}.
A guard \relax{$(\emon{\obnd{\sowner}{\stype}{\sowner}}{\svalue})$}
 represents a boundary between two components.
A trace wrapper \relax{$(\ehist{\sbset}{\svalue})$} attaches metadata to a value.

Type{-}enforcement strategies typically use guard wrappers to constrain the
 behavior of a value.
For example, the \relax{\cname} semantics wraps any pair that crosses a boundary
 with a guard; this wrapper validates the elements of the pair upon
 future projections.
Trace wrappers do not constrain behavior.
A traced value simply comes with extra information; namely, a collection of
 the boundaries that the value has previously crossed.

The higher{-}order typing judgments, \relax{$\stypeenv \sWTfull \sexpr : \stoptional$},
 extend the surface typing judgments with rules for wrappers and errors.
Guard wrappers may appear in both typed and untyped code; the rules
 in each case mirror those for boundary expressions.
Trace wrappers may only appear in untyped code;
 this restriction simplifies the \relax{\aname} semantics (\hyperref[t:x28counter_x28x22figurex22_x22figx3aamnesicx2dreductionx22x29x29]{figure~\FigureRef{41}{t:x28counter_x28x22figurex22_x22figx3aamnesicx2dreductionx22x29x29}}).
A traced expression is well{-}formed iff the enclosed value is well{-}formed.
An error term is well{-}typed in any context.

\hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dhox22x29x29]{Figure~\FigureRef{32}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dhox22x29x29}} also extends the single{-}owner consistency judgment
 to handle wrapped values.
For a guard wrapper, the outer client name must match the context
 and the enclosed value must be single{-}owner consistent with the inner
 sender name.
For a trace wrapper, the inner value must be single{-}owner consistent
 relative to the context label.

\Ssubsubsubsectionstarx{Flat Syntax}{Flat Syntax}\label{t:x28part_x22secx3adesignx3atechx3aevalx3aFOx22x29}

\label{sec:design:tech:eval:FO}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{  \lbl{\fbox{\syntaxfo{}} \makebox[0pt][l]{extends \hyperref[fig:evaluation-common]{\sevallang}}}{
  \begin{tabular}{l@{~}l}
    \begin{langarray}
      \sexpr & \BNFeq &
        \ldots \mid
        \eloc \mid
        \echecktwo{\stoptional}{\sexpr}{\eloc}
      \\
      \svalue & \BNFeq &
        \sint \mid \snat \mid \eloc
      \\
      \sprevalue & \BNFeq &
        {\efun{\svar}{\sexpr}} \mid
        {\efun{\tann{\svar}{\stype}}{\sexpr}} \mid
        {\epair{\svalue}{\svalue}}
      \\
      \eloc & \BNFeq    & % \locations
        \textrm{\scountable{} set of heap locations}
    \end{langarray}
    &
    \begin{langarray}
      \vstore & \BNFeq &
        \powerset{(\vrecord{\eloc}{\sprevalue})}
      \\
      \bstore & \BNFeq &
        \powerset{(\brecord{\eloc}{\sbset})}
      \\
      \vstoretype & \BNFeq &
        \snil \mid \fcons{\tann{\eloc}{\stag}}{\vstoretype}
    \end{langarray}
  \end{tabular}
  }

  \medskip
  \begin{flushleft}
  \(\fmapref{\vstore_0}{\svalue_0}
     {} \feq
    \left\{\begin{array}{l@{\quad}l}
      \sprevalue_0 & \mbox{if $\svalue_0 \in \eloc$ and $(\vrecord{\svalue_0}{\sprevalue_0}) \in \vstore_0$}
      \\
      \svalue_0 & \mbox{if $\svalue_0 \not\in \eloc$}
    \end{array}\right.\)

  \smallskip
  \(\fmapref{\bstore_0}{\svalue_0}
    {} \feq
    \left\{\begin{array}{l@{\quad}l}
      \sbset_0 & \mbox{if $\svalue_0 \in \eloc$ and $(\brecord{\svalue_0}{\sbset_0}) \in \bstore_0$}
      \\
      \semptymap & \mbox{otherwise}
    \end{array}\right.\)

  \smallskip
  \(\fmapreplace{\bstore_0}{\svalue_0}{\sbset_0}
    {} \feq
    \left\{\begin{array}{l@{\quad}l}
      \zerowidth{\eset{\vrecord{\svalue_0}{\sbset_0}} \cup {(\bstore_0 \setminus (\vrecord{\svalue_0}{\sbset_1}))}}
      \\
      & \mbox{if $\svalue_0 \in \eloc$ and $(\vrecord{\svalue_0}{\sbset_1}) \in \bstore_0$}
      \\
      \bstore_0 & \mbox{otherwise}
    \end{array}\right.\)

  \smallskip
  \(\fmapupdate{\bstore_0}{\svalue_0}{\sbset_0}
     \feq
      \fmapreplace{\bstore_0}{\svalue_0}{\bappend{\sbset_0}{\fmapref{\bstore_0}{\svalue_0}}}\)
\end{flushleft}

\medskip
\lbl{\fbox{$\vstoretype; \stypeenv \sWTtag \sexpr : \stag$}~\missingrules{}}{
  \begin{mathpar}
    \inferrule*{
      \tann{\sloc_0}{\stag_0} \in \vstoretype_0
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \sloc_0 : \stag_0
    }

    \inferrule*{
      \tann{\svar_0}{\stype_0} \in \stypeenv_0
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \svar_0 : \ftagof{\stype_0}
    }

    \inferrule*{
      \vstoretype_0; \fcons{\tann{\svar_0}{\tdyn}}{\stypeenv_0} \sWTtag \sexpr_0 : \tdyn
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \efun{\svar_0}{\sexpr_0} : \kfun
    }

    \inferrule*{
      \vstoretype_0; \fcons{\tann{\svar_0}{\stype_0}}{\stypeenv_0} \sWTtag \sexpr_0 : \stag_0
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \efun{\tann{\svar_0}{\stype_0}}{\sexpr_0} : \kfun
    }

    \inferrule*{
      \vstoretype_0; \stypeenv_0 \sWTtag \sexpr_0 : \kfun
      \\
      \vstoretype_0; \stypeenv_0 \sWTtag \sexpr_1 : \stag_0
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \eapp{\stype_0}{\sexpr_0}{\sexpr_1} : \ftagof{\stype_0}
    }

    \inferrule*{
      \vstoretype_0; \stypeenv_0 \sWTtag \sexpr_0 : \kpair
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \eunopt{\stype_0}{\sexpr_0} : \ftagof{\stype_0}
    }

    \inferrule*{
      \vstoretype_0; \stypeenv_0 \sWT \sexpr_0 : \tdyn
    }{
      \vstoretype_0; \stypeenv_0 \sWT \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sexpr_0} : \ftagof{\stype_0}
    }

    \inferrule*{
      \vstoretype_0; \stypeenv_0 \sWTtag \sexpr_0 : \stag_0
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \echecktwo{\stype_0}{\sexpr_0}{\eloc_0} : \ftagof{\stype_0}
    }

    \inferrule*{
      \vstoretype_0; \stypeenv_0 \sWTtag \sexpr_0 : \tdyn
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \echecktwo{\stype_0}{\sexpr_0}{\eloc_0} : \ftagof{\stype_0}
    }

  \end{mathpar}
}

\medskip
\lbl{\fbox{$\vstoretype; \stypeenv \sWTtag \sexpr : \tdyn$}~\missingrules{}}{
  \begin{mathpar}
    \inferrule*{
      \tann{\sloc_0}{\stag_0} \in \vstoretype_0
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \sloc_0 : \tdyn
    }

    \inferrule*{
      \tann{\svar_0}{\tdyn} \in \stypeenv_0
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \svar_0 : \tdyn
    }

    \inferrule*{
      \vstoretype_0; \stypeenv_0 \sWTtag \sexpr_0 : \ftagof{\stype_0}
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sexpr_0} : \tdyn
    }

    \inferrule*{
      \vstoretype_0; \stypeenv_0 \sWTtag \sexpr_0 : \tdyn
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \echecktwo{\tdyn}{\sexpr_0}{\eloc_0} : \tdyn
    }

    \inferrule*{
      \vstoretype_0; \stypeenv_0 \sWTtag \sexpr_0 : \stag_0
    }{
      \vstoretype_0; \stypeenv_0 \sWTtag \echecktwo{\tdyn}{\sexpr_0}{\eloc_0} : \tdyn
    }
  \end{mathpar}
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dfox22x29x29}Figure~33: }{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dfox22x29x29}Flat syntax, typing rules, and ownership consistency}}\end{FigureMulti}

The flat syntax (\hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dfox22x29x29]{figure~\FigureRef{33}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dfox22x29x29}})
 supports wrapper{-}free gradual typing.
A new expression form, \relax{$(\echecktwo{\stoptional}{\sexpr}{\eloc})$},
 represents a shape check.
The intended meaning is that the given type must match the value of the
 enclosed expression.
If not, then the location \relax{$\eloc$} may be the source of the fault.
Locations are names for the pairs and functions in a program.
These names map to pre{-}values in a heap (\relax{$\vstore$})
 and, more importantly, to sets of boundaries in a blame map (\relax{$\bstore$}).
Pairs and functions are second{-}class pre{-}values (\relax{$\sprevalue$}) that
 must be allocated before they may be used.

Three meta{-}functions define heap operations:
 \relax{$\fmapref{\cdot}{\cdot}$}, \relax{$\fmapreplace{\cdot}{\cdot}{\cdot}$}, and \relax{$\fmapupdate{\cdot}{\cdot}{\cdot}$}.
The first gets an item from a finite map,
 the second replaces a blame heap entry,
 and the third extends a blame heap entry.
Because maps are sets, set union suffices to add new entries.

The flat typing judgments check the top{-}level shape (\relax{$\stag$}) of an expression
 and the well{-}formedness of any subexpressions.
These judgments rely on a store typing (\relax{$\vstoretype$})
 to describe heap{-}allocated values.
These types must be consistent with the actual values on the heap, a standard
 technical device that is spelled out in the appendix.
Untyped functions may appear in a typed context and vice{-}versa;
 there are no wrappers to enforce a separation.
Shape{-}check expressions are valid in typed and untyped contexts.

\Ssubsubsubsectionstarx{Erased Syntax}{Erased Syntax}\label{t:x28part_x22secx3adesignx3atechx3aevalx3aEx22x29}

\label{sec:design:tech:eval:E}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{\syntaxeo{}}~extends \hyperref[fig:evaluation-common]{\sevallang}}{
  \begin{langarray}
    \svalue & \BNFeq &
      \sint \mid \snat \mid \epair{\svalue}{\svalue} \mid \efun{\svar}{\sexpr} \mid \efun{\tann{\svar}{\stype}}{\sexpr}
  \end{langarray}
}

\bigskip
\lbl{\fbox{$\stypeenv \sWTnone \sexpr : \tdyn$}~\missingrules{}}{
  \begin{mathpar}
    \inferrule*{
      \tann{\svar_0}{\stoptional} \in \stypeenv_0
    }{
      \stypeenv_0 \sWTnone \svar_0 : \tdyn
    }

    \inferrule*{
      \fcons{\tann{\svar_0}{\tdyn}}{\stypeenv_0} \sWTnone \sexpr_0 : \tdyn
    }{
      \stypeenv_0 \sWTnone \efun{\svar_0}{\sexpr_0} : \tdyn
    }

    \inferrule*{
      \fcons{\tann{\svar_0}{\stype_0}}{\stypeenv_0} \sWTnone \sexpr_0 : \tdyn
    }{
      \stypeenv_0 \sWTnone \efun{\tann{\svar_0}{\stype_0}}{\sexpr_0} : \tdyn
    }

    \inferrule*{
      \stypeenv_0 \sWTnone \sexpr_0 : \tdyn
    }{
      \stypeenv_0 \sWTnone \edynb{\sbnd_0}{\sexpr_0} : \tdyn
    }

    \inferrule*{
      \stypeenv_0 \sWTnone \sexpr_0 : \tdyn
    }{
      \stypeenv_0 \sWTnone \estab{\sbnd_0}{\sexpr_0} : \tdyn
    }
  \end{mathpar}
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aevaluationx2deox22x29x29}Figure~34: }{t:x28counter_x28x22figurex22_x22figx3aevaluationx2deox22x29x29}Erased evaluation syntax and typing}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2deox22x29x29]{Figure~\FigureRef{34}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2deox22x29x29}} defines an evaluation syntax for type{-}erased
 programs.
Expressions include error terms; the typing judgment holds
 for any expression without free variables.
Aside from the type annotations left over from the surface syntax, which could be
 removed with a translation step, the result is a conventional dynamically{-}typed language.

\Ssubsubsection{Properties of Interest}{Properties of Interest}\label{t:x28part_x22secx3adesignx3atechx3apropertiesx22x29}

\label{sec:design:tech:properties}

\emph{Type soundness} guarantees that the evaluation of a well{-}formed expression
 (1) cannot end in an invariant error and (2) preserves an evaluation{-}language
 image of the surface type.
Note that an invariant error captures the classic idea of going wrong\relax{~\citep{m-jcss-1978}}.

\relax{\begin{definition}[$\sXproj{}$-type soundness]\label{def:ts}
  Let\/ $\sXproj$ map surface types to evaluation types.
  A semantics\/ $\xsym$
  satisfies\/ $\propts{\sXproj}$
  if for all\/ $\fwellformed{\sexpr_0}{\stoptional}$
  one of the following holds:
  \begin{itemize}
    \item
      $\sexpr_0 \rredX \svalue_0$ and\/ ${}\sWTX \svalue_0 : \sXproj(\stoptional)$
    \item
      $\sexpr_0 \rredX \eset{\tagerrorD{}, \divisionbyzeroerror{}} \cup \boundaryerror{\sbset}{\svalue}$
    \item
      $\fdiverge{\sexpr_0}{\rredX}$.
  \end{itemize}
\end{definition}}

\noindent{}Three surface{-}to{-}evaluation maps (\relax{$\sXproj$}) suffice for the evaluation languages:
 an identity map \relax{$\sidproj$},
 a type{-}shape map \relax{$\stagproj$} that extends the type{-}to{-}shape metafunction from \hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dcommonx22x29x29]{figure~\FigureRef{30}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dcommonx22x29x29}},
 and a constant map \relax{$\sdynproj$}:

\relax{\smallskip
\(\hfill
  \fidproj{\stoptional} \feq \stoptional
  \hfill
  \ftagproj{\stoptional} \feq
    \left\{\begin{array}{ll}
      \tdyn & \mbox{if\/ $\,\stoptional \eeq \tdyn$}
      \\
      \ftagof{\stype_0} & \mbox{if\/ $\,\stoptional \eeq \stype_0$}
    \end{array}\right.
  \hfill
  {\fdynproj{\stoptional} \feq \tdyn}
  \hfill\)
\smallskip}

\emph{Complete monitoring} guarantees that the type on each component boundary
 monitors all interactions between client and server components.
The definition of {``}all interactions{''} comes from the
 path{-}based ownership propagation laws (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alawsx22x29}{4.4.4.1}{How to lift a reduction relation});
 the labels on a value enumerate all partially{-}responsible components.
Relative to this specification, a reduction that preserves
 single{-}owner consistency (\hyperref[t:x28counter_x28x22figurex22_x22figx3asurfacex2downershipx22x29x29]{figure~\FigureRef{29}{t:x28counter_x28x22figurex22_x22figx3asurfacex2downershipx22x29x29}})
 ensures that a value cannot enter a new component without a full type check.

\relax{\begin{definition}[complete monitoring]\label{def:cm}
  A semantics\/ $\xsym$
  satisfies\/ $\propcm{}$
  if for all\/ $\fwellformed{\obars{\sexpr_0}{\sowner_0}}{\stoptional}$
  and all\/ $\sexpr_1$
  such that\/ $\sexpr_0 \rredX \sexpr_1$,
  the contractum is single-owner consistent:\/ $\sowner_0 \sWLsingle \sexpr_1$.
\end{definition}}

\emph{Blame soundness} and \emph{blame completeness} measure the quality of error messages
 relative to a specification of the components that handled a value during an
  evaluation.
A blame{-}sound semantics guarantees a subset of the true senders,
 though it may miss some or even all.
A blame{-}complete semantics guarantees all the true senders,
 though it may include irrelevant information.
A sound and complete semantics reports exactly the components that sent
 the value across a partially{-}checked boundary.

The standard definitions for blame soundness and blame completeness
 rely on the path{-}based ownership propagation laws from chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alawsx22x29}{4.4.4.1}{How to lift a reduction relation}.
Relative to these laws, the definitions relate the sender names in a
 set of boundaries (\hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dmetax22x29x29]{figure~\FigureRef{31}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dmetax22x29x29}}) to the true owners of
 the mismatched value.

\relax{\begin{definition}[path-based blame soundness and blame completeness]\label{def:blame-path}
  For all well-formed\/ $\sexpr_0$
  such that\/ $\sexpr_0 \rredX \boundaryerror{\sbset_0}{\svalue_0}$:
  \begin{itemize}
    \itemsep0.1ex
    \item
      $\xsym$ satisfies $\propbspath$
      iff
      $\fbsetsenders{\sbset_0} \subseteq \fvalueowners{\svalue_0}$
    \item
      $\xsym$ satisfies $\propbcpath$
      iff
      $\fbsetsenders{\sbset_0} \supseteq \fvalueowners{\svalue_0}$.
  \end{itemize}
\end{definition}}

\noindent{}A second useful specification extends the propagation laws to push the owners
 for each location (\relax{$\eloc$}) onto the value heap (\relax{$\vstore$}).
Chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechx3atransientx22x29}{4.5.8}{\relax{\tname} and its Properties} develops this idea to characterize the blame
 guarantees of the \relax{\tname} semantics.

Lastly, the error preorder relation allows direct behavioral comparisons.
If \relax{$\xsym$} and \relax{$\ysym$} represent two strategies for type enforcement,
 then \relax{$\xsym \sbehaviorle \ysym$} states that the \relax{$\ysym$} semantics
 reduces at least as many expressions to a value as the \relax{$\xsym$} semantics.

\relax{\begin{definition}[error preorder]
  $\xsym \sbehaviorle \ysym$
  iff\/ $\sexpr_0 \rredY \eerr_0$
  implies\/ $\sexpr_0 \rredX \eerr_1$\/
  for all well-formed expressions\/ $\sexpr_0$.
\end{definition}}

\noindent{}If two semantics lie below one another on the error preorder, then they report
 type mismatches on exactly the same well{-}formed expressions.

\relax{\begin{definition}[error equivalence]
  $\xsym \sbehavioreq \ysym$
  iff\/ $\xsym \sbehaviorle \ysym$
  and\/ $\ysym \sbehaviorle \xsym$.
\end{definition}}

\Ssubsubsection{Common Higher{-}Order Notions of Reduction}{Common Higher{-}Order Notions of Reduction}\label{t:x28part_x22secx3adesignx3atechx3acommonx2dHOx22x29}

\label{sec:design:tech:common-HO}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{minipage}[t]{0.5\columnwidth}
  \lbl{\fbox{$\sexpr \snredsta \sexpr$}}{
    \begin{rrarray}
      \eunopt{\stype_0}{\svalue_0}
      & \!\!\snredsta\!\!
      & \tagerrorS
      \\\sidecond{if {$\svalue_0 \not\in (\emon{\obnd{\sowner}{(\tpair{\stype}{\stype})}{\sowner}}{\svalue})$}}
      \\\sidecond{and {$\sdelta(\sunop, {\svalue_0})$} is undefined}
      \\[0.5ex]
      \eunopt{\stype_0}{\svalue_0}
      & \!\!\snredsta\!\!
      & \sdelta(\sunop, {\svalue_0})
      \\\sidecond{if {$\sdelta(\sunop, {\svalue_0})$} is defined}
      \\[0.5ex]
      \ebinopt{\stype_0}{\svalue_0}{\svalue_1}
      & \!\!\snredsta\!\!
      & \tagerrorS
      \\\sidecond{if {$\sdelta(\sbinop, {\svalue_0}, {\svalue_1})$} is undefined}
      \\[0.5ex]
      \ebinopt{\stype_0}{\svalue_0}{\svalue_1}
      & \!\!\snredsta\!\!
      & \sdelta(\sbinop, {\svalue_0}, {\svalue_1})
      \\\sidecond{if {$\sdelta(\sbinop, {\svalue_0}, {\svalue_1})$} is defined}
      \\[0.5ex]
      \eapp{\stype_0}{\svalue_0}{\svalue_1}
      & \!\!\snredsta\!\!
      & \tagerrorS
      \\\sidecond{if $\svalue_0 \not\in (\efun{\tann{\svar}{\stype}}{\sexpr}) \cup {}$}
      \\\sidecond{\wideas{~}{\svalue_0 \in\in~} $(\emon{\obnd{\sowner}{(\tfun{\stype}{\stype})}{\sowner}}{\svalue})$}
      \\[0.5ex]
      \eapp{\stype_0}{\svalue_0}{\svalue_1}
      & \!\!\snredsta\!\!
      & \esubst{\sexpr_0}{\svar_0}{\svalue_1}
      \\\sidecond{if $\svalue_0 \eeq (\efun{\tann{\svar_0}{\stype_1}}{\sexpr_0})$}
    \end{rrarray}
  }

\end{minipage}\begin{minipage}[t]{0.5\columnwidth}
  \lbl{\fbox{$\sexpr \snreddyn \sexpr$}}{
    \begin{rrarray}
      \eunopt{\tdyn}{\svalue_0}
      & \!\!\snreddyn\!\!
      & \tagerrorD
      \\\sidecond{if {$\svalue_0 \not\in (\emon{\obnd{\sowner}{(\tpair{\stype}{\stype})}{\sowner}}{\svalue})$}}
      \\\sidecond{and {$\sdelta(\sunop, {\svalue_0})$} is undefined}
      \\[0.5ex]
      \eunopt{\tdyn}{\svalue_0}
      & \!\!\snreddyn\!\!
      & \sdelta(\sunop, {\svalue_0})
      \\\sidecond{if {$\sdelta(\sunop, {\svalue_0})$} is defined}
      \\[0.5ex]
      \ebinopt{\tdyn}{\svalue_0}{\svalue_1}
      & \!\!\snreddyn\!\!
      & \tagerrorD
      \\\sidecond{if {$\sdelta(\sbinop, {\svalue_0}, {\svalue_1})$} is undefined}
      \\[0.5ex]
      \ebinopt{\tdyn}{\svalue_0}{\svalue_1}
      & \!\!\snreddyn\!\!
      & \sdelta(\sbinop, {\svalue_0}, {\svalue_1})
      \\\sidecond{if {$\sdelta(\sbinop, {\svalue_0}, {\svalue_1})$} is defined}
      \\[0.5ex]
      \eapp{\tdyn}{\svalue_0}{\svalue_1}
      & \!\!\snreddyn\!\!
      & \tagerrorD
      \\\sidecond{if $\svalue_0 \not\in (\efun{\svar}{\sexpr}) \cup {}$}
      \\\sidecond{\wideas{~}{\svalue_0 \in\in~} $(\emon{\obnd{\sowner}{(\tfun{\stype}{\stype})}{\sowner}}{\svalue})$}
      \\[0.5ex]
      \eapp{\tdyn}{\svalue_0}{\svalue_1}
      & \!\!\snreddyn\!\!
      & \esubst{\sexpr_0}{\svar_0}{\svalue_1}
      \\\sidecond{if $\svalue_0 \eeq (\efun{\svar_0}{\sexpr_0})$}
    \end{rrarray}
  }
\end{minipage}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3acommonx2dreductionx22x29x29}Figure~35: }{t:x28counter_x28x22figurex22_x22figx3acommonx2dreductionx22x29x29}Common notions of reduction for \relax{\nname}, \relax{\cname}, \relax{\fname}, and \relax{\aname}}}\end{FigureMulti}

Four of the semantics build on the higher{-}order evaluation syntax.
In redexes that do not mix typed and untyped values, these semantics
 share the common behavior specified in \hyperref[t:x28counter_x28x22figurex22_x22figx3acommonx2dreductionx22x29x29]{figure~\FigureRef{35}{t:x28counter_x28x22figurex22_x22figx3acommonx2dreductionx22x29x29}}.
The rules for typed code (\relax{$\snredsta$}) handle basic elimination forms
 and raise an invariant error (\relax{$\tagerrorS$}) for invalid input.
Type soundness ensures that such errors do not occur.
The rules for untyped code (\relax{$\snreddyn$}) raise a tag error for a malformed redex.
Later definitions, for example \hyperref[t:x28counter_x28x22figurex22_x22figx3anaturalx2dreductionx22x29x29]{figure~\FigureRef{36}{t:x28counter_x28x22figurex22_x22figx3anaturalx2dreductionx22x29x29}}, combine
 relations via set union to build one large relation to accomodate all redexes.
The full reduction relation is the reflexive{-}transitive closure of such a set.

\Ssubsubsection{\relax{\nname} and its Properties}{\relax{\nname} and its Properties}\label{t:x28part_x22secx3adesignx3atechx3anaturalx22x29}

\label{sec:design:tech:natural}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{\nname{} Syntax}~extends \hyperref[fig:evaluation-ho]{\syntaxho{}}}{
  \begin{langarray}
    \svalue & \BNFeq &
      \sint \mid
      \snat \mid
      \epair{\svalue}{\svalue} \mid
      \efun{\svar}{\sexpr} \mid
      \efun{\tann{\svar}{\stype}}{\sexpr} \mid
      \emon{\obnd{\sowner}{\tfun{\stype}{\stype}}{\sowner}}{\svalue}
  \end{langarray}
}

%% 2020-09-01 : KNOWN TYPO technically needs error rules for (unop mon), because not handled in common rules,
%%  but based on JFP reviews a "missingrules" mark will confuse more than it helps
\bigskip
\lbl{\fbox{{$\sexpr \nredNS \sexpr$}}}{
  \begin{rrarray}
    \edynb{\obnd{\sowner_0}{\tfun{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0}
    & \!\!\nredNS\!\!\!
    & \emon{\obnd{\sowner_0}{\tfun{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0}
    \\\sidecond{if {$\fshallow{\tagof{\tfun{\stype_0}{\stype_1}}}{\svalue_0}$}}
    \\[0.5ex]
    \edynb{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\epair{\svalue_0}{\svalue_1}}
    & \!\!\nredNS\!\!\!
    & \epair{\edynb{\sbnd_0}{\svalue_0}}{\edynb{\sbnd_1}{\svalue_1}}
    \\\sidecond{if {$\fshallow{\tagof{\tpair{\stype_0}{\stype_1}}}{\epair{\svalue_0}{\svalue_1}}$}}
    \\\sidecond{where {$\sbnd_0 \sassign \obnd{\sowner_0}{\stype_0}{\sowner_1}$}
                and {$\sbnd_1 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$}}
    \\[0.5ex]
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sint_0}
    & \!\!\nredNS\!\!\!
    & \sint_0
    \\\sidecond{if {$\fshallow{\tagof{\stype_0}}{\sint_0}$}}
    \\[0.5ex]
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \!\!\nredNS\!\!\!
    & \boundaryerror{\eset{\obnd{\sowner_0}{\stype_0}{\sowner_1}}}{\svalue_0}
    \\\sidecond{if {$\neg \fshallow{\tagof{\stype_0}}{\svalue_0}$}}
    \\[1.0ex]
    \eapp{\stype_0}{(\emon{\obnd{\sowner_0}{\tfun{\stype_1}{\stype_2}}{\sowner_1}}{\svalue_0})}{\svalue_1}
    & \!\!\nredNS\!\!\!
    & \edynb{\sbnd_0}{(\eapp{\tdyn}{\svalue_0}{(\estab{\sbnd_1}{\svalue_1})})}
    \\\sidecond{where {$\sbnd_0 \sassign \obnd{\sowner_0}{\stype_2}{\sowner_1}$}
                and {$\sbnd_1 \sassign \obnd{\sowner_1}{\stype_1}{\sowner_0}$}}
  \end{rrarray}
}

\bigskip
\lbl{\fbox{{$\sexpr \nredND \sexpr$}}}{
  \begin{rrarray}
    \estab{\obnd{\sowner_0}{\tfun{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0}
    & \!\!\nredND\!\!\!
    & \emon{\obnd{\sowner_0}{\tfun{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0}
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\svalue_0}$}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\epair{\svalue_0}{\svalue_1}}
    & \!\!\nredND\!\!\!
    & \epair{\estab{\sbnd_0}{\svalue_0}}{\estab{\sbnd_1}{\svalue_1}}
    \\\sidecond{if {$\fshallow{\tagof{\tpair{\stype_0}{\stype_1}}}{\epair{\svalue_0}{\svalue_1}}$}}
    \\\sidecond{where {$\sbnd_0 \sassign \obnd{\sowner_0}{\stype_0}{\sowner_1}$}
                and {$\sbnd_1 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$}}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sint_0}
    &  \!\!\nredND\!\!\!
    &  \sint_0
    \\\sidecond{if \(\fshallow{\ftagof{\stype_0}}{\sint_0}\)}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    &  \!\!\nredND\!\!\!
    &  \tagerrorS
    \\\sidecond{if \(\neg \fshallow{\ftagof{\stype_0}}{\svalue_0}\)}
    \\[1.0ex]
    \eapp{\tdyn}{(\emon{\obnd{\sowner_0}{\tfun{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0})}{\svalue_1}
    & \!\!\nredND\!\!\!
    & \estab{\sbnd_0}{(\eapp{\stype_1}{\svalue_0}{(\edynb{\sbnd_1}{\svalue_1})})}
    \\\sidecond{where {$\sbnd_0 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$}
                and {$\sbnd_1 \sassign \obnd{\sowner_1}{\stype_0}{\sowner_0}$}}
  \end{rrarray}
}

\bigskip
\lbl{\fbox{$\sexpr \rredN \sexpr$} ${}={} \rtclosure{\nredNS, \nredND, \snreddyn, \snredsta}$}{}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3anaturalx2dreductionx22x29x29}Figure~36: }{t:x28counter_x28x22figurex22_x22figx3anaturalx2dreductionx22x29x29}\relax{\nname} notions of reduction}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3anaturalx2dreductionx22x29x29]{Figure~\FigureRef{36}{t:x28counter_x28x22figurex22_x22figx3anaturalx2dreductionx22x29x29}} presents the values and key reduction rules
 for the \relax{\nname} semantics.
Conventional reductions handle primitives and unwrapped functions
  (\relax{$\snreddyn$} and \relax{$\snredsta$}, \hyperref[t:x28counter_x28x22figurex22_x22figx3acommonx2dreductionx22x29x29]{figure~\FigureRef{35}{t:x28counter_x28x22figurex22_x22figx3acommonx2dreductionx22x29x29}}).

A successful \relax{\nname} reduction yields either an unwrapped value or
 a guard{-}wrapped function.
Guards arise when a function value reaches a function{-}type boundary.
Thus, the possible wrapped values are drawn from the following two sets:

\relax{\smallskip
\begin{flushleft}
\(\begin{array}[t]{lcl}
  \svaluestat & \BNFeq & \emon{\obnd{\sowner}{(\tfun{\stype}{\stype})}{\sowner}}{(\efun{\svar}{\sexpr})} \\
  & \mid & \emon{\obnd{\sowner}{(\tfun{\stype}{\stype})}{\sowner}}{\svaluedyn}
\end{array}\)

\smallskip
\(\begin{array}[t]{lcl}
  \svaluedyn & \BNFeq & \emon{\obnd{\sowner}{(\tfun{\stype}{\stype})}{\sowner}}{(\efun{\tann{\svar}{\stype}}{\sexpr})} \\
  & \mid & \emon{\obnd{\sowner}{(\tfun{\stype}{\stype})}{\sowner}}{\wideas{\svaluestat}{\svaluedyn}}
\end{array}\)
\end{flushleft}
\smallskip}

The presented reduction rules are those relevant to the \relax{\nname} strategy for
 enforcing static types.
When a dynamically{-}typed value reaches a typed context (\relax{$\sdyn$}),
 \relax{\nname} checks the shape of the value against the type.
If the type and value match, \relax{\nname} wraps functions
 and recursively checks the elements of a pair.
Otherwise, \relax{\nname} raises an error at the current boundary.
When a wrapped function receives an argument, \relax{\nname}
 creates two new boundaries:
 one to protect the input to the inner, untyped function
 and one to validate the result.

Reduction in dynamically{-}typed code (\relax{$\nredND$}) follows a dual strategy.
The rules for \relax{$\ssta$} boundaries wrap functions and recursively protect
 the contents of pairs.
The application of a wrapped function creates boundaries to validate
 the input to a typed function and to protect the result.

Unsurprisingly, this checking protocol ensures the validity of types in typed
 code and the well{-}formedness of expressions in untyped code.
The \relax{\nname} approach furthemore enforces boundary types throughout the execution.

\relax{\begin{theorem}
  \nname{} satisfies $\propts{\sidproj}$.
\end{theorem}
\begin{proofsketch}
  By progress and preservation lemmas for the higher-order typing judgment ($\sWTfull$).
  For example, if an untyped pair reaches a boundary then a typed step
   ($\nredNS$) makes progress to either a new pair or an error.
  In the former case, the new pair contains two boundary expressions:

  \begin{displayrrarray}
    \edynb{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\epair{\svalue_0}{\svalue_1}}
    & \nredNS
    \\\sidestep{\epair{\edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}}{\edynb{\obnd{\sowner_0}{\stype_1}{\sowner_1}}{\svalue_1}}}
  \end{displayrrarray}

  \noindent{}The typing rules for pairs and for $\sdyn$ boundaries validate
   the type of the result.
\end{proofsketch}}

\relax{\begin{theorem}
  \nname{} satisfies $\propcm{}$.
\end{theorem}
\begin{proofsketch}
  By showing that a lifted variant of the $\rredN$ relation preserves
   single-owner consistency ($\sWLsingle$).
  Full lifted rules for \nname{} appear in an appendix,
   but one can derive the rules by applying the guidelines from \sectionref{sec:design:laws}.
  For example, consider the $\nredND$ rule that wraps a function.
  The lifted version accepts a term with arbitrary ownership labels
   and propagates these labels to the result:

  \begin{displayrrarray}
    \obars{\estab{\obnd{\sowner_0}{(\tfun{\stype_0}{\stype_1})}{\sowner_1}}{\obbars{\svalue_0}{\sownerlist_2}}}{\sowner_3}
    & \nredNDanns & \hspace{3cm}~
    \\\sidestep{\obars{\emon{\obnd{\sowner_0}{(\tfun{\stype_0}{\stype_1})}{\sowner_1}}{\obbars{\svalue_0}{\sownerlist_2}}}{\sowner_3}}
    \\\sidecond{if $\fshallow{\ftagof{\tfun{\stype_0}{\stype_1}}}{\svalue_0}$}
  \end{displayrrarray}

  \noindent{}If the redex satisfies single-owner consistency, then the context label
   matches the client name ($\sowner_3 = \sowner_0$) and the labels inside
   the boundary match the sender name ($\sownerlist_2 = \fconcat{\sowner_1}{\fconcat{\cdots}{\sowner_1}}$).
   Under these premises, the result also satisfies single-owner consistency.
\end{proofsketch}}

Complete monitoring implies that the \relax{\nname} semantics detects every mismatch
 between two components{---}either immediately, or as soon as a function
 computes an incorrect result.
Consequently, every mismatch is due to a single boundary.
Blame soundness and completeness ask whether \relax{\nname} identifies the culprit.

\relax{\begin{lemma}\label{lemma:natural-blame}
  If\/ $\sexpr_0$ is well-formed
  and\/ $\sexpr_0 \rredN\!\boundaryerror{\sbset_0}{\svalue_0}$,
  then\/ $\fbsetsenders{\sbset_0}\!=\!\fvalueowners{\svalue_0}$
  and furthermore\/ $\sbset_0$ contains exactly one boundary specification.
\end{lemma}
\begin{proof}
  The sole \nname{} rule that detects a mismatch blames a single boundary:

  \begin{displayrrarray}
    \obars{\sexpr_0}{\sowner_0}
    & \rredN &
    \ctx[\edynb{\obnd{\sowner_1}{\stype_0}{\sowner_2}}{\svalue_0}]
    \\[0.5ex]
    & \rredN &
    \boundaryerror{\eset{\obnd{\sowner_1}{\stype_0}{\sowner_2}}}{\svalue_0}
  \end{displayrrarray}

  \noindent{}Thus $\sbset_0 = \eset{\obnd{\sowner_1}{\stype_0}{\sowner_2}}$ and $\fbsetsenders{\sbset_0} \feq \eset{\sowner_2}$.
  This boundary is the correct one to blame only if it matches the true owner
   of the value; that is, $\fvalueowners{\svalue_0} \feq \eset{\sowner_2}$.
  Complete monitoring guarantees a match via $\sowner_0 \sWLsingle \ctx[\edynb{\obnd{\sowner_1}{\stype_0}{\sowner_2}}{\svalue_0}]$.
\end{proof}}

\relax{\begin{corollary}
  \nname{} satisfies $\propbspath$\/ and $\propbcpath$.
\end{corollary}}

\Ssubsubsection{\relax{\cname} and its Properties}{\relax{\cname} and its Properties}\label{t:x28part_x22secx3adesignx3atechx3aconaturalx22x29}

\label{sec:design:tech:conatural}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{\cname{} Syntax}~extends \hyperref[fig:evaluation-ho]{\syntaxho{}}}{
  \begin{langarray}
    \svalue & \BNFeq &
      \sint \mid
      \snat \mid
      \epair{\svalue}{\svalue} \mid
      \efun{\svar}{\sexpr} \mid
      \efun{\tann{\svar}{\stype}}{\sexpr} \mid
    \\ & &
      \emon{\obnd{\sowner}{\tfun{\stype}{\stype}}{\sowner}}{\svalue} \mid
      \emon{\obnd{\sowner}{\tpair{\stype}{\stype}}{\sowner}}{\svalue}
  \end{langarray}
}

\bigskip
\lbl{\fbox{{$\sexpr \nredCS \sexpr$}}}{
  \begin{rrarray}
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \!\!\nredCS\!\!
    & \emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    \\\sidecond{if {$\fshallow{\tagof{\stype_0}}{\svalue_0}$}
                and {$\svalue_0 \in \epair{\svalue}{\svalue} \cup (\efun{\svar}{\sexpr}) \cup (\emon{\sbnd}{\svalue})$}}
    \\[0.5ex]
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sint_0}
    & \!\!\nredCS\!\!
    & \sint_0
    \\\sidecond{if {$\fshallow{\tagof{\stype_0}}{\sint_0}$}}
    \\[0.5ex]
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \!\!\nredCS\!\!
    & \boundaryerror{\eset{\obnd{\sowner_0}{\stype_0}{\sowner_1}}}{\svalue_0}
    \\\sidecond{if {$\neg \fshallow{\tagof{\stype_0}}{\svalue_0}$}}
    \\[1.0ex]
    \efst{\stype_0}{(\emon{\obnd{\sowner_0}{\tpair{\stype_1}{\stype_2}}{\sowner_1}}{\svalue_0})}
    & \!\!\nredCS\!\!
    & \edynb{\sbnd_0}{(\efst{\tdyn}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$}
    \\[0.5ex]
    \esnd{\stype_0}{(\emon{\obnd{\sowner_0}{\tpair{\stype_1}{\stype_2}}{\sowner_1}}{\svalue_0})}
    & \!\!\nredCS\!\!
    & \edynb{\sbnd_0}{(\esnd{\tdyn}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_2}{\sowner_1}$}
    \\[0.5ex]
    \eapp{\stype_0}{(\emon{\obnd{\sowner_0}{\tfun{\stype_1}{\stype_2}}{\sowner_1}}{\svalue_0})}{\svalue_1}
    & \!\!\nredCS\!\!
    & \edynb{\sbnd_0}{(\eapp{\tdyn}{\svalue_0}{(\estab{\sbnd_1}{\svalue_1})})}
    \\\sidecond{where {$\sbnd_0 \sassign \obnd{\sowner_0}{\stype_2}{\sowner_1}$}
                and {$\sbnd_1 \sassign \obnd{\sowner_1}{\stype_1}{\sowner_0}$}}
  \end{rrarray}
}

\bigskip
\lbl{\fbox{{$\sexpr \nredCD \sexpr$}}}{
  \begin{rrarray}
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \!\!\nredCD\!\!
    & \emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    \\\sidecond{if $\fshallow{\ftagof{\stype_0}}{\svalue_0}$
                and {$\svalue_0 \in \epair{\svalue}{\svalue} \cup {(\efun{\tann{\svar}{\stype}}{\sexpr})} \cup {(\emon{\sbnd}{\svalue})}$}}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sint_0}
    &  \!\!\nredCD\!\!
    &  \sint_0
    \\\sidecond{if \(\fshallow{\ftagof{\stype_0}}{\sint_0}\)}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    &  \!\!\nredCD\!\!
    &  \tagerrorS
    \\\sidecond{if \(\neg \fshallow{\ftagof{\stype_0}}{\svalue_0}\)}
    \\[1.0ex]
    \efst{\tdyn}{(\emon{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0})}
    & \!\!\nredCD\!\!
    & \estab{\sbnd_0}{(\efst{\stype_0}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_0}{\sowner_1}$}
    \\[0.5ex]
    \esnd{\tdyn}{(\emon{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0})}
    & \!\!\nredCD\!\!
    & \estab{\sbnd_0}{(\esnd{\stype_1}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$}
    \\[0.5ex]
    \eapp{\tdyn}{(\emon{\obnd{\sowner_0}{\tfun{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0})}{\svalue_1}
    & \!\!\nredCD\!\!
    & \estab{\sbnd_0}{(\eapp{\stype_1}{\svalue_0}{(\edynb{\sbnd_1}{\svalue_1})})}
    \\\sidecond{where {$\sbnd_0 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$}
                and {$\sbnd_1 \sassign \obnd{\sowner_1}{\stype_0}{\sowner_0}$}}
  \end{rrarray}
}

\bigskip
\lbl{\fbox{$\sexpr \rredC \sexpr$} ${}={} \rtclosure{\nredCS, \nredCD, \snreddyn, \snredsta}$}{}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aconaturalx2dreductionx22x29x29}Figure~37: }{t:x28counter_x28x22figurex22_x22figx3aconaturalx2dreductionx22x29x29}\relax{\cname} notions of reduction}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3aconaturalx2dreductionx22x29x29]{Figure~\FigureRef{37}{t:x28counter_x28x22figurex22_x22figx3aconaturalx2dreductionx22x29x29}} presents the \relax{\cname} strategy.
\relax{\cname} is a lazy variant of the \relax{\nname} approach.
Instead of eagerly validating pairs at a boundary, \relax{\cname} creates a wrapper
 to delay element{-}checks until they are needed.

Relative to \relax{\nname}, there are two changes in the notions of reduction.
First, the rules for a pair value at a pair{-}type boundary create guards.
Second, new projection rules handle guarded pairs;
 these rules make a new boundary to validate the projected element.

\relax{\cname} still satisfies both a strong type soundness theorem and complete
 monitoring.
Blame soundness and blame completeness follow from complete monitoring.
Nevertheless, \relax{\cname} and \relax{\nname} can behave differently.

\relax{\begin{theorem}
  \cname{} satisfies $\propts{\sidproj}$.
\end{theorem}
\begin{proofsketch}
  By progress and preservation lemmas for the higher-order typing judgment ($\sWTfull$).
  For example, consider the rule that applies a wrapped function in a statically-typed context:

  \begin{displayrrarray}
    \eapp{\stype_0}{(\emon{\obnd{\sowner_0}{(\tfun{\stype_1}{\stype_2})}{\sowner_1}}{\svalue_0})}{\svalue_1}
    & \nredCS
    \\[0.5ex]\sidestep{\edynb{\obnd{\sowner_0}{\stype_2}{\sowner_1}}{(\eapp{\tdyn}{\svalue_0}{(\estab{\obnd{\sowner_1}{\stype_1}{\sowner_2}}{\svalue_1})})}}
  \end{displayrrarray}

  \noindent{}If the redex is well-typed, then $\svalue_1$ has type $\stype_1$
   and the inner $\sstat$ boundary is well-typed.
  Similar reasoning for $\svalue_0$ shows that the untyped application in the
   result is well-typed.
  Thus the $\sdyn$ boundary has type $\stype_2$ which, by inversion on
   the redex, is a subtype of $\stype_0$.
\end{proofsketch}}

\relax{\begin{theorem}
  \cname{} satisfies $\propcm{}$.
\end{theorem}
\begin{proofsketch}
  $\!\!\!$ By preservation of single-owner consistency for the lifted
   $\rredC$ relation.
  Consider the lifted rule that applies a wrapped function:

  \begin{displayrrarray}
    \obars{\eapp{\stype_0}{\obbars{\emon{\obnd{\sowner_0}{(\tfun{\stype_1}{\stype_2})}{\sowner_1}}{\obars{\svalue_0}{\sowner_2}}}{\sownerlist_3}}{\svalue_1}}{\sowner_4}
    & \nredCSanns
    \\[0.5ex]
    \sidestep{\obars{\edynb{\obnd{\sowner_0}{\stype_2}{\sowner_1}}{\obars{\eapp{\tdyn}{\svalue_0}{(\estab{\obnd{\sowner_1}{\stype_1}{\sowner_0}}{\obars{\svalue_1}{\fconcat{\sowner_4}{\frev{\sownerlist_3}}}})}}{\sowner_2}}}{\fconcat{\sownerlist_3}{\sowner_4}}}
  \end{displayrrarray}

  \noindent{}If the redex satisfies single-owner consistency, then $\sowner_0 = \sownerlist_3 = \sowner_4$
  and $\sowner_1 = \sowner_2$.
  Hence both sequences of labels in the result contain nothing but the context label $\sowner_4$.
\end{proofsketch}}

\relax{\begin{theorem}
  \cname{} satisfies $\propbspath$\/ and $\propbcpath$.
\end{theorem}
\begin{proofsketch}
  By the same line of reasoning that supports \nname{}; refer to \lemmaref{lemma:natural-blame}.
\end{proofsketch}}

\relax{\begin{theorem}
  $\nsym{} \sbehaviorle \csym{}$.
\end{theorem}
\begin{proofsketch}
  By a stuttering simulation.
  \nname{} takes extra steps when a pair reaches a boundary because it
   immediately checks the contents; \cname{} creates a guard wrapper.
  \cname{} takes additional steps when eliminating a wrapped pair.
  The appendix defines the simulation relation.

  The pair wrappers in \cname{} imply $\csym{} \not\sbehaviorle \nsym{}$.
  Consider a typed expression that imports an untyped pair
   with an ill-typed first element.

  \begin{displayrrarray}
    \edynb{\obnd{\sowner_0}{\tpair{\tnat}{\tnat}}{\sowner_1}}{\epair{{-2}}{2}}
  \end{displayrrarray}

  \noindent{}\nname{} detects the mismatch at the boundary, but \cname{} will only
    raise an error if the first element is accessed.
\end{proofsketch}}

\Ssubsubsection{\relax{\fname} and its Properties}{\relax{\fname} and its Properties}\label{t:x28part_x22secx3adesignx3atechx3aforgetfulx22x29}

\label{sec:design:tech:forgetful}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{\fname{} Syntax}~extends \hyperref[fig:evaluation-ho]{\syntaxho{}}}{
  \begin{langarray}
    \svalue & \BNFeq &
      \sint \mid
      \snat \mid
      \epair{\svalue}{\svalue} \mid
      \efun{\svar}{\sexpr} \mid
      \efun{\tann{\svar}{\stype}}{\sexpr} \mid
    \\ & &
      \emon{\obnd{\sowner}{\tfun{\stype}{\stype}}{\sowner}}{\svalue} \mid
      \emon{\obnd{\sowner}{\tpair{\stype}{\stype}}{\sowner}}{\svalue}
  \end{langarray}
}

\bigskip
\lbl{\fbox{$\sexpr \nredFS \sexpr$}}{
  \begin{rrarray}
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \!\!\nredFS\!\!
    & \emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\svalue_0}$
                and $\svalue_0 \in {\epair{\svalue}{\svalue}} \cup
                                   (\efun{\svar}{\sexpr}) \cup
                                   (\emon{\sbnd}{\svalue})$}
    \\[0.5ex]
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \!\!\nredFS\!\!
    & \sint_0
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\svalue_0}$}
    \\[0.5ex]
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \!\!\nredFS\!\!
    & \boundaryerror{\eset{\obnd{\sowner_0}{\stype_0}{\sowner_1}}}{\svalue_0}
    \\\sidecond{if $\neg\fshallow{\tagof{\stype_0}}{\svalue_0}$}
    \\[1.0ex]
    \efst{\stype_0}{(\emon{\obnd{\sowner_0}{\tpair{\stype_1}{\stype_2}}{\sowner_1}}{\svalue_0})}
    & \!\!\nredFS\!\!
    & \edynb{\sbnd_0}{(\efst{\tdyn}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$}
    \\[0.5ex]
    \esnd{\stype_0}{(\emon{\obnd{\sowner_0}{\tpair{\stype_1}{\stype_2}}{\sowner_1}}{\svalue_0})}
    & \!\!\nredFS\!\!
    & \edynb{\sbnd_0}{(\esnd{\tdyn}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_2}{\sowner_1}$}
    \\[0.5ex]
    \eapp{\stype_0}{(\emon{\obnd{\sowner_0}{\tpair{\stype_1}{\stype_2}}{\sowner_1}}{\svalue_0})}{\svalue_1}
    & \!\!\nredFS\!\!
    & \edynb{\sbnd_0}{(\eapp{\tdyn}{\svalue_0}{(\estab{\sbnd_1}{\svalue_1})})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_2}{\sowner_1}$
                and $\sbnd_1 \sassign \obnd{\sowner_1}{\stype_1}{\sowner_0}$}
  \end{rrarray}
}

\bigskip
\lbl{\fbox{$\sexpr \nredFD \sexpr$}}{
  \begin{rrarray}
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \!\!\nredFD\!\!
    & \emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\svalue_0}$
                and $\svalue_0 \in {\epair{\svalue}{\svalue}} \cup {(\efun{\tann{\svar}{{\stype}}}{\sexpr})}$}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{(\emon{\sbnd_1}{\svalue_0})}
    & \!\!\nredFD\!\!
    & \svalue_0
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\svalue_0}$}
    \\\sidecond{and $\svalue_0 \in {\epair{\svalue}{\svalue}} \cup
                                   (\efun{\svar}{\sexpr}) \cup
                                   (\emon{\sbnd}{\epair{\svalue}{\svalue}}) \cup
                                   (\emon{\sbnd}{(\efun{\tann{\svar}{\stype}}{\sexpr})})$}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sint_0}
    & \!\!\nredFD\!\!
    & \sint_0
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\sint_0}$}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \!\!\nredFD\!\!
    & \tagerrorS
    \\\sidecond{if $\neg\fshallow{\tagof{\stype_0}}{\svalue_0}$}
    \\[1.0ex]
    \efst{\tdyn}{(\emon{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0})}
    & \!\!\nredFD\!\!
    & \estab{\sbnd_0}{(\efst{\stype_0}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_0}{\sowner_1}$}
    \\[0.5ex]
    \esnd{\tdyn}{(\emon{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0})}
    & \!\!\nredFD\!\!
    & \estab{\sbnd_0}{(\esnd{\stype_1}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$}
    \\[0.5ex]
    \eapp{\tdyn}{(\emon{\obnd{\sowner_0}{\tfun{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0})}{\svalue_1}
    & \!\!\nredFD\!\!
    & \estab{\sbnd_0}{(\eapp{\stype_1}{\svalue_0}{(\edynb{\sbnd_1}{\svalue_1})})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$
                and $\sbnd_1 \sassign \obnd{\sowner_1}{\stype_0}{\sowner_0}$}
  \end{rrarray}
}

\bigskip
\lbl{\fbox{$\sexpr \rredF \sexpr$} ${}={} \rtclosure{\nredFS, \nredFD, \snreddyn, \snredsta}$}{}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aforgetfulx2dreductionx22x29x29}Figure~38: }{t:x28counter_x28x22figurex22_x22figx3aforgetfulx2dreductionx22x29x29}\relax{\fname} notions of reduction}}\end{FigureMulti}

The \relax{\fname} semantics (\hyperref[t:x28counter_x28x22figurex22_x22figx3aforgetfulx2dreductionx22x29x29]{figure~\FigureRef{38}{t:x28counter_x28x22figurex22_x22figx3aforgetfulx2dreductionx22x29x29}})
 creates wrappers to enforce pair and function types,
 but strictly limits the number of wrappers on any one value.
An untyped value acquires at most one wrapper.
A typed value acquires at most two wrappers: one to protect itself from
 inputs, and a second to reflect the expectations of its current client:

\relax{\smallskip
\(\hfill
  \begin{array}[t]{lcl}
    \svaluestat
     & \BNFeq & \emon{\sbnd}{\epair{\svalue}{\svalue}} \\
     & \mid   & \emon{\sbnd}{\efun{\svar}{\sexpr}} \\
     & \mid   & \emon{\sbnd}{(\emon{\sbnd}{\epair{\svalue}{\svalue}})} \\
     & \mid   & \zerowidth{\emon{\sbnd}{(\emon{\sbnd}{\efun{\tann{\svar}{\stype}}{\sexpr}})}}
  \end{array}
  \hfill
  \begin{array}[t]{lcl}
    \svaluedyn
    & \BNFeq & \emon{\sbnd}{\epair{\svalue}{\svalue}} \\
    & \mid & \emon{\sbnd}{\efun{\tann{\svar}{\stype}}{\sexpr}}
  \end{array}
\hfill\)
\smallskip}

\relax{\fname} enforces this two{-}wrapper limit by removing the outer wrapper of
 any guarded value that exits typed code.
Re{-}entering typed code makes a new wrapper,
 but these wrappers do not
 accumulate because a value cannot enter typed code twice in a row; it
 must first exit typed code and lose one wrapper.

Removing outer wrappers does not affect the type soundness of untyped code;
 all well{-}formed values match \relax{$\tdyn$}, with or without wrappers.
Type soundness for typed code is guaranteed by the temporary outer wrappers.
Complete monitoring is lost, however, because the removal of a wrapper
 creates a joint{-}ownership situation.
Similarly, \relax{\fname} lies above \relax{\cname} and \relax{\nname} in the error preorder.

When a type mismatch occurs, \relax{\fname} blames one boundary.
Though sound, this one boundary is generally not enough information to
 find the source of the problem.
So, \relax{\fname} fails to satisfy blame completeness.

\relax{\begin{theorem}\label{thm:F-TS}
  \fname{} satisfies $\propts{\sidproj}$.
\end{theorem}
\begin{proofsketch}
  By progress and preservation lemmas for the higher-order typing judgment ($\sWTfull$).
  The most interesting proof case shows that dropping a guard wrapper does not
   break type soundness.
  Suppose that a pair $\svalue_0$ with static type $\tpair{\tint}{\tint}$ crosses
   two boundaries and re-enters typed code at a different type.

  \begin{displayrrarray}
    \edynb{\obnd{\sowner_0}{(\tpair{\tnat}{\tnat})}{\sowner_1}}{(\estab{\obnd{\sowner_1}{\tpair{\tint}{\tint}}{\sowner_2}}{\svalue_0})}
    & \rredF
    \\[0.5ex]\sidestep{\emon{\obnd{\sowner_0}{(\tpair{\tnat}{\tnat})}{\sowner_1}}{(\emon{\obnd{\sowner_1}{\tpair{\tint}{\tint}}{\sowner_2}}{\svalue_0})}}
  \end{displayrrarray}

  \noindent{}No matter what value $\svalue_0$ is, the result is well-typed because
   the context trusts the outer wrapper.
  If this double-wrapped value---call it $\svalue_2$---crosses another boundary,
   \fname{} drops the outer wrapper.
  Nevertheless, the result is a sound dynamically-typed value:

  \begin{displayrrarray}
    \estab{\obnd{\sowner_3}{(\tpair{\tnat}{\tnat})}{\sowner_0}}{\svalue_2}
    & \rredF
    \\[0.5ex]\sidestep{\emon{\obnd{\sowner_1}{\tpair{\tint}{\tint}}{\sowner_2}}{\svalue_0}}
  \end{displayrrarray}

  When this single-wrapped wrapped pair reenters a typed context,
   it again gains a wrapper to document the context's expectation:

  \begin{displayrrarray}
    \edynb{\obnd{\sowner_4}{(\tpair{\stype_1}{\stype_2})}{\sowner_3}}{(\emon{\obnd{\sowner_1}{\tpair{\tint}{\tint}}{\sowner_2}}{\svalue_0})}
    & \rredF
    \\[0.5ex]\sidestep{\emon{\obnd{\sowner_4}{(\tpair{\stype_1}{\stype_2})}{\sowner_3}}{(\emon{\obnd{\sowner_1}{\tpair{\tint}{\tint}}{\sowner_2}}{\svalue_0})}}
  \end{displayrrarray}

  \noindent{}The new wrapper preserves soundness.
\end{proofsketch}}

\relax{\begin{theorem}\label{thm:F-CM}
  \fname{} does not satisfy $\propcm{}$.
\end{theorem}
\begin{proof}
  Consider the lifted variant of the $\ssta$ rule that removes an outer guard wrapper:

  \begin{displayrrarray}
    \obars{\estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\obbars{\emon{\sbnd_1}{\svalue_0}}{\sownerlist_2}}}{\sowner_3}
    & \nredFDanns &
    \obbars{\svalue_0}{\fconcat{\sownerlist_2}{\sowner_3}}
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{(\emon{\sbnd_1}{\svalue_0})}$}
  \end{displayrrarray}

  \noindent{}Suppose $\sowner_0 \neq \sowner_1$.
  If the redex satisfies single-owner consistency, then $\sownerlist_2$ contains
   $\sowner_1$ and $\sowner_3 = \sowner_0$.
  Thus the rule creates a contractum with two distinct labels.
\end{proof}}

\relax{\begin{theorem}
  \fname{} satisfies\/ $\propbspath$.
\end{theorem}
\begin{proof}
  By a preservation lemma for a weakened version of the $\sWLsingle$ judgment,
   which is defined in the appendix.
  The judgment asks whether the owners on a value contain at least the name
   of the current component.
  \fname{} easily satisfies this invariant because the ownership
   guidelines (\sectionref{sec:design:laws}) never drop an un-checked label.
  Thus, when a boundary error occurs:

  \begin{displayrrarray}
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \nredFS
    & \boundaryerror{\eset{\obnd{\sowner_0}{\stype_0}{\sowner_1}}}{\svalue_0}
    \\\sidecond{if $\neg\fshallow{\tagof{\stype_0}}{\svalue_0}$}
  \end{displayrrarray}

  \noindent{}the sender name $\sowner_1$ matches one of the ownership labels on $\svalue_0$.
\end{proof}}

\relax{\begin{theorem}
  \fname{} does not satisfy\/ $\propbcpath$.
\end{theorem}
\begin{proof}
  The proof of \theoremref{thm:F-CM} shows how a pair value can acquire two labels.
  A function can gain owners in a similar fashion, and reach an incompatible boundary:

  {\newcommand{\theexvalue}{\obbars{\efun{\svar_0}{\svar_0}}{\fconcat{\sowner_0}{\sowner_1}}}
  \begin{displayrrarray}
    \edynb{\obnd{\sowner_2}{\tint}{\sowner_1}}{\theexvalue}
    & \nredFSanns
    \\\sidestep{\boundaryerror{\eset{\obnd{\sowner_2}{\tint}{\sowner_1}}}{\theexvalue}}
  \end{displayrrarray}}

  \noindent{}In this example, the error does not point to component $\sowner_0$.
\end{proof}}

\relax{\begin{theorem}
  $\csym{} \sbehaviorle \fsym{}$.
\end{theorem}
\begin{proofsketch}
  By a stuttering simulation.
  \cname{} can take extra steps at an elimination form to unwrap an arbitrary
   number of wrappers; \fname{} has at most two to unwrap.

  In the other direction, $\fsym{} \not\sbehaviorle \csym{}$ because \fname{} drops checks.
  Let:

  \begin{displayrrarray}
    \sexpr_0 = \estab{\sbnd_0}{(\edynb{\obnd{\sowner_0}{(\tfun{\tnat}{\tnat})}{\sowner_1}}{(\efun{\svar_0}{\svar_0})})}
    \\[0.5ex]
    \sexpr_1 = \eapp{\tdyn}{\sexpr_0}{\epair{2}{8}}
  \end{displayrrarray}

  \noindent{}Then $\sexpr_1 \rredF {\epair{2}{8}}$ and \cname{} raises a boundary error.
\end{proofsketch}}

\Ssubsubsection{\relax{\tname} and its Properties}{\relax{\tname} and its Properties}\label{t:x28part_x22secx3adesignx3atechx3atransientx22x29}

\label{sec:design:tech:transient}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{\tname{} Syntax}~extends \hyperref[fig:evaluation-fo]{\syntaxfo}}{
  \begin{langarray}
    \svalue & \BNFeq &
      \sint \mid \snat \mid \eloc
  \end{langarray}
}

\bigskip
\lbl{\fbox{$\conf{\sexpr}{\vstore}{\bstore} \nredTX \conf{\sexpr}{\vstore}{\bstore}$}~\missingrules{}}{
  \begin{rrarray}
    \conf{(\edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0})}{\vstore_0}{\bstore_0}
    & \nredTX
    & \conf{\svalue_0}{\vstore_0}{(\fmapupdate{\bstore_0}{\svalue_0}{\eset{\obnd{\sowner_0}{\stype_0}{\sowner_1}}})}
    \\\sidecond{if $\fshallow{\ftagof{\stype_0}}{\fmapref{\vstore_0}{\svalue_0}}$}
    \\[0.5ex]
    \conf{(\edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0})}{\vstore_0}{\bstore_0}
    & \nredTX
    & \conf{\boundaryerror{\eset{\obnd{\sowner_0}{\stype_0}{\sowner_1}}}{\svalue_0}}{\vstore_0}{\bstore_0}
    \\\sidecond{if $\neg\fshallow{\ftagof{\stype_0}}{\fmapref{\vstore_0}{\svalue_0}}$}
    \\[0.5ex]
    \conf{(\estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0})}{\vstore_0}{\bstore_0}
    & \nredTX
    & \conf{\svalue_0}{\vstore_0}{(\fmapupdate{\bstore_0}{\svalue_0}{\eset{\obnd{\sowner_0}{\stype_0}{\sowner_1}}})}
    \\\sidecond{if $\fshallow{\ftagof{\stype_0}}{\fmapref{\vstore_0}{\svalue_0}}$}
    \\[0.5ex]
    \conf{(\estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0})}{\vstore_0}{\bstore_0}
    & \nredTX
    & \conf{\tagerrorS}{\vstore_0}{\bstore_0}
    \\\sidecond{if $\neg\fshallow{\ftagof{\stype_0}}{\fmapref{\vstore_0}{\svalue_0}}$}
    \\[0.5ex]
    \conf{(\echecktwo{\tdyn}{\svalue_0}{\eloc_0})}{\vstore_0}{\bstore_0}
    & \nredTX
    & \conf{\svalue_0}{\vstore_0}{\bstore_0}
    \\[0.5ex]
    \conf{(\echecktwo{\stype_0}{\svalue_0}{\eloc_0})}{\vstore_0}{\bstore_0}
    &  \nredTX
    & \conf{\svalue_0}{\vstore_0}{(\fmapupdate{\bstore_0}{\svalue_0}{\fmapref{\bstore_0}{\eloc_0}})}
    \\\sidecond{if \(\fshallow{\ftagof{\stype_0}}{\fmapref{\vstore_0}{\svalue_0}}\)}
    \\[0.5ex]
    \conf{(\echecktwo{\stype_0}{\svalue_0}{\eloc_0})}{\vstore_0}{\bstore_0}
    & \nredTX
    \\\sidestep{ \conf{\boundaryerror{\bappend{\fmapref{\bstore_0}{\svalue_0}}{\fmapref{\bstore_0}{\eloc_0}}}{\svalue_0}}{\vstore_0}{\bstore_0} }
    \\\sidecond{if \(\neg \fshallow{\ftagof{\stype_0}}{\fmapref{\vstore_0}{\svalue_0}}\)}
    \\[1.0ex]

    \conf{(\eunopt{\stoptional}{\eloc_0})}{\vstore_0}{\bstore_0}
    &  \nredTX
    \\\sidestep{ \conf{(\echecktwo{\stoptional}{\sdelta(\sunop, \vstore_0(\eloc_0))}{\eloc_0})}{\vstore_0}{\bstore_0} }
    \\\sidecond{if $\sdelta(\sunop, \vstore_0(\eloc_0))$ is defined}
    \\[0.5ex]
    \conf{(\ebinopt{\toptional}{\sint_0}{\sint_1})}{\vstore_0}{\bstore_0}
    &  \nredTX
    &  \conf{\sdelta(\sbinop, \sint_0, \sint_1)}{\vstore_0}{\bstore_0}
    \\\sidecond{if \(\sdelta(\sbinop, \sint_0, \sint_1)\) is defined}
    \\[0.5ex]
    \conf{(\eapp{\stype_0}{\eloc_0}{\svalue_0})}{\vstore_0}{\bstore_0}
    & \nredTX
    & \conf{(\echecktwo{\stype_0}{\esubst{\sexpr_0}{\svar_0}{\svalue_0}}{\eloc_0})}{\vstore_0}{\bstore_1}
    \\\sidecond{if \(\fmapref{\vstore_{0}}{\eloc_0}=\efun{\svar_0}{\sexpr_0}\)}
    \\\sidecond{and $\bstore_1 = \fmapupdate{\bstore_0}{\svalue_0}{\frev{\fmapref{\bstore_0}{\eloc_0}}}$}
    \\[0.5ex]
    \conf{(\eapp{\tdyn}{\eloc_0}{\svalue_0})}{\vstore_0}{\bstore_0}
    &  \nredTX
    & \conf{(\esubst{\sexpr_0}{\svar_0}{\svalue_0})}{\vstore_0}{\bstore_0}
    \\\sidecond{if \(\fmapref{\vstore_{0}}{\eloc_0}=\efun{\svar_0}{\sexpr_0}\)}
    \\[0.5ex]
    \conf{(\eapp{\stoptional}{\eloc_0}{\svalue_0})}{\vstore_0}{\bstore_0}
    &  \nredTX
    & \conf{(\echecktwo{\stoptional}{\esubst{\sexpr_0}{\svar_0}{\svalue_0}}{\eloc_0})}{\vstore_0}{\bstore_1}
    \\\sidecond{if $\fmapref{\vstore_{0}}{\eloc_0}=\efun{\tann{\svar_0}{{\stype_0}}}{\sexpr_0}$
                and $\fshallow{\ftagof{\stype_0}}{\fmapref{\vstore_0}{\svalue_0}}$}
    \\\sidecond{and $\bstore_1 = \fmapupdate{\bstore_0}{\svalue_0}{\frev{\bstore_0(\eloc_0)}}$}
    \\[0.5ex]
    \conf{(\eapp{\stoptional}{\eloc_0}{\svalue_0})}{\vstore_0}{\bstore_0}
    &  \nredTX
    & \conf{\boundaryerror{\frev{\fmapref{\bstore_0}{\eloc_0}}}{\svalue_0}}{\vstore_0}{\bstore_1}
    \\\sidecond{if $\fmapref{\vstore_{0}}{\eloc_0}=\efun{\tann{\svar_0}{{\stype_0}}}{\sexpr_0}$
                and $\neg \fshallow{\ftagof{\stype_0}}{\fmapref{\vstore_0}{\svalue_0}}$}
    \\\sidecond{where $\bstore_1 = \fmapupdate{\bstore_0}{\svalue_0}{\frev{\bstore_0(\eloc_0)}}$}
    \\[1.0ex]

    \conf{\sprevalue_0}{\vstore_0}{\bstore_0}
    &  \nredTX
    \\\sidestep{ \conf{\eloc_0}{(\eset{\vrecord{\eloc_0}{\sprevalue_0}} \cup \vstore_0)}{(\eset{\brecord{\eloc_0}{\semptymap}} \cup {\bstore_0})} }
    \\\sidecond{where $\ffresh{\eloc_0}{\vstore_0\mbox{ and }\bstore_0}$}

  \end{rrarray}
}

\bigskip
\lbl{\fbox{$\sexpr; \vstore; \bstore \rredT \sexpr; \vstore; \bstore$} ${}={} \rastar_{\tsym}$}{
  where $\conf{\ctx[\sexpr_0]}{\vstore_0}{\bstore_0} ~\mathrel{\tsym}~ \conf{\ctx[\sexpr_1]}{\vstore_1}{\bstore_1}$
  if $\conf{\sexpr_0}{\vstore_0}{\bstore_0} \nredTX \conf{\sexpr_1}{\vstore_1}{\bstore_1}$
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29}Figure~39: }{t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29}\relax{\tname} notions of reduction}}\end{FigureMulti}

The \relax{\tname} semantics in \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29]{figure~\FigureRef{39}{t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29}} builds on the flat evaluation syntax (\hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dfox22x29x29]{figure~\FigureRef{33}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dfox22x29x29}});
 it stores pairs and functions on a heap
 as indicated by the syntax of \hyperref[t:x28counter_x28x22figurex22_x22figx3aevaluationx2dfox22x29x29]{figure~\FigureRef{33}{t:x28counter_x28x22figurex22_x22figx3aevaluationx2dfox22x29x29}},
 and aims to enforce type constructors (\relax{$\stag$}, or \relax{$\tagof{\stype}$})
 through shape checks.
For every pre{-}value \relax{$\sprevalue$} stored on a heap \relax{$\vstore$}, there is a
 corresponding entry in a blame map \relax{$\bstore$} that points to a set of boundaries.
The blame map provides information if
 a mismatch occurs, following Reticulated Python\relax{~\citep{vss-popl-2017,v-thesis-2019}}.

Unlike for the higher{-}order{-}checking semantics, there is significant overlap between the
 \relax{\tname} rules for typed and untyped redexes.
Thus \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29]{figure~\FigureRef{39}{t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29}} presents one notion of reduction.
The first group of rules in \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29]{figure~\FigureRef{39}{t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29}} handle boundary
 expressions and check expressions.
When a value reaches a boundary, \relax{\tname} matches its shape against the
 expected type.
If successful, the value crosses the boundary and its blame map records
 the fact; otherwise, the program halts.
For a \relax{$\sdyn$} boundary, the result is a boundary error.
For a \relax{$\ssta$} boundary, the mismatch reflects an invariant error in typed
 code.
Check expressions similarly match a value against a type{-}shape.
On success, the blame map gains the boundaries associated with
 the location \relax{$\eloc_0$} from which the value originated.
On failure, these same boundaries may help the programmer diagnose the fault.

The second group of rules handle primitives and application.
Pair projections and function applications must be followed by a check
 in typed contexts to enforce the type annotation at the elimination form.
In untyped contexts, a check for the dynamic type embeds a possibly{-}typed subexpression.
The binary operations are not elimination forms, so they are not followed by
 a check.
Applications of typed functions additionally check the input value against
 the function{'}s domain type.
If successful, the blame map records the check.
Otherwise, \relax{\tname} reports the boundaries associated with the function\relax{~\citep{vss-popl-2017}}.
Note that untyped functions may appear in typed contexts, and vice{-}versa.

Applications of untyped functions in untyped code do not update the
 blame map.
This allows an implementation to insert all checks by rewriting typed
 code at compile{-}time, leaving untyped code as is.
Protected typed code can then interact with any untyped libraries.

Not shown in \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29]{figure~\FigureRef{39}{t:x28counter_x28x22figurex22_x22figx3atransientx2dreductionx22x29x29}} are rules for elimination
 forms that halt the program.
When \relax{$\sdelta$} is undefined or when a non{-}function is applied, the result
 is either an invariant error or a tag error depending on the context.

\relax{\tname} shape checks do not guarantee full type soundness,
 complete monitoring, or the standard blame soundness and completeness.
They do, however, preserve the top{-}level shape of all values in typed code.
Furthermore, \relax{\tname} satisfies a heap{-}based notion of blame soundness.
Blame completeness fails because \relax{\tname} does not update the blame map when an
 untyped function is applied in an untyped context.

\relax{\begin{theorem}
  \tname{} does not satisfy $\propts{\sidproj}$.
\end{theorem}
\begin{proofsketch}
  Let $\sexpr_0 = \edynb{\obnd{\sowner_0}{(\tfun{\tnat}{\tnat})}{\sowner_1}}{(\efun{\svar_0}{{-4}})}$.
  \begin{itemize}
    \item $\sWT \sexpr_0 : \tfun{\tnat}{\tnat}~$ in the surface syntax, but
    \item $\conf{\sexpr_0}{\semptymap}{\semptymap} \rredT \conf{\eloc_0}{\vstore_0}{\bstore_0}$, where $\fmapref{\vstore_0}{\eloc_0} = (\efun{\svar_0}{{-4}})$
  \end{itemize}
  and $\not\sWTfull (\efun{\svar_0}{{-4}}) : \tfun{\tnat}{\tnat}$.
\end{proofsketch}}

\relax{\begin{theorem}
  \tname{} satisfies $\propts{\stagproj}$.
\end{theorem}
\begin{proofsketch}
  Recall that $\stagproj$ maps types to type shapes and the unitype to itself.
  The proof depends on progress and preservation lemmas for the flat typing judgment ($\sWTtag$).
  Although \tname{} lets any well-shaped value cross a boundary, the check
   expressions that appear after elimination forms preserve soundness.
  Suppose that an untyped function crosses a boundary and eventually computes
   an ill-typed result:

  \begin{displayrrarray}
    \conf{(\eapp{\tint}{\eloc_0}{4})}{\vstore_0}{\bstore_0}
    & \nredTX
    & \conf{(\echecktwo{\tint}{{\epair{4}{\esum{\tdyn}{4}{1}}}}{\eloc_0})}{\vstore_0}{\bstore_1}
    \\\sidecond{if \(\fmapref{\vstore_{0}}{\eloc_0}=\efun{\svar_0}{\epair{\svar_0}{\esum{\tdyn}{\svar_0}{1}}}\)}
    \\\sidecond{and $\bstore_1 = \fmapupdate{\bstore_0}{\svalue_0}{\frev{\fmapref{\bstore_0}{\eloc_0}}}$}
  \end{displayrrarray}

  \noindent{}The check expression guards the context.
\end{proofsketch}}

\relax{\begin{theorem}
  \tname{} does not satisfy $\propcm{}$.
\end{theorem}
\begin{proof}
  A structured value can cross any boundary with a matching shape, regardless
   of the deeper type structure.
  For example, the following annotated rule adds a new label to a pair:

  \begin{displayrrarray}
    \conf{\obars{\edynb{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\obbars{\eloc_0}{\sownerlist_2}}}{\sowner_3}}{\vstore_0}{\bstore_0}
    & \nredTXanns &
    \conf{\obbars{\eloc_0}{\fconcat{\sownerlist_2}{\sowner_3}}}{\vstore_0}{\bstore_1}
    \\\sidecond{where $\fmapref{\vstore_0}{\eloc_0} \in \epair{\svalue}{\svalue}$}
  \end{displayrrarray}

\end{proof}}

\relax{\begin{theorem}\label{thm:T-BS}
  \tname{} does not satisfy $\propbspath$.
\end{theorem}
\begin{proof}
  Let component $\sowner_0$ define a function $f_0$ and export it to
   components $\sowner_1$ and $\sowner_2$.
  If component $\sowner_2$ triggers a type mismatch, as sketched below,
   then \tname{} blames both component $\sowner_2$ and the irrelevant $\sowner_1$:

  \begin{center}
    \begin{tikzpicture}[
      triangle/.style = {fill=black!04, regular polygon, regular polygon sides=3}
    ]
      \node (0) {$\sowner_1$};
      \node (1) [right of=0,xshift=4mm] {$\sowner_0$};
      \node (2) [right of=1,xshift=1.2cm] {$\sowner_2$};
      \node (3) [right of=2,xshift=1mm] {};

      \node (3) [below of=1,yshift=2mm] {\hphantom{$\sowner_1$}};
      \draw[dashed] (1.north west) -- (3.south west);
      \node (4) [below of=2,yshift=2mm] {\hphantom{$\sowner_2$}};
      \draw[dashed] (2.north west) -- (4.south west);

      \node[draw,triangle,shape border rotate=180,inner sep=2pt] (5) [right of=1,xshift=-1mm,yshift=-3mm] {$f$};
      \node (6) [right of=0,xshift=-5mm,yshift=-3mm] {\scalebox{1.4}{\bigcheckmark}};
      \draw[->] (5) -- (6);
      \node (7) [outer sep=2pt,right of=2,xshift=-5mm,yshift=-3mm] {\scalebox{1.8}{!}};
      \draw[->] (5) -- (7);
    \end{tikzpicture}
  \end{center}

  The following term expresses this scenario using a let-expression to
   abbreviate untyped function application:

   {\newcommand{\theexampleint}{5}
    \newcommand{\theexampletype}{(\tfun{\tint}{\tint})}
    \begin{displayrrarray}
      \!\!\!\!\!\!\!\!\!(\eletdecl{f_0}{(\efun{\svar_0}{\epair{\svar_0}{\svar_0}})} \!\!\!\!
      \\
      \!\!\!\!\!\!\!\!\!  ~\eletdecl{f_1}{(\estab{\obnd{\sowner_0}{\theexampletype}{\sowner_1}}{\obars{\edynb{\obnd{\sowner_1}{\theexampletype}{\sowner_0}}{\obars{f_0}{\sowner_0}}}{\sowner_1}})} \!\!\!\!
      \\
      \!\!\!\!\!\!\!\!\!  ~\conf{\estab{\obnd{\sowner_0}{\tint}{\sowner_2}}{\obars{\eapp{\tint}{(\edynb{\obnd{\sowner_2}{\theexampletype}{\sowner_0}}{\obars{f_0}{\sowner_0}})}{\theexampleint}}{\sowner_2}})^{\raisedsowner}}{\emptyset}{\emptyset} \!\!\!\!
    \end{displayrrarray}}

  \noindent{}Reduction ends in a boundary error that blames three components.
\end{proof}}

\relax{\begin{theorem}\label{thm:T-BC}
  \tname{} does not satisfy $\propbcpath$.
\end{theorem}
\begin{proof}
  An untyped function application in untyped code does not update the blame map:

  \begin{displayrrarray}
    \conf{(\eapp{\tdyn}{\eloc_0}{\svalue_0})}{\vstore_0}{\bstore_0}
    &  \nredTX
    & \conf{(\esubst{\sexpr_0}{\svar_0}{\svalue_0})}{\vstore_0}{\bstore_0}
    \\\sidecond{if \(\fmapref{\vstore_{0}}{\eloc_0}=\efun{\svar_0}{\sexpr_0}\)}
  \end{displayrrarray}

  \noindent{}Such applications lead to incomplete blame when the function
   has previously crossed a type boundary.
  To illustrate, the term below uses an untyped identity
   function $f_1$ to coerce the type of another function ($f_0$).
  After the coercion, an application leads to type mismatch.

  {\newcommand{\theexamplefun}{\efun{\svar_0}{\svar_0}}
  \newcommand{\typea}{(\tfun{\tint}{\tint})}
  \newcommand{\typeb}{(\tfun{\tint}{\tpair{\tint}{\tint}})}
  \newcommand{\typeatxt}{\stype_0}
  \newcommand{\typebtxt}{\stype_1}
  \newcommand{\deepfowners}{\fconcat{\sowner_2}{\fconcat{\sowner_1}{\fconcat{\sowner_0}{\fconcat{\sowner_3}{\fconcat{\sowner_4}{\fconcat{\sowner_3}{\fconcat{\sowner_0}{\sowner_5}}}}}}}}
  \begin{displayrrarray}
    \!\!\!\!\!\!\!\!\!(\eletdecl{f_0}{\estab{\obnd{\sowner_0}{\typeatxt}{\sowner_1}}{(\edynb{\obnd{\sowner_1}{\typeatxt}{\sowner_2}}{(\theexamplefun)})}}\!\!\!\!
    \\[0.7ex]
    \!\!\!\!\!\!\!\!\!~\eletdecl{f_1}{\estab{\obnd{\sowner_0}{(\tfun{\typeatxt}{\typebtxt})}{\sowner_3}}{(\edynb{\obnd{\sowner_3}{(\tfun{\typeatxt}{\typebtxt})}{\sowner_4}}{(\efun{\svar_1}{\svar_1})})}}\!\!\!\!
    \\[0.7ex]
    \!\!\!\!\!\!\!\!\!~\estab{\obnd{\sowner_0}{(\tpair{\tint}{\tint})}{\sowner_5}}{}\!\!\!\!
    \\[0.5ex]\quad\conf{\zeroheight{\obars{\eapp{\tpair{\tint}{\tint}}{(\edynb{\obnd{\sowner_5}{\typebtxt}{\sowner_0}}{\obars{\eapp{\tdyn}{f_1}{f_0}}{\sowner_0}})}{42}}{\sowner_5})^{\raisedsowner}}}{\semptymap}{\semptymap}
  \end{displayrrarray}}

  \noindent{}Reduction ends in a boundary error that does not report the crucial labels $\sowner_3$ and $\sowner_4$.
\end{proof}}

The results so far paint a negative picture of the wrapper{-}free \relax{\tname} semantics.
It fails \relax{$\propcm{}$} and  \relax{$\propbcpath{}$} because it has no interposition mechanism to
 keep track of type implications for untyped code.
Additionally, its heap{-}based approach to blame fails \relax{$\propbspath{}$} because the
 blame heap conflates different paths in a program.
If several clients use the same library function and one client encounters
 a type mismatch, everyone gets blamed.

We have struggled to find a positive characterization of \relax{\tname}{'}s blame behavior.
Complete monitoring and blame completeness appear unattainable, even in a
 weakened form, because \relax{\tname} has no control over untyped code.
Blame soundness, however, is possible under a relaxed specification of ownership
 that adds one guideline to the {``}natural laws{''} from chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alawsx22x29}{4.4.4.1}{How to lift a reduction relation}:

\relax{\begin{enumerate}
  \item[8.] \label{law:heap}
    If an address gains a label, then so does the associated pre-value on the heap.
   \subitem\hfill
     \(\begin{array}[t]{l}
       \oconf{\sfst~{\obars{\eloc_0}{\sowner_0}}}{\vstore_0}{\bstore_0}{\lstore_0}
       \rrarrow
       \oconf{\obars{\eloc_1}{\sowner_0}}{\vstore_0}{\bstore_0}{\fmapupdate{\lstore_0}{\eloc_1}{\eset{\sowner_0}}}
       \\\mbox{\quad\emph{where} $\fmapref{\vstore_0}{\eloc_0} = \epair{\eloc_1}{\eloc_2}$}
     \end{array}\)
   \subitem\hfill
     \emph{\Lawref{law:pos} propagates the outer label, which goes up to}
   \subitem\hfill
     \emph{the ownership heap ($\lstore$).}
\end{enumerate}}

\noindent{}Intuitively, the new specification pushes all ownership labels onto the heap.
Rather than push to the value heap (\relax{$\vstore$}) directly, though, the
 extended model of \relax{\tname} in the appendix introduces a parallel store
 (\relax{$\lstore$}) analogous to the blame heap.

Merging ownership labels on the heap is a non{-}compositional behavior.
A programmer cannot reason about a local expression without thinking about
 how the rest of the codebase may introduce new owners.
Because of this whole{-}program action, it is unclear whether the weakened
 notions of blame that follow are useful guarantees to strive for.
Nevertheless, they help characterize \relax{\tname}.

\relax{\begin{definition}[heap-based blame soundness and blame completeness]\label{def:blame-heap}
  For all well-formed\/ $\sexpr_0$
  such that\/ $\sexpr_0 \rredX \oconf{\boundaryerror{\sbset_0}{\svalue_0}}{\vstore_0}{\bstore_0}{\lstore_0}$~\emph{:}
  \begin{itemize}
    \itemsep0.1ex
    \item
      $\xsym$ satisfies $\propbsheap$
      iff
      $\fbsetsenders{\sbset_0} \subseteq \fvalueowners{\svalue_0} \cup \fmapref{\lstore_0}{\svalue_0}$
    \item
      $\xsym$ satisfies $\propbcheap$
      iff
      $\fbsetsenders{\sbset_0} \supseteq \fvalueowners{\svalue_0} \cup \fmapref{\lstore_0}{\svalue_0}$.
  \end{itemize}
\end{definition}}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{$\lstore; \sownerenv; \sowner \sWLheap \sexpr; \bstore$}~\missingrules{}}{\begin{mathpar}
 \inferrule*{
   \fbsetsenders{\fmapref{\bstore_0}{\sloc_0}} \subseteq \fmapref{\lstore_0}{\sloc_0}
 }{
   \lstore_0; \sownerenv_0; \sowner_0 \sWLheap \sloc_0; \bstore_0
 }

 \inferrule*{
   \lstore_0; \sownerenv_0; \sowner_0 \sWLheap \sexpr_0; \bstore_0
   \\
   \fbsetsenders{\fmapref{\bstore_0}{\eloc_0}} \subseteq \fmapref{\lstore_0}{\eloc_0}
 }{
   \lstore_0; \sownerenv_0; \sowner_0 \sWLheap \echecktwo{\stype_0}{\sexpr_0}{\eloc_0}; \bstore_0
 }
\end{mathpar}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aheapx2dblamex22x29x29}Figure~40: }{t:x28counter_x28x22figurex22_x22figx3aheapx2dblamex22x29x29}Heap{-}based ownership consistency for \relax{\tname}}}\end{FigureMulti}

\relax{\begin{theorem}\leavevmode
  \tname{} satisfies $\propbsheap$.
\end{theorem}
\begin{proofsketch}
  By a preservation lemma for the $\sWLheap$ judgment sketched in \hyperref[t:x28counter_x28x22figurex22_x22figx3aheapx2dblamex22x29x29]{figure~\FigureRef{40}{t:x28counter_x28x22figurex22_x22figx3aheapx2dblamex22x29x29}}
   and fully-defined in the appendix.
  The judgment ensures that the blame map records a subset of the true owners on each heap-allocated value.
  One subtle case of the proof concerns function application, because the unlabeled
   rule appears to blame a typed function (at address $\eloc_0$) for an unrelated incompatible value:

  \begin{displayrrarray}
      \conf{(\eapp{\stoptional}{\eloc_0}{\svalue_0})}{\vstore_0}{\bstore_0}
      &  \nredTX
      & \conf{\boundaryerror{\frev{\fmapref{\bstore_0}{\eloc_0}}}{\svalue_0}}{\vstore_0}{\bstore_1}
      \\\sidecond{if $\fmapref{\vstore_{0}}{\eloc_0}=\efun{\tann{\svar_0}{{\stype_0}}}{\sexpr_0}$
                  and $\neg \fshallow{\ftagof{\stype_0}}{\fmapref{\vstore_0}{\svalue_0}}$}
      \\\sidecond{where $\bstore_1 = \fmapupdate{\bstore_0}{\svalue_0}{\frev{\bstore_0(\eloc_0)}}$}
  \end{displayrrarray}

  \noindent{}But, the value is not unrelated because the shape check happens
   when this value meets the function's type annotation; that is,
   after the function receives the input value.
  By \lawref{law:neg}, the correct labeling matches the following outline:

  \begin{displayrrarray}
    \obars{\eapp{\stoptional}{\obbars{\eloc_0}{\sownerlist_0}}{\obbars{\svalue_0}{\sownerlist_1}}}{\sowner_0}; \ldots
    &  \nredTXanns & \hspace{2cm}~
    \\\sidestep{ \obars{\boundaryerror{\ldots}{\obbars{\svalue_0}{\fconcat{\sownerlist_1}{\fconcat{\sowner_0}{\frev{\sownerlist_0}}}}}}{\sowner_0}; \ldots }
  \end{displayrrarray}

  \noindent{}Additionally blaming $\fmapref{\bstore_0}{\svalue_0}$
   seems like a useful change to the original \tname{} semantics because it
   offers more information.
  Thanks to heap-based ownership, the technical justification is that
   adding these boundaries preserves the $\propbsheap$\/ property.
\end{proofsketch}}

\relax{\begin{theorem}\leavevmode
  \tname{} does not satisfy $\propbcheap$.
\end{theorem}
\begin{proof}
  Blame completeness fails because \tname{} does not update the blame map
   during an untyped function application.
  Refer to the proof of \theoremref{thm:T-BC} for an example.
\end{proof}}

\relax{\begin{theorem}\label{thm:T-preorder}
  $\fsym{} \sbehaviorle \tsym{}$.
\end{theorem}
\begin{proofsketch}
  Indirectly, via $\tsym{} \sbehavioreq \asym{}$ (\theoremref{thm:TAsim})
   and $\fsym{} \sbehaviorle \asym{}$ (\theoremref{thm:FAsim}).
\end{proofsketch}}

\Ssubsubsection{\relax{\aname} and its Properties}{\relax{\aname} and its Properties}\label{t:x28part_x22secx3adesignx3atechx3aamnesicx22x29}

\label{sec:design:tech:amnesic}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{\aname{} Syntax}~extends \hyperref[fig:evaluation-ho]{\syntaxho{}}}{
  \begin{langarray}
    \svalue & \BNFeq &
      \sint \mid
      \snat \mid
      \epair{\svalue}{\svalue} \mid
      \efun{\svar}{\sexpr} \mid
      \efun{\tann{\svar}{\stype}}{\sexpr} \mid
    \\ & &
      \emon{\obnd{\sowner}{\tfun{\stype}{\stype}}{\sowner}}{\svalue} \mid
      \emon{\obnd{\sowner}{\tpair{\stype}{\stype}}{\sowner}}{\svalue} \mid
      \ehist{\sbset}{\svalue}
  \end{langarray}
}

\bigskip
\lbl{\fbox{$\sexpr \nredAS \sexpr$}~\missingrules{}}{
  \begin{rrarray}
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \nredAS
    & \emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\svalue_0}$}
    \\\sidecond{and $\fremtrace{\svalue_0} \in {\epair{\svalue}{\svalue}} \cup
                                   (\efun{\tann{\svar}{{\stype}}}{\sexpr}) \cup
                                   (\emon{\sbnd}{\svalue})$}
    \\[0.5ex]
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \nredAS
    & \svalue_0
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\svalue_0}$
                and $\fremtrace{\svalue_0} \in \sint$}
    \\[0.5ex]
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \nredAS
    \\\sidestep{ \boundaryerror{\funion{\eset{\obnd{\sowner_0}{\stype_0}{\sowner_1}}}{\sbset_0}}{\svalue_0} }
    \\\sidecond{if $\neg\fshallow{\tagof{\stype_0}}{\svalue_0}$
                and $\sbset_0 \eeq \fgettrace{\svalue_0}$}
    \\[1.0ex]
    \efst{\stype_0}{(\emon{\obnd{\sowner_0}{\stype_1}{\sowner_1}}{\svalue_0})}
    & \nredAS
    & \edynb{\sbnd_0}{(\efst{\tdyn}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_0}{\sowner_1}$}
    \\[0.5ex]
    \esnd{\stype_0}{(\emon{\obnd{\sowner_0}{\stype_1}{\sowner_1}}{\svalue_0})}
    & \nredAS
    & \edynb{\sbnd_0}{(\esnd{\tdyn}{\svalue_0})}
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_0}{\sowner_1}$}
    \\[0.5ex]
    \eapp{\stype_0}{(\emon{\obnd{\sowner_0}{\tfun{\stype_1}{\stype_2}}{\sowner_1}}{\svalue_0})}{\svalue_1}
    & \nredAS
    \\\sidestep{ \edynb{\sbnd_0}{(\eapp{\tdyn}{\svalue_0}{(\estab{\sbnd_1}{\svalue_1})})} }
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_0}{\sowner_1}$
                and $\sbnd_1 \sassign \obnd{\sowner_1}{\stype_1}{\sowner_0}$}
  \end{rrarray}
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aamnesicx2dreductionx22x29x29}Figure~41: }{t:x28counter_x28x22figurex22_x22figx3aamnesicx2dreductionx22x29x29}\relax{\aname} notions of reduction (1/2)}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{$\sexpr \nredAD \sexpr$}~\missingrules{}}{
  \begin{rrarray}
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \nredAD
    & \emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\svalue_0}$
                and $\svalue_0 \in {\epair{\svalue}{\svalue}} \cup {(\efun{\tann{\svar}{{\stype}}}{\sexpr})}$}
    \\[0.5ex]
    \estab{\sbnd_0}{(\emon{\sbnd_1}{(\ehopt{\sbset_0}{\svalue_0})})}
    & \nredAD
    & \eprehist{(\funion{\eset{\sbnd_0, \sbnd_1}}{\sbset_0})}{\svalue_0}
    \\\sidecond{if $\sbnd_0 \eeq \obnd{\sowner_0}{\stype_0}{\sowner_1}$
                and $\fshallow{\tagof{\stype_0}}{\svalue_0}$}
    \\\sidecond{and $\svalue_0 \in {\epair{\svalue}{\svalue}} \cup (\efun{\svar}{\sexpr}) \cup (\emon{\sbnd}{(\efun{\tann{\svar}{\stype}}{\sexpr})}) \cup (\emon{\sbnd}{\epair{\svalue}{\svalue}})$}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\sint_0}
    & \nredAD
    & \sint_0
    \\\sidecond{if $\fshallow{\tagof{\stype_0}}{\sint_0}$}
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \nredAD
    & \tagerrorS
    \\\sidecond{if $\neg\fshallow{\tagof{\stype_0}}{\svalue_0}$}
    \\[1.0ex]
    \efst{\tdyn}{(\ehopt{\sbset_0}{(\emon{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0})})}
    & \nredAD
    \\\sidestep{ \eprehist{\sbset_0}{(\estab{\sbnd_0}{(\efst{\stype_0}{\svalue_0})})} }
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_0}{\sowner_1}$}
    \\[0.5ex]
    \esnd{\tdyn}{(\ehopt{\sbset_0}{(\emon{\obnd{\sowner_0}{\tpair{\stype_0}{\stype_1}}{\sowner_1}}{\svalue_0})})}
    & \nredAD
    \\\sidestep{ \eprehist{\sbset_0}{(\estab{\sbnd_0}{(\esnd{\stype_1}{\svalue_0})})} }
    \\\sidecond{where $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_1}{\sowner_1}$}
    \\[0.5ex]
    \eapp{\tdyn}{(\ehopt{\sbset_0}{(\emon{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0})})}{\svalue_1}
    & \nredAD
    \\\sidestep{ \eprehist{\sbset_0}{(\estab{\sbnd_0}{(\eapp{\stype_2}{\svalue_0}{\sexpr_0})})} }
    \\\sidecond{where $\stype_0 = \tfun{\stype_1}{\stype_2}$
                and $\sbnd_0 \sassign \obnd{\sowner_0}{\stype_2}{\sowner_1}$
                and $\sbnd_1 \sassign \obnd{\sowner_1}{\stype_1}{\sowner_0}$}
    \\\sidecond{and $\sexpr_0 \sassign (\edynb{\sbnd_1}{(\faddtrace{\frev{\sbset_0}}{\svalue_1})})$}
    \\[1.0ex]
    \eprehist{\sbset_0}{\svalue_0}
    & \nredAD
    & \svalue_1
    \\\sidecond{where $\svalue_1 \sassign \faddtrace{\sbset_0}{\svalue_0}$}
  \end{rrarray}
}

\bigskip
\lbl{\fbox{$\sexpr \rredA \sexpr$} ${}={} \rtclosure{\nredAS, \nredAD, \snreddyn, \snredsta}$}{}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aamnesicx2dreduction2x22x29x29}Figure~42: }{t:x28counter_x28x22figurex22_x22figx3aamnesicx2dreduction2x22x29x29}\relax{\aname} notions of reduction (2/2)}}\end{FigureMulti}

The \relax{\aname} semantics employs the same dynamic checks as \relax{\tname} but
 offers path{-}based blame information.
Whereas \relax{\tname} indirectly tracks blame through heap addresses,
 \relax{\aname} uses trace wrappers to keep boundaries alongside the value
 at hand.

\relax{\aname} bears a strong resemblance to the \relax{\fname}
 semantics.
Both use guard wrappers in the same way, keeping a sticky {``}inner{''} wrapper
 around typed values and a temporary {``}outer{''} wrapper in typed contexts.
There are two crucial differences:


\noindent \begin{itemize}\atItemizeStart

\item When \relax{\aname} removes a guard wrapper, it saves the boundary specification
 in a trace wrapper.
The number of boundaries in a trace can grow without bound, but the
 number of wrappers around a value is limited to three.

\item At elimination forms, \relax{\aname} checks only the context{'}s type annotation.
Suppose an untyped function enters typed code at one type and is
 used at a supertype:
 \relax{\\\hfill{}\qquad \relax{$\eapp{\tint}{(\emon{\obnd{\sowner_0}{(\tfun{\tnat}{\tnat})}{\sowner_1}}{\efun{\svar_0}{{-7}}})}{2}$} \hfill{}\\}
\relax{\aname} runs this application without error but \relax{\fname} raises a boundary error.\end{itemize}

\noindent{}Thus, the following wrapped values can occur at run{-}time.
Note that \relax{$(\ehopt{\sbset}{\sexpr})$} is short for an expression that may or may not have a trace wrapper (\hyperref[t:x28counter_x28x22figurex22_x22figx3aamnesicx2dmetax22x29x29]{figure~\FigureRef{43}{t:x28counter_x28x22figurex22_x22figx3aamnesicx2dmetax22x29x29}}).

\relax{\smallskip
\(\hfill
\begin{array}[t]{lcl}
  \svaluestat
   & \BNFeq & \emon{\sbnd}{(\ehopt{\sbset}{\epair{\svalue}{\svalue}})} \\[1pt]
   & \mid   & \emon{\sbnd}{(\ehopt{\sbset}{\efun{\svar}{\sexpr}})} \\[1pt]
   & \mid   & \emon{\sbnd}{(\ehopt{\sbset}{(\emon{\sbnd}{\epair{\svalue}{\svalue}})})} \\[1pt]
   & \mid   & \zerowidth{\emon{\sbnd}{(\ehopt{\sbset}{(\emon{\sbnd}{\efun{\tann{\svar}{\stype}}{\sexpr}})})}}
\end{array}
\hfill
\begin{array}[t]{lcl}
  \svaluedyn
  & \BNFeq & \ehist{\sbset}{\sint} \\
  & \mid & \ehist{\sbset}{\epair{\svalue}{\svalue}} \\
  & \mid & \ehist{\sbset}{\efun{\svar}{\sexpr}} \\
  & \mid & \ehopt{\sbset}{(\emon{\sbnd}{\epair{\svalue}{\svalue}})} \\
  & \mid & \ehopt{\sbset}{(\emon{\sbnd}{\efun{\tann{\svar}{\stype}}{\sexpr}})}
\end{array}
\hfill\)
\smallskip}

The elimination rules for guarded pairs show the clearest
 difference between checks in \relax{\aname} and \relax{\fname}.
\relax{\aname} ignores the type in the guard.
\relax{\fname} ignores the type annotation on the primitive operation.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{minipage}[t]{0.5\columnwidth}
  \(\faddtrace{\sbset_0}{\svalue_0}
    \\ {} \feq
     \left\{\begin{array}{ll}
        \svalue_0
        \\ & \mbox{if $\sbset_0 \eeq \emptyset$}
        \\
        \zerowidth{\ehist{(\sbset_0 \cup \sbset_1)\,}{\svalue_1}}
        \\ & \mbox{if $\svalue_0 \eeq \ehist{\sbset_1}{\svalue_1}$}
        \\
        \zerowidth{\ehist{\sbset_0}{\svalue_0}}
        \\ & \mbox{if $\svalue_0 \not\in \ehist{\sbset}{\svalue}$ and $\sbset_0 \neq \emptyset\!\!\!\!$}
     \end{array}\right.\)

\end{minipage}\begin{minipage}[t]{0.5\columnwidth}
  \(\fgettrace{\svalue_0}
    \\ {} \feq
      \left\{\begin{array}{ll}
        \sbset_0
        & \mbox{if $\svalue_0 \eeq \ehist{\sbset_0}{\svalue_1}$}
        \\
        \emptyset
        & \mbox{if $\svalue_0 \not\in \ehist{\sbset}{\svalue}$}
      \end{array}\right.\)

  \bigskip
  \(\fremtrace{\svalue_0}
    \\ {} \feq
      \left\{\begin{array}{ll}
        \svalue_1
        & \mbox{if $\svalue_0 \eeq \ehist{\sbset_0}{\svalue_1}$}
        \\
        \svalue_0
        & \mbox{if $\svalue_0 \not\in \ehist{\sbset}{\svalue}$}
      \end{array}\right.\)
\end{minipage}

\[(\ehopt{\sbset_0}{\svalue_0}) \eeq \svalue_1
   {} \sabbreveq
    \mbox{$\fremtrace{\svalue_1} \eeq \svalue_0$ and $\fgettrace{\svalue_1} \eeq \sbset_0$} \]}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aamnesicx2dmetax22x29x29}Figure~43: }{t:x28counter_x28x22figurex22_x22figx3aamnesicx2dmetax22x29x29}Metafunctions for \relax{\aname}}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3aamnesicx2dreductionx22x29x29]{Figure~\FigureRef{41}{t:x28counter_x28x22figurex22_x22figx3aamnesicx2dreductionx22x29x29}}
 defines three metafunctions and one abbreviation for trace wrappers.
The metafunctions extend, retrieve, and remove the boundaries associated
 with a value.
The abbreviation lets reduction rules accept optionally{-}traced values.

\relax{\aname} satisfies full type soundness thanks to guard wrappers
 and fails complete monitoring because it drops wrappers.
This is no surprise, since \relax{\aname} creates and removes guard
 wrappers in the same manner as \relax{\fname}.
Unlike the \relax{\fname} semantics, \relax{\aname} uses trace wrappers to remember
 the boundaries that a value has crossed.
This information leads to sound and complete blame messages.

\relax{\begin{theorem}\label{thm:A-TS}
  \aname{} satisfies $\propts{\sidproj}$.
\end{theorem}
\begin{proofsketch}
  By progress and preservation lemmas for the higher-order typing judgment ($\sWTfull$).
  \aname{} creates and drops wrappers in the same manner as \fname{} (\theoremref{thm:F-TS}),
   so the only interesting proof cases concern elimination forms.
  For example, when \aname{} extracts an element from a guarded pair it ignores
   the type in the guard ($\tpair{\stype_1}{\stype_2}$):

  \begin{displayrrarray}
    \efst{\stype_0}{(\emon{\obnd{\sowner_0}{\tpair{\stype_1}{\stype_2}}{\sowner_1}}{\svalue_0})}
    & \nredAS
    & \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{(\efst{\tdyn}{\svalue_0})}
  \end{displayrrarray}

  \noindent{}The new boundary enforces the context's assumption ($\stype_0$)
   instead, but we know that $\stype_0$ is a supertype of $\stype_1$ by the
   higher-order typing judgment.
\end{proofsketch}}

\relax{\begin{theorem}
  \aname{} does not satisfy $\propcm{}$.
\end{theorem}
\begin{proofsketch}
  Removing a wrapper creates a value with more than one label:

  \begin{displayrrarray}
    \obars{\estab{\obnd{\sowner_0}{(\tfun{\stype_0}{\stype_1})}{\sowner_1}}{\obbars{\emon{\sbnd_1}{\obbars{\ehist{\sbset_0}{\obbars{\efun{\svar_0}{\svar_0}}{\sownerlist_2}}}{\sownerlist_3}}}{\sownerlist_4}}}{\sowner_5}
      & \nredADanns
    \\[1ex]\sidestep{\obbars{\eprehist{(\funion{\eset{\obnd{\sowner_0}{(\tfun{\stype_0}{\stype_1})}{\sowner_1}, \sbnd_1}}{\sbset_0})}{\obbars{\efun{\svar_0}{\svar_0}}{\sownerlist_2}}}{\fconcat{\sownerlist_3}{\fconcat{\sownerlist_4}{\sowner_5}}}}
  \end{displayrrarray}

\end{proofsketch}}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{$\sownerenv; \sowner \sWLpath \sexpr$}~\missingrules{}, extends \hyperref[fig:surface-ownership]{$\,\sownerenv; \sowner \sWLsingle \sexpr$}}{\begin{mathpar}
    \inferrule*{
      \sbset_0 = \eset{\fconcat{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\fconcat{\cdots}{\obnd{\sowner_{n-1}}{\stype_{n-1}}{\sowner_n}}}}
      \\
      \sownerenv_0; \sowner_n \sWLpath \svalue_0
    }{
      \sownerenv_0; \sowner_0 \sWLpath \obars{\ehist{\sbset_0}{\obbars{\svalue_0}{\sowner_n \cdots \sowner_1}}}{\sowner_0}
    }
\end{mathpar}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3apathx2dblamex22x29x29}Figure~44: }{t:x28counter_x28x22figurex22_x22figx3apathx2dblamex22x29x29}Path{-}based ownership consistency for trace wrappers}}\end{FigureMulti}

\relax{\begin{theorem}
  \aname{} satisfies $\propbspath$\/ and $\propbcpath$.
\end{theorem}
\begin{proofsketch}
  By progress and preservation lemmas for a path-based consistency judgment, $\sWLpath$, that weakens
   single-owner consistency to allow multiple labels around a trace-wrapped value.
  Unlike the heap-based consistency for \tname{}, which requires an entirely
   new judgment, path-based consistency only replaces the rules for trace wrappers
   (shown in \hyperref[t:x28counter_x28x22figurex22_x22figx3apathx2dblamex22x29x29]{figure~\FigureRef{44}{t:x28counter_x28x22figurex22_x22figx3apathx2dblamex22x29x29}}) and trace expressions.
  Now consider the guard-dropping rule:

  \begin{displayrrarray}
    \obars{\estab{\obnd{\sowner_0}{(\tfun{\stype_0}{\stype_1})}{\sowner_1}}{\obbars{\emon{\sbnd_1}{\obbars{\ehist{\sbset_0}{\obbars{\efun{\svar_0}{\svar_0}}{\sownerlist_2}}}{\sownerlist_3}}}{\sownerlist_4}}}{\sowner_5}
      & \nredADanns
    \\[1ex]\sidestep{\obbars{\eprehist{(\funion{\eset{\obnd{\sowner_0}{(\tfun{\stype_0}{\stype_1})}{\sowner_1}, \sbnd_1}}{\sbset_0})}{\obbars{\efun{\svar_0}{\svar_0}}{\sownerlist_2}}}{\fconcat{\sownerlist_3}{\fconcat{\sownerlist_4}{\sowner_5}}}}
  \end{displayrrarray}

  \noindent{}Path-consistency for the redex implies that $\sownerlist_3$ and $\sownerlist_4$
   match the component names on the boundary $\sbnd_1$, and that the client side
   of $\sbnd_1$ matches the outer sender $\sowner_1$.
  Thus the new labels on the result match the sender names on the two new
   boundaries in the trace.
\end{proofsketch}}

\relax{\begin{theorem}\label{thm:TAsim}
  $\tsym{} \sbehavioreq \asym{}$.
\end{theorem}
\begin{proofsketch}
  By a stuttering simulation between \tname{} and \aname{}.
  \aname{} may take extra steps at an elimination form and to combine traces
   into one wrapper.
  \tname{} takes extra steps to place pre-values on the heap and to conservatively
   check the result of elimination forms.
  In fact, @|aname| and @|tname| behave exactly the same aside from bookkeeping
   to create wrappers and track blame.
\end{proofsketch}}

\relax{\begin{theorem}\label{thm:FAsim}
  $\fsym{} \sbehaviorle \asym{}$.
\end{theorem}
\begin{proofsketch}
  $\!\!$ By a lock-step bisimulation.
  The only difference between \fname{} and \aname{} comes from subtyping.
  \fname{} uses wrappers to enforce the type on a boundary.
  \aname{} uses boundary types only for an initial shape check, and instead uses the static types
   in typed code to guide checks at elimination forms.
  In the following $\asym{} \not\sbehaviorle \fsym{}$ example, a boundary declares one type and an elimination
   form requires a weaker type:

  \begin{displayrrarray}
    \efst{\tint}{(\edynb{\obnd{\sowner_0}{(\tpair{\tnat}{\tnat})}{\sowner_1}}{\epair{{-4}}{4}})}
  \end{displayrrarray}

  \noindent{}Since ${{-4}}$ is an integer, \aname{} reduces to a value.
  \fname{} detects an error.
\end{proofsketch}}

\Ssubsubsection{\relax{\ename} and its Properties}{\relax{\ename} and its Properties}\label{t:x28part_x22secx3adesignx3atechx3aerasurex22x29}

\label{sec:design:tech:erasure}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{\ename{} Syntax}~extends \hyperref[fig:evaluation-eo]{\syntaxeo{}}}{
  \begin{langarray}
    \svalue & \BNFeq &
      \sint \mid \snat \mid \epair{\svalue}{\svalue} \mid \efun{\svar}{\sexpr} \mid \efun{\tann{\svar}{\stype}}{\sexpr}
  \end{langarray}
}

\bigskip
\lbl{\fbox{{$\sexpr \nredEX \sexpr$}}}{
  \begin{rrarray}
    \edynb{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \nredEX
    & \svalue_0
    \\[0.5ex]
    \estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\svalue_0}
    & \nredEX
    & \svalue_0
    \\[1.0ex]
    \eunopt{\stype_0}{\svalue_0}
    & \nredEX
    & \boundaryerror{\emptyset}{\svalue_0}
    \\\sidecond{if {$\sdelta(\sunop, {\svalue_0})$} is undefined}
    \\[0.5ex]
    \eunopt{\tdyn}{\svalue_0}
    & \nredEX
    & \tagerrorD
    \\\sidecond{if {$\sdelta(\sunop, {\svalue_0})$} is undefined}
    \\[0.5ex]
    \eunopt{\stoptional}{\svalue_0}
    & \nredEX
    & \sdelta(\sunop, {\svalue_0})
    \\\sidecond{if {$\sdelta(\sunop, {\svalue_0})$} is defined}
    \\[0.5ex]
    \ebinopt{\stype_0}{\svalue_0}{\svalue_1}
    & \nredEX
    & \boundaryerror{\emptyset}{\svalue_i}
    \\\sidecond{if {$\sdelta(\sbinop, {\svalue_0}, {\svalue_1})$} is undefined and $\svalue_i \not\in \tint$}
    \\[0.5ex]
    \ebinopt{\tdyn}{\svalue_0}{\svalue_1}
    & \nredEX
    & \tagerrorD
    \\\sidecond{if {$\sdelta(\sbinop, {\svalue_0}, {\svalue_1})$} is undefined}
    \\[0.5ex]
    \ebinopt{\stoptional}{\svalue_0}{\svalue_1}
    & \nredEX
    & \sdelta(\sbinop, {\svalue_0}, {\svalue_1})
    \\\sidecond{if {$\sdelta(\sbinop, {\svalue_0}, {\svalue_1})$} is defined}
    \\[0.5ex]
    \eapp{\stype_0}{\svalue_0}{\svalue_1}
    & \nredEX
    & \boundaryerror{\emptyset}{\svalue_0}
    \\\sidecond{if $\svalue_0 \not\in (\efun{\svar}{\sexpr}) \cup (\efun{\tann{\svar}{\stype}}{\sexpr})$}
    \\[0.5ex]
    \eapp{\tdyn}{\svalue_0}{\svalue_1}
    & \nredEX
    & \tagerrorD
    \\\sidecond{if $\svalue_0 \not\in (\efun{\svar}{\sexpr}) \cup (\efun{\tann{\svar}{\stype}}{\sexpr})$}
    \\[0.5ex]
    \eapp{\stoptional}{(\efun{\tann{\svar_0}{\stype_0}}{\sexpr_0})}{\svalue_0}
    & \nredEX
    & \esubst{\sexpr_0}{\svar_0}{\svalue_0}
    \\[0.5ex]
    \eapp{\stoptional}{(\efun{\svar_0}{\sexpr_0})}{\svalue_0}
    & \nredEX
    & \esubst{\sexpr_0}{\svar_0}{\svalue_0}
  \end{rrarray}
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3aerasurex2dreductionx22x29x29}Figure~45: }{t:x28counter_x28x22figurex22_x22figx3aerasurex2dreductionx22x29x29}\relax{\ename} notions of reduction}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3aerasurex2dreductionx22x29x29]{Figure~\FigureRef{45}{t:x28counter_x28x22figurex22_x22figx3aerasurex2dreductionx22x29x29}} presents the values and notions of reduction
 for the \relax{\ename} semantics.
\relax{\ename} ignores all types at runtime.
As the first two reduction rules show, any value may cross any boundary.
When an incompatible value reaches an elimination form, the result depends
 on the context.
In untyped code, the redex steps to a standard tag error.
In typed code, however, the malformed redex indicates that an ill{-}typed
 value crossed a boundary.
Thus \relax{\ename} ends with a boundary error at the last possible moment;
 these errors come with no information because there is no record of the
 relevant boundary.

\relax{\begin{theorem}
  \ename{} satisfies neither $\propts{\sidproj}$\/ nor $\propts{\stagproj}$.
\end{theorem}
\begin{proof}
  Dynamic-to-static boundaries are unsound.
  An untyped function, for example, can enter a typed context that expects an integer:

  \begin{displayrrarray}
    \edynb{\obnd{\sowner_0}{\tint}{\sowner_1}}{(\efun{\svar_0}{42})}
    & \nredEX
    & (\efun{\svar_0}{42})
  \end{displayrrarray}

\end{proof}}

\relax{\begin{theorem}
  \ename{} satisfies $\propts{\sdynproj}$.
\end{theorem}
\begin{proofsketch}
  By progress and preservation lemmas for the erased, or dynamic-typing, judgment ($\sWTnone$).
  Given well-formed input, every $\nredEX$ rule yields a dynamically-typed result.
\end{proofsketch}}

\relax{\begin{theorem}
  \ename{} does not satisfy $\propcm{}$.
\end{theorem}
\begin{proofsketch}
  A static-to-dynamic boundary can create a value with multiple labels:

  \begin{displayrrarray}
    \obars{\estab{\obnd{\sowner_0}{\stype_0}{\sowner_1}}{\obars{\svalue_0}{\sowner_2}}}{\sowner_3}
    & \nredEXanns &
    \obbars{\svalue_0}{\fconcat{\sowner_2}{\sowner_3}}
  \end{displayrrarray}

\end{proofsketch}}

\relax{\begin{theorem}\leavevmode
  \begin{itemize}
    \item \ename{} satisfies\/ $\propbspath$.
    \item \ename{} does not satisfy\/ $\propbcpath$.
  \end{itemize}
\end{theorem}
\begin{proofsketch}
  An \ename{} boundary error blames an empty set, for example:

  \begin{displayrrarray}
    \efst{\tint}{(\efun{\svar_0}{\svar_0})}
    & \nredEX &
    \boundaryerror{\emptyset}{(\efun{\svar_0}{\svar_0})}
  \end{displayrrarray}

  \noindent{}The empty set is trivially sound and incomplete.
\end{proofsketch}}

\relax{\begin{theorem}
  $\asym{} \sbehaviorle \esym{}$.
\end{theorem}
\begin{proofsketch}
  By a stuttering simulation.
  \aname{} takes extra steps at elimination forms, to enforce types, and
   to create trace wrappers.

  As a countexample showing $\asym{} \not\sbehaviorle \esym{}$, the following
   applies an untyped function:

  \begin{displayrrarray}
    \eapp{\tnat}{(\edynb{\obnd{\sowner_0}{(\tfun{\tnat}{\tnat})}{\sowner_1}}{(\efun{\svar_0}{{-9}})})}{4}
  \end{displayrrarray}

  \noindent{}\aname{} checks for a natural-number result and errors,
   but \ename{} checks nothing.
\end{proofsketch}}

\Ssubsection{Discussion}{Discussion}\label{t:x28part_x22secx3adesignx3aconclusionx22x29}

One central design issue of a mixed{-}typed language is the semantics of
 types and specifically how their integrity is enforced at the boundaries between typed and untyped code.
Among other things, the choice determines whether typed code can trust
 the static types and the quality of assistance that a programmer receives
 when a mixed{-}typed interaction goes wrong.
Without an interaction story, mixed{-}typed programs are no better than
 dynamically{-}typed programs when it comes to run{-}time errors.
Properties that hold for the typed half of the language are only valid
 under a closed{-}world assumption\relax{~\citep{bat-ecoop-2014,rsfbv-popl-2015,cvgrl-oopsla-2017}};
 such properties are an important starting point, but make no contribution to
 the overall goal.

As the analysis of this chapter demonstrates, the limitations of
 the host language determine the invariants that a language designer can hope to enforce.
First, higher{-}order wrappers enable strong guarantees, but need support from the host
 runtime system.
For example, Typed Racket is a mature language but
 lacks wrappers for certain higher{-}order values.
A language without wrappers of any sort can provide weaker guarantees by
 rewriting typed code and maintaining a global map of blame metadata.
If this metadata can be attached directly to a value, then stronger
 blame guarantees are in reach.

More precisely, this chapter analyzes six distinct semantics via four properties (table~\ref{tbl:technical})
 and establishes an error preorder relation:

\begin{itemize}\atItemizeStart

\item Type soundness is a relatively weak property for mixed{-}typed programs;
 it determines whether typed code can trust its own types.
Except for the \relax{\ename} semantics, which does nothing to enforce types,
 type soundness does not clearly distinguish the various strategies.

\item Complete monitoring is a stronger property, adapted from the literature on
 higher{-}order contracts\relax{~\citep{dtf-esop-2012}}.
It holds when \emph{untyped} code can trust type specifications and vice{-}versa;
 see chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alyingx2dtypex22x29}{4.2.3}{Uncovering the Source of a Mismatch} for examples.\end{itemize}

\noindent{}The last two properties tell a developer what aid to expect if a
 type mismatch occurs.

\begin{itemize}\atItemizeStart

\item Blame soundness states that every boundary in a blame message is potentially
 responsible.
Four strategies satisfy blame soundness relative to a standard, path{-}based notion of
 responsibility.
\relax{\tname} satisfies blame soundness only if the notion of responsibility is weakened to
 merge distinct references to the same heap{-}allocated value.
\relax{\ename} is trivially blame{-}sound because it gives the programmer zero type{-}related information.

\item Blame completeness states that every blame error comes with an
 overapproximation of the responsible parties.
Three of the four blame{-}sound semantics also satisfy blame completeness.
\relax{\fname} can be modified to satisfy this property.
The \relax{\ename} strategy trivially fails blame completeness.
And the \relax{\tname} strategy fails because it has no way to supervise untyped
values that flow through a typed context.\end{itemize}

\noindent{}Table~\ref{tbl:technical} points out, however, that the weakest strategies
 are the only ones that do not require wrapper values.
Perhaps a future design can strengthen the wrapper{-}free guarantees.

\relax{\begin{table}[t]
  \caption{Technical contributions}
  \label{tbl:technical}

  {\deftablemacros{}
   \newcommand{\addmark}[2]{\hphantom{{}^{#2}}{#1}^{#2}}
   \hfill\(\begin{array}{l@{\quad}c@{\hsep}c@{\hsep}c@{\hsep}c@{\hsep}c@{\hsep}c}
     & \nscr\LE & \cscr\LE & \fscr\LE & \tscr\EQ & \ascr\LE & \escr
     \\[1.0ex] \textrm{type soundness}
        &     \TSfull &     \TSfull &     \TSfull &     \addmark{\TStag}{\dagger} &     \TSfull &     \TSnone
     \\ \textrm{complete monitoring}
        &     \tblY &     \tblY &     \tblN &     \tblN &     \tblN &     \tblN
     \\ \textrm{blame soundness}
        &     \Bpath &     \Bpath &     \Bpath           &     \Bheap &     \Bpath &     \emptyset
     \\ \textrm{blame completeness}
        &     \Bpath &     \Bpath &     \addmark{\tblN}{\ddagger} &     \tblN &     \Bpath &     \tblN
     \\[1ex] \textrm{no wrappers}
        &      \tblN &      \tblN &      \tblN &      \tblY &      \tblN &      \tblY
   \end{array}\)\hfill}

   \medskip
   \hfill
     \begin{tabular}{c@{~~}l}
     $\dagger$ & {note that $\tscr{}$ is bisimilar to $\ascr{}$ (\theoremref{thm:TAsim})}
     \\
     $\ddagger$ & {satisfiable by adding $\ascr{}$-style trace wrappers, see appendix}\!\!\!\!
     \end{tabular}
\end{table}}

\sectionNewpage

\Ssection{Shallow Racket}{Shallow Racket}\label{t:x28part_x22chapx3atransientx22x29}

The high costs of deep types and the weak guarantees of shallow types motivate a compromise.
In a language that supports both, programmers can mix deep and
 shallow types to find an optimal tradeoff.
This chapter presents the first half of the compromise, namely, a shallow semantics for Typed Racket.
By default, Typed Racket provides deep types via the natural semantics.
My work brings the transient semantics to the Typed Racket surface syntax.

Henceforth, Deep Racket refers to the original, natural implementation
 of Typed Racket and Shallow Racket refers to its transient implementation.
Typed Racket refers to the common parts: the surface language and the type system.

Transient is a promising companion to Natural because it pursues an
 opposite kind of implementation.
Whereas natural eagerly enforces full types with guard wrappers, transient
 lazily checks only top{-}level shapes.
The lazy strategy means that transient does not need wrappers, which removes
 the main source of natural overhead.
Transient can also run without blame, removing another form of run{-}time cost.
By contrast, simply removing blame from natural changes little because
 blame information tags along with the guard wrappers.
To fully benefit from removing blame, Natural needs a new strategy for allocating wrappers in
 the first place.

Adapting the theory of transient\relax{~\citep{vss-popl-2017}} to Typed Racket required
 several generalizations and insights (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3atheoryx22x29}{5.1}{Theory}).
In the course of this work, I also adapted the transient heap{-}based blame
 algorithm and identified several challenges (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3ablamex22x29}{5.2}{Work{-}in{-}progress: Blame});
 first and foremost, the basic blame algorithm is prohibitively slow.
The final implementation takes care to reuse large parts of Typed Racket
 (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3aimplementationx22x29}{5.3}{Implementation}).

The performance of Shallow Racket is typically an improvement over
 Deep Racket, but both semantics have distinct strengths (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3aperformancex22x29}{5.4}{Performance}).
Transient always adds overhead relative to untyped Racket, but is the
 safer bet for mixed{-}typed programs.
Natural has better performance in programs with large chunks of typed
 code, and surpasses untyped Racket in many cases.
Whether Shallow Racket can ever run faster than untyped code is an open
 question.

\Ssubsection{Theory}{Theory}\label{t:x28part_x22secx3atransientx3atheoryx22x29}

\relax{\citet{vss-popl-2017}} present a first transient semantics.
This semantics communicates the key ideas behind transient and
 the behavior of Reticulated Python, but four characteristics make it
 unsuitable for a transient implementation in Racket.
It deals with a simpler language of static types;
 it includes a dynamic type;
 it does not include a subtyping relation;
 and its type checker is intertwined with the \emph{completion} pass
 that rewrites typed code.
This section outlines the design of a suitable model and its properties.

\Ssubsubsection{More{-}Expressive Static Types}{More{-}Expressive Static Types}\label{t:x28part_x22secx3atransientx3atheoryx3atypesx22x29}

The main design choices for Shallow Racket concern the run{-}time checks
 that enforce types.
In terms of the model, there is a rich language \relax{$\stype$} of static types
 and the problem is to define a type{-}shape interpretation \relax{$\tagof{\stype}$} for
 each.
A shape must be decidable; for example,
 \relax{$\tagof{\tfun{\tint}{\tint}} = \tfun{\tint}{\tint}$} is unacceptable
 without a predicate that can decide whether an untyped function always
 returns an integer when applied to an integer.
Beyond decidability, type{-}shapes should be fast to test and imply useful
 properties.
Shape soundness should be a meaningful property that helps a programmer debug
 and enables shape{-}directed optimizations.

The original transient model suggests that type{-}shapes must be decidable
 in constant time\relax{~\citep{vss-popl-2017}}.
This model contains type constructors for only reference cells and functions,
 both of which are easily recognized in a dynamically{-}typed language.
Reticulated, however, does not follow the constant{-}time suggestion in order
 to express object types.
The type{-}shape for an object with \relax{$N$} fields/methods checks for the presence
 of each member.
Thus, the cost is linear in the size of an object type.

Shallow Racket includes additional linear{-}time shapes to support
 Typed Racket{'}s expressive types with meaningful run{-}time checks.
Some are linear in the size of a type; others are linear in the size of incoming values.
In general, the goal is to enforce full constructors.
The type{-}shape for a function checks arity; for example,
 the types \relax{$(\tfun{\tint}{\tnat})$} and \relax{$(\tfun{\tint\,\tint}{\tnat})$}
 have different shapes.
The shape for a vector with a fixed number of elements checks length.
And the shape for a list checks for a null{-}terminated sequence of pairs.
Not all types correspond to value constructors, though.
These amorphous type \emph{connectives}\relax{~\citep{cl-icfp-2017,clps-popl-2019}} call for
 recursive interpretations.
For example, \relax{$\tagof{\stype_0 \cup \stype_1} = \tagof{\stype_0} \cup \tagof{\stype_1}$}
 and \relax{$\tagof{\fforall{\alpha_0}{\stype_0}} = \tagof{\stype_0}$}
 provided \relax{$\tagof{\stype_0}$} does not depend on the bound variable.
Type variables have trivial shapes in other contexts, \relax{$\tagof{\alpha_0} = \top$}.
Chapter~\SecRefLocal{t:x28part_x22secx3atransientx3atypesx22x29}{5.3.1}{Types to Shapes} goes into more detail about the implementation.

\Ssubsubsection{Removing Type Dynamic}{Removing Type Dynamic}\label{t:x28part_x22secx3atransientx3atheoryx3adynx22x29}

Reticulated Python provides a dynamic type in the micro gradual typing
 tradition.
Consequently, every type{-}checking rule must accomodate the dynamic type
 in addition to the expected type.
Typed Racket does not have a dynamic type; instead it adds run{-}time tools
 so that a non{-}dynamic type system can make assumptions about untyped input.
Using this macro approach, only a handful of typing rules need to deal
 with dynamically{-}typed values.

The differences between the dynamic (micro) and non{-}dynamic (macro) typing rules have implications
 for transient run{-}time checks.
In the original model, the evaluation of any expression could bring
 a dynamically{-}typed value into a typed context.
In a non{-}dyn model, only boundaries and elimination forms can introduce
 an untyped value.
\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aappx2dcomparex22x29x29]{Figure~\FigureRef{46}{t:x28counter_x28x22figurex22_x22figx3atransientx3aappx2dcomparex22x29x29}} illustrates the difference by contrasting
 the transient checks needed for a function application.
On the top, the dynamic approach requires three checks: two checks in case
 the function and argument are dynamically{-}typed, and one to validate the
 shape of the result.
On the bottom, only one check is needed because the function and argument
 are certain to have a correct, non{-}dyn shape.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{mathpar}
  \inferrule*[lab=With Dyn]{
    \stypeenv_0 \sWT \sexpr_0 : \stype_0 \compilesto \sexpr_0'
    \\
    \stypeenv_0 \sWT \sexpr_1 : \stype_1 \compilesto \sexpr_1'
    \\\\
    \stype_0~\scoerce~\tfun{\stype_2}{\stype_3}
  }{
    \stypeenv_0 \sWT \sexpr_0~\sexpr_1 : \stype_3
    \compilesto
    \echeckone{\stype_3}{((\echeckone{(\tfun{\stype_2}{\stype_3})}{\sexpr_0'})~(\echeckone{\stype_2}{\sexpr_1'}))}
  }

  \inferrule*[lab=Without Dyn]{
    \stypeenv_0 \sWT \sexpr_0 : \tfun{\stype_2}{\stype_3} \compilesto \sexpr_0'
    \\
    \stypeenv_0 \sWT \sexpr_1 : \stype_2 \compilesto \sexpr_1'
  }{
    \stypeenv_0 \sWT \sexpr_0~\sexpr_1 : \stype_3
    \compilesto
    \echeckone{\stype_3}{(\sexpr_0'~\sexpr_1')}
  }
\end{mathpar}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aappx2dcomparex22x29x29}Figure~46: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aappx2dcomparex22x29x29}Transient completion rules for an application with a dynamic type (top) and
without (bottom).
Both rules insert run{-}time shape checks.
The micro rule depends on a type coercion (\relax{$\scoerce$})
metafunction\relax{~\citep{vss-popl-2017}}.}}\end{FigureMulti}

Note: Adding blame to a non{-}dynamic language adds the need for an additional blame{-}map operation
 in \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aappx2dcomparex22x29x29]{figure~\FigureRef{46}{t:x28counter_x28x22figurex22_x22figx3atransientx3aappx2dcomparex22x29x29}}, but no additional checks.
The blame map potentially needs an update because the argument flows
 in to the function.
There is no need for a check because the argument has a non{-}dynamic type.

Other rules can be simplified in a similar fashion.
The benefits are two{-}fold:
 non{-}dyn programs have fewer run{-}time checks to slow them down,
 and programmers have fewer places to search if a program manifests a
 boundary error.

\Ssubsubsection{Adding Subtyping}{Adding Subtyping}\label{t:x28part_x22secx3atransientx3atheoryx3asubtx22x29}

A type system for untyped code must either include a subtyping
 judgment or force programmers to rewrite their data definitions.
Rewriting takes time and invites mistakes, therefore the
 migratory typing perspective demands a subtyping judgment.

The dynamic type is not a replacement for subtyping because it cannot describe designs.
For example, the untyped \Scribtexttt{divide} function in \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3adividex22x29x29]{figure~\FigureRef{47}{t:x28counter_x28x22figurex22_x22figx3atransientx3adividex22x29x29}}
 either divides two numbers or returns the symbol \Scribtexttt{}\Scribtexttt{{'}}\Scribtexttt{undef} if the divisor
 is zero.
Typed Racket lets a programmer express this union of two base types.
By contrast, the dynamic type can only summarize the result in an over{-}approximate
 way that provides no information to callers.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.0bp}{\makebox[200.8bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_25.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3adividex22x29x29}Figure~47: }{t:x28counter_x28x22figurex22_x22figx3atransientx3adividex22x29x29}Untyped division function with two kinds of output.}}\end{FigureMulti}

Adapting transient to include subtyping is therefore an essential task
 for Shallow Racket.
The addition is straightforward, but reveals a surprising distinction
 between declaration{-}site types and use{-}site types; transient with
 subtyping may miss certain type mistakes.
\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3asubtypex22x29x29]{Figure~\FigureRef{48}{t:x28counter_x28x22figurex22_x22figx3atransientx3asubtypex22x29x29}} illustrates the pitfall of transient
 subtyping with a lazy factorial function.
This typed function asks for a thunk that computes a non{-}negative number
 and returns a thunk that computes a factorial.
Because of the type declaration on \Scribtexttt{lazy{-}n}, it looks like transient
 should check that the call \Scribtexttt{(lazy{-}n)} returns a non{-}negative number.
The actual behavior, however, depends on the type of the call expression.
If the implementation replaces the placeholder \Scribtexttt{{\hbox{\texttt{?}}}{\hbox{\texttt{?}}}{\hbox{\texttt{?}}}} with the valid type
 \Scribtexttt{Integer}, then transient checks for an integer and the untyped
 code at the bottom of the figure enters an infinite loop.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.19999999999998863bp}{\makebox[248.8bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_26.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3asubtypex22x29x29}Figure~48: }{t:x28counter_x28x22figurex22_x22figx3atransientx3asubtypex22x29x29}Lazy factorial function, may diverge under transient depending on the type subsituted for the \Scribtexttt{{\hbox{\texttt{?}}}{\hbox{\texttt{?}}}{\hbox{\texttt{?}}}} placeholder.}}\end{FigureMulti}

In summary, the flexibility of subtyping limits the ability of transient
 checks to find mismatches due to type boundaries.
Checks are based on local uses, while boundaries are claims with a broad scope.

\Ssubsubsection{From Elaboration to Completion}{From Elaboration to Completion}\label{t:x28part_x22secx3atransientx3atheoryx3acompletionx22x29}

\relax{\citet{vss-popl-2017}} intertwine typing and transient checks in a
 type{-}elaboration judgment.
The combination is a good fit for an implementation because check{-}insertion
 depends on static types, and one pass over the program is more efficient than
 two.
For the theory, however, it is better to keep surface typing separate
 from a second \emph{completion}\relax{~\citep{h-scp-1994}}
 pass that inserts transient checks

In the model of Shallow Racket, completion is a judgment (\relax{$\compilesto$})
 that transforms a well{-}typed surface term to a term with transient checks.
The goal is to insert enough checks to create a target{-}language term with
 a similar type.

\relax{\theoremsketch{completion correctness}{
  If\/ ${\sWT \sexpr_0 : \stype_0}$
  then\/ ${\sWT \sexpr_0 : \stype_0 \compilesto \sexpr_1}$
  and\/ ${\sWTtag \sexpr_1 : \tagof{\stype_0}}$.
}}

\noindent{}\relax{\Lemmaref{lemma:both:completion}} adapts the theorem sketch to a model.

The first benefit of this theorem is that it rules out nonsensical completions.
By contrast, a type elaboration that converts all surface terms to the
 integer \relax{$42$} satisfies every theorem used to validate the original
 transient\relax{~\citep{vss-popl-2017}}.

Second, the clear requirement makes it easier to adapt the idea of transient
 to a new language.
If the language has its own surface{-}level typing and type{-}to{-}shape metafunction
 (\relax{$\tagof{\cdot}$}), then completion correctness theorem guides the next steps.

Third, the separation encourages research on better completions and target{-}level
 typings.
The challenge is to use as few checks as possible to build the target term.
For example, suppose the variable \Scribtexttt{xy} points to a pair of numbers
 and consider the expression \Scribtexttt{(+ (car xy) (car xy))}.
The completion for Shallow Racket produces the following term:

\begin{SCodeFlow}\Scribtexttt{(+ (check Num (car xy)) (check Num (car xy)))}\end{SCodeFlow}

\noindent{}Racket guarantees left{-}to{-}right evaluation, however, so the second check
 can never fail.
An improved completion would eliminate this check, other flow{-}dominated checks,
 and potentially many others.

\Ssubsection{Work{-}in{-}progress: Blame}{Work{-}in{-}progress: Blame}\label{t:x28part_x22secx3atransientx3ablamex22x29}

Blame is an important part of a migratory typing system because it strengthens
 the key weakness of migratory types.
Static types guarantee that certain errors cannot occur at run{-}time.
Migratory types are weak because they cannot offer the same promise.
Errors can occur just about anywhere in typed code.
With blame, however, type{-}mismatch errors come with an action plan for debugging.
A programmer can follow the blame information to attempt a fix.

The usefulness of such an action plan depends on the blame strategy.
The current{-}best algorithm for transient, from \relax{\citet{vss-popl-2017}},
 blames a set of boundaries.
The set is unsound and incomplete in the technical sense of
 chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method}, but one would expect that it is more useful than
 no information.

Early experience with blame in Shallow Racket, however, has identified
 two significant challenges.
First, scaling the original blame algorithm to Typed Racket raises
 questions about its accuracy.
Second, transient blame has a tremendous performance cost.
This section explains the challenges; performance concerns are deferred
 to chapter~\SecRefLocal{t:x28part_x22secx3atransientx3ablamex2dperformancex22x29}{5.4.4}{Blame Performance}.

\Ssubsubsection{Basics of Transient Blame}{Basics of Transient Blame}\label{t:x28part_x22Basicsx5fofx5fTransientx5fBlamex22x29}

The transient blame algorithm uses a global \emph{blame map} to connect
 run{-}time values to source{-}code boundaries.
This blame map uses heap addresses as keys.
Every non{-}primitive value in a program has a heap address and potentially
 a blame map entry.
The values in a blame map are collections of entries.
There are two kinds of entry in such a collection:


\noindent \begin{enumerate}\atItemizeStart

\item A \emph{boundary entry} combines a type with a source location.
Whenever a value crosses one of the static boundaries between typed
 and untyped code, the blame map gains a boundary entry.
For example, if the function \Scribtexttt{f} flows out of typed code:
\relax{\\\raisebox{-0.7999999999999972bp}{\makebox[198.4bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_27.pdf}}} \\}
then the blame map gains an entry for \Scribtexttt{f} that points to the
 type \Scribtexttt{({-}{\Stttextmore} Natural String)} and a source location.

\item A \emph{link entry} combines a parent pointer and an action.
The parent refers to another blame map key.
The action describes the relation between the current value and its parent.
Suppose the function \Scribtexttt{f} from above gets applied to an
 untyped value \Scribtexttt{v}.
As the value enters the function, the blame map gains a link entry
 for \Scribtexttt{v} that points to \Scribtexttt{f} with the action \Scribtexttt{}\Scribtexttt{{'}}\Scribtexttt{dom},
 to remember that the current value is an input to the parent.\end{enumerate}

If a transient run{-}time check fails, the blame map can supply a set
 of boundaries by following
 parent pointers up from the failed value.
Each parent pointer is partially responsible for the mismatched value.
Each boundary at the root of all parent paths contains possibly{-}unchecked
 type assumptions.
The programmer can begin debugging by reviewing these type assumptions.

\relax{\citet{vss-popl-2017}} suggest a further refinement to this basic idea.
They filter the set of typed boundaries using the failed value and the
 action path that led to the boundary.
The action path gives a list of selectors to apply to the boundary type,
 ending with a smaller type.
Checking this type against the bad value helps rule out irrelevant boundaries.
For example, if the bad value is an integer and one of the boundary types expects an integer,
 then that boundary is not worth reporting.

In summary, the success of the blame map rests on three principles:


\noindent \begin{itemize}\atItemizeStart

\item every type boundary in the program adds one boundary entry in the
 map for each value that crosses the boundary at runtime;

\item every elimination form adds a link entry with a correct parent and action; and

\item there is a run{-}time way to test whether a value matches part of
 a boundary type.\end{itemize}

\noindent These principles are relatively easy to satisfy in a model language,
 but pose surprising challenges for a full language.

\Ssubsubsection{Trusted Libraries Obstruct Blame}{Trusted Libraries Obstruct Blame}\label{t:x28part_x22Trustedx5fLibrariesx5fObstructx5fBlamex22x29}

A migratory typing system must be able to re{-}use host language libraries.
Racket, for example, comes with a list library that provides a \Scribtexttt{map}
 function.
Both Deep Racket and Shallow Racket can re{-}use this function by
 declaring a static type:

\raisebox{-0.7999999999999972bp}{\makebox[304.80000000000007bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_28.pdf}}}

\noindent{}Furthermore, both can import \Scribtexttt{map} at no run{-}time cost.
Deep can trust that the implementation completely follows the type
 and Shallow{---}without blame{---}can trust that \Scribtexttt{map} always returns a list.

For Shallow with blame, however, trusted re{-}use leads to imprecise blame.
\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex3amapx22x29x29]{Figure~\FigureRef{49}{t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex3amapx22x29x29}} illustrates this phenomenon with a tiny example.
The typed function at the top of this figure expects a list of numbers,
 applies a trivial \Scribtexttt{map} to the list,
 and lastly finds a bad element in the mapped list.
Transient blame should point back to the boundary between the typed
 function and the untyped list but cannot if \Scribtexttt{map} does
 not update the blame map.
The solution is to register \Scribtexttt{map} in the blame map with a boundary entry
 and add link entries before and after every call.
Unfortunately, the cost of this extra bookkeeping can add up.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.19999999999998863bp}{\makebox[243.2bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_29.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex3amapx22x29x29}Figure~49: }{t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex3amapx22x29x29}Unless \Scribtexttt{map} updates the blame map, transient cannot point to
 any boundaries when \Scribtexttt{(first nums2)} fails to return a number.}}\end{FigureMulti}

\Ssubsubsection{Complex Flows, Tailored Specifications}{Complex Flows, Tailored Specifications}\label{t:x28part_x22Complexx5fFlowsx5fx5fTailoredx5fSpecificationsx22x29}

Getting blame right for the \Scribtexttt{map} function requires careful bookkeeping.
The result list must have a link entry that points to the input list.
Additionally, the input function should point to this input list in case
 it receives a bad result.

Blame in Shallow Racket depends on literal syntax to decide when complex
 reasoning is needed.
The original algorithm uses the same method; primitive operations have tailored
 bookkeeping and other function applications create link entries in a standard
 way\relax{~\citep{vss-popl-2017}}.

Obviously, the syntactic approach is brittle.
Renaming \Scribtexttt{map} leads to misleading blame errors.
The same goes for applications of an expression instead of a literal identifier.
Improving precision is an open challenge.

\Ssubsubsection{Multi{-}Parent Paths}{Multi{-}Parent Paths}\label{t:x28part_x22Multix2dParentx5fPathsx22x29}

A link entry points to one parent.
Several functions, however, create data with multiple parents.
One basic example is an \Scribtexttt{append} function on lists:

\raisebox{-0.7999999999999972bp}{\makebox[86.39999999999999bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_30.pdf}}}

\noindent{}The result list contains the elements of both inputs.
At a minimum, there should be two parents to blame if something goes wrong.

A second, more complicated example is a \Scribtexttt{hash{-}ref} function that
 may return a default value:

\raisebox{-0.7999999999999972bp}{\makebox[97.6bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_31.pdf}}}

\noindent{}If the table \Scribtexttt{h} has a binding for the key \Scribtexttt{k},
 then the result comes from the table.
Otherwise, the result is computed by the default thunk.

A blame map clearly needs conditional and multi{-}parent paths to give precise
 error outputs.
But the cost of building and traversing the additional link entries may be
 high.
Thus we leave such paths to future work.

\Ssubsubsection{Expressive Link{-}Entry Actions}{Expressive Link{-}Entry Actions}\label{t:x28part_x22Expressivex5fLinkx2dEntryx5fActionsx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{{
\renewcommand{\twoline}[2]{\parbox[t]{2.4in}{#1\newline#2}}
\begin{tabular}{l@ {~~~~}l}
  Action Template & Interpretation
\\\hline
  \Scribtexttt{(dom n)} & \Scribtexttt{n}-th argument to a function
\\
  \Scribtexttt{(cod n)} & \Scribtexttt{n}-th result from a function
\\
  \Scribtexttt{(case{-}dom (k n))} & \twoline{\Scribtexttt{n}-th argument (of \Scribtexttt{k} total) to an}{overloaded function}
\\[3.5ex]
  \Scribtexttt{(object{-}method (m n))} & \twoline{\Scribtexttt{n}-th argument to method \Scribtexttt{m} of an}{object}
\\[3.5ex]
  \Scribtexttt{list{-}elem} & Element of a homogeneous list
\\
  \Scribtexttt{list{-}rest} & Tail of a list
\\
  \Scribtexttt{(list{-}elem n)} &  \twoline{Element of a heterogeneous list,}{e.g. \Scribtexttt{(List Boolean Number String)}$\!\!\!\!$}
\\[3.5ex]
  \Scribtexttt{hash{-}key} & Key of a hashtable
\\
  \Scribtexttt{hash{-}value} & Value of a hashtable
\\
  \Scribtexttt{(struct{-}field n)} & \Scribtexttt{n}-th field of a structure
\\
  \Scribtexttt{(object{-}field f)} & Field \Scribtexttt{f} of an object type
\\
  \Scribtexttt{noop} & No action; direct link to parent
\end{tabular}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex3apathx22x29x29}Figure~50: }{t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex3apathx22x29x29}Sample blame actions in Shallow Racket.}}\end{FigureMulti}

A check entry in the blame map has two parts: a parent pointer and
 an action.
The action informs the type{-}based filtering.
Given a type for the parent, the action says what part of the type is
 relevant to the current value.

The model for Reticulated comes with three actions: \Scribtexttt{Res},
 \Scribtexttt{Arg}, and \Scribtexttt{Deref}.
These help traverse simple function types (\relax{$\tfun{\stype}{\stype}$})
 and reference cells; for example, starting from the parent type
 \relax{$\mathsf{ref}\,\tint$} and applying the \Scribtexttt{Deref} action
 focuses on the element type \relax{$\tint$}.
The implementation of Reticulated adds one action, \Scribtexttt{Attr},
 and generalizes \Scribtexttt{Arg} with an index.
Starting from the following Reticulated type:

\begin{SCodeFlow}\Scribtexttt{Function([int, str], float)}\end{SCodeFlow}

\noindent{}the action \Scribtexttt{[Arg, 1]} focuses on the type \Scribtexttt{str} of the
 second positional argument.
Similarly, the action \Scribtexttt{[Attr, "foo"]} focuses on the member \Scribtexttt{"foo"}
 of an object type.

Despite the extensions, the action language in Reticulated suffers from
 imprecision in two ways.
First, it has no way to refer to certain parts of a type.
If a function uses optional or keyword arguments, then Reticulated has no
 way to test whether the type is irrelevant; such types cannot be filtered from
 the blame output.
Second, it may conflate types.
The action \Scribtexttt{Deref} seems to apply to any data structure.
If a nested list value crosses the boundaries \Scribtexttt{List(List(int))}
 and \Scribtexttt{List(Dict(str, str))}, and then an elimination returns
 a string where an \Scribtexttt{int} was expected, a plain \Scribtexttt{Deref}
 incorrectly filters out the \Scribtexttt{Dict} type.
The developer needs to see both types because neither matches the actual nested list value.

Shallow Racket thus comes with an extensive action language to
 prevent imprecision.
\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex3apathx22x29x29]{Figure~\FigureRef{50}{t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex3apathx22x29x29}} presents a representative sample of actions
 and a brief description of each.
Function actions must handle multiple arguments, multiple results,
 methods, and overloadings.
Data structures have tailored actions.
Lists, for example, require three kinds of actions:
 \Scribtexttt{list{-}elem} to dereference a simple list,
 \Scribtexttt{list{-}rest} to move to the tail of a list keeping the same type,
 and an indexed element action for fixed{-}sized lists with distinct types
 in each position.
Finally, the \Scribtexttt{noop} action adds a direct link
 to track a copy from one data structure to another (\Scribtexttt{vector{-}copy{\hbox{\texttt{!}}}})
 or a wrapper.

\Ssubsubsection{Types at Runtime}{Types at Runtime}\label{t:x28part_x22secx3atransientx3ablamex3atypesx22x29}

Transient blame needs types at runtime, or a close substitute, to filter
 irrelevant boundaries.
These runtime types must have selectors for
 each possible action and an interpretation function that checks the
 shape of a value against the shape of a type.

Shallow Racket{'}s runtime types are a revived version of its static types.
During compilation, static types get serialized into a chain of type constructor
 calls.
After a runtime error occurs, Shallow Racket re{-}evaluates the constructor
 definitions and uses these constructors to revive types.
This revival approach re{-}uses at least 4,000 lines of Typed Racket to good effect:
 roughly 3,000 lines of constructor and selector definitions,
 and 1,000 lines that turn a type into a transient check.
It also handles type aliases nicely.
The static environment knows all relevant aliases and can serialize them
 along with the type.

Revival unfortunately fails for generative structure types.
The run{-}time type and the static type are two different entities, and so
 Shallow Racket is unable to parse the serialized types at run{-}time.
If parsing were to succeed, finding the correct predicate for a generative
 type is a separate challenge.
At compile{-}time, it suffices to generate a correct identifier.
At run{-}time, transient needs to evaluate a correct identifier in
 the right run{-}time context to find the predicate.

A different approach may be able to solve the generative{-}types problem.
A related question, though, is whether transient is better off with
 a different method of filtering.

\Ssubsection{Implementation}{Implementation}\label{t:x28part_x22secx3atransientx3aimplementationx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.5031249999999972bp}{\makebox[331.20000000000005bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_32.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3atrx2doverviewx22x29x29}Figure~51: }{t:x28counter_x28x22figurex22_x22figx3atransientx3atrx2doverviewx22x29x29}Stages in the Deep Racket compiler. Shallow can re{-}use the expander and type checker in full, and parts of the optimizer.}}\end{FigureMulti}

Shallow Racket is an extension of the (Deep) Typed Racket codebase.
The goal is not to create a fork, but rather to adapt the existing compiler
 and provide a uniform experience to programmers.

\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3atrx2doverviewx22x29x29]{Figure~\FigureRef{51}{t:x28counter_x28x22figurex22_x22figx3atransientx3atrx2doverviewx22x29x29}} presents a high{-}level organization diagram of the
 Typed Racket compiler\relax{~\citep{tscff-pldi-2011}}.
Source code goes through a macro{-}expansion step at the start.
The type checker operates on expanded code; it validates the program and
 attaches type annotations as metadata for later passes.
Third, the compiler turns boundary types into higher{-}order contracts.
The last major step is the type{-}driven optimizer, which uses type annotations
 to remove unnecessary runtime checks.

Shallow Racket can re{-}use the expander and type checker as{-}is.
The {``}contract{''} and {``}optimize{''} steps require changes.
Contract generation must create transient checks rather than
 deep higher{-}order contracts (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3atypesx22x29}{5.3.1}{Types to Shapes}).
Additionally, the contract pass must rewrite all typed code with transient
 checks (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3adefensex22x29}{5.3.2}{Inserting Shape Checks}).
The {``}optimize{''} pass must be restricted because it cannot rely on full types (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3aoptimizex22x29}{5.3.3}{Optimizer}).

The implementation effort brought a few surprises.
Challenges with universal types and occurrence types cause the current
 Shallow Racket to reject some well{-}typed code (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3asurprisex22x29}{5.3.2.1}{Current Limitations}).
Deep Racket rejects the same programs.
The experience led to several improvements to Typed Racket, Racket, and
 libraries (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3aprx22x29}{5.3.4}{Bonus Fixes and Enhancements}).

\Ssubsubsection{Types to Shapes}{Types to Shapes}\label{t:x28part_x22secx3atransientx3atypesx22x29}

Shallow Racket compiles static types to \emph{type shape} checks.
Each check enforces first{-}order properties of a type constructor.
In general, a successful check means that all well{-}typed operations
 should succeed at run{-}time.
For example, the type \Scribtexttt{(Pairof String String)} uses the \Scribtexttt{Pairof}
 type constructor; its shape check, \Scribtexttt{pair{\hbox{\texttt{?}}}}, accepts any kind of
 pair.
A successful check \Scribtexttt{(pair{\hbox{\texttt{?}}} v)} means that the operations
 \Scribtexttt{(car v)} and \Scribtexttt{(cdr v)} are well{-}defined, and nothing more.
Because these two operations are the only elimination forms for the
 \Scribtexttt{Pairof} constructor, the shape meets its goal.

Types that support many first{-}order properties have more complex shape checks.
For example, an object comes with field and method names.
The shape check must ensure that type{-}correct calls to \Scribtexttt{get{-}field}
 and \Scribtexttt{send} succeed at run{-}time.

Below are several more example types, chosen to illustrate the variety
 and challenges of extending transient.
Each type comes with a shape that illustrates the implementation
 and a brief discussion.
Actual shapes in the implementation do not use contract combinators such
 as \Scribtexttt{and/c} for performance.

\begin{itemize}\atItemizeStart

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(Listof Real)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{list{\hbox{\texttt{?}}}}\!\!\!\!
\end{tabular}}

The type represents lists of real numbers.
The shape accepts any proper list, but not improper lists such as
 \Scribtexttt{(cons 1 (cons 2 3))}.
The run{-}time cost depends on the size of input values in the worst case,
 but pairs are immutable and the predicate \Scribtexttt{list{\hbox{\texttt{?}}}} caches
 its results.
The optimizer uses the shape to rewrite getters.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(List Real Real)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(and/c list{\hbox{\texttt{?}}} ($\lambda$(v) (= 2 (length l))))}\!\!\!\!
\end{tabular}}

Represents a list with exactly two numbers.
The shape checks lengths.
Doing so lets the optimizer change \Scribtexttt{(list{-}ref v 1)}
 to \Scribtexttt{(unsafe{-}list{-}ref v 1)}.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(Rec Chain (U Null (Pairof Chain Real)))}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(or/c null{\hbox{\texttt{?}}} pair{\hbox{\texttt{?}}})}\!\!\!\!
\end{tabular}}

The recursive type is isomorphic to \Scribtexttt{(Listof Real)}, but enforced
 with a more primitive check.
In general, built{-}in lists have the only shape whose cost depends on the size
 of input values.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(Vector Real)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(and/c vector{\hbox{\texttt{?}}} ($\lambda$(v) (= 1 (vector{-}length v))))}\!\!\!\!
\end{tabular}}

Represents a vector that contains one number.
The shape checks length; the optimizer can use this fact.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(Mutable{-}Vectorof Real)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(and/c vector{\hbox{\texttt{?}}} (not/c immutable{\hbox{\texttt{?}}}))}\!\!\!\!
\end{tabular}}

Represents a mutable vector with any number of elements.
Vectors can also be immutable; the parent type \Scribtexttt{Vector} covers both.
The optimizer does not look at mutability, but the type checker does
 to raise static type errors.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(Weak{-}HashTable Symbol Any)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(and/c hash{\hbox{\texttt{?}}} hash{-}weak{\hbox{\texttt{?}}})}\!\!\!\!
\end{tabular}}

Represents a mutable hash table whose keys do not inhibit the garbage collector.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(U Real String)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(or/c real{\hbox{\texttt{?}}} string{\hbox{\texttt{?}}})}\!\!\!\!
\end{tabular}}

Untagged union.
The shape accepts either a real number or a string;
 these predicates are elimination forms for the union because of occurrence
 typing\relax{~\citep{tf-icfp-2010,t-thesis-2010}}.
Wider unions, with \relax{$N$} types inside, have shapes with \relax{$N$} components.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(Syntaxof String)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{syntax{\hbox{\texttt{?}}}}\!\!\!\!
\end{tabular}}

Represents a syntax object that contains a string.
The shape checks for a syntax object.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(Syntaxof Symbol)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{identifier{\hbox{\texttt{?}}}}\!\!\!\!
\end{tabular}}

Represents a syntax object that contains a symbol.
The shape checks for a syntax object with a symbol inside.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{Integer}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{exact{-}integer{\hbox{\texttt{?}}}}\!\!\!\!
\end{tabular}}

Represents a mathematical integer.
The shape checks for exactness; an inexact integer such as \Scribtexttt{4{\hbox{\texttt{.}}}1} is
 not allowed.

Other numeric types require larger checks for additional properties,
 for example \Scribtexttt{Negative{-}Integer} looks for an exact integer that
 is less than zero.

To the type system, numeric types are wide unions.
Shape enforcement flattens these unions wherever possible.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(Refine [n {\hbox{\texttt{:}}} Integer] (= n 42))}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(and/c exact{-}integer{\hbox{\texttt{?}}} (=/c 42))}\!\!\!\!
\end{tabular}}

Represents an integer that is equal to \Scribtexttt{42}.

Refinement types attach a predicate to a static type.
Predicates are limited to a linear arithmetic.
The shape check uses the whole predicate.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(Class (field [a Natural]) (get{-}a ({-}{\Stttextmore} Natural)))}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(contract{-}first{-}order (class/c (field a) get{-}a))}\!\!\!\!
\end{tabular}}

Represents a class with one field and one method.
The shape depends on the \Scribtexttt{racket/contract} library to check simple
 properties of class shape.
Object types have similar checks, using \Scribtexttt{object/c} instead.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{({-}{\Stttextmore} Real String)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(arity{-}includes/c 1)}\!\!\!\!
\end{tabular}}

Represents a function with one required argument.
The shape checks arity.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{({-}{\Stttextmore} Real * Real)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(arity{-}includes/c 0)}\!\!\!\!
\end{tabular}}

Represents a function that accepts any number of positional arguments.
The shape looks for functions that can accept zero arguments,
 but it does not check whether they accept more.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(case{-}{\Stttextmore} ({-}{\Stttextmore} Real Real) ({-}{\Stttextmore} String Real String))}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{(and/c (arity{-}includes/c 1) (arity{-}includes/c 2))}\!\!\!\!
\end{tabular}}

Represents an overloaded function.
The shape checks both arities.

Functions can also have optional, keyword, and optional keyword arguments.
The shapes for such functions check that the keywords are accepted.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(All (A) (Box A))}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{box{\hbox{\texttt{?}}}}\!\!\!\!
\end{tabular}}

Represents a polymorphic mutable cell.
The shape checks for a cell.
If typed code wants to extract a value from the cell, it must instatiate
 the polymorphic type.
The instantiation provides a shape to check the contents.

\item \relax{\begin{tabular}[t]{l@ {\hspace{1mm}}c@ {\hspace{1mm}}l}
  \(\stype\) & \(=\) & \Scribtexttt{(All (A) A)}\!\!\!\!
\\
  \(\tagof{\stype}\) & \(=\) & \Scribtexttt{none/c}\!\!\!\!
\end{tabular}}

Represents a value that can be instantiated to any type.
The shape rejects all values.

This type could be allowed with the trivial shape \Scribtexttt{any/c} in an
 implementation that checks the result of type instantiation,
 along the lines of \relax{\citet{nja-popl-2020}}.
Shallow Racket does nothing at instantiation, and therefore rejects
 the type to prevent unsoundness (\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aallx2dtypex22x29x29]{figure~\FigureRef{54}{t:x28counter_x28x22figurex22_x22figx3atransientx3aallx2dtypex22x29x29}}).\end{itemize}

\Ssubsubsection{Inserting Shape Checks}{Inserting Shape Checks}\label{t:x28part_x22secx3atransientx3adefensex22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.7999999999999972bp}{\makebox[276.80000000000007bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_33.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3adefensex22x29x29}Figure~52: }{t:x28counter_x28x22figurex22_x22figx3atransientx3adefensex22x29x29}A shallow{-}typed function defended with transient checks.}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.7999999999999972bp}{\makebox[243.2bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_34.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aoptx22x29x29}Figure~53: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aoptx22x29x29}Type prevents callers from sending an optional argument, but the function body can use the default value.}}\end{FigureMulti}

Shallow Racket rewrites typed code to include transient shape checks.
Checks guard the positions where an untyped value might appear
 (chapter~\SecRefLocal{t:x28part_x22secx3adesignx3atechx3atransientx22x29}{4.5.8}{\relax{\tname} and its Properties}); in particular:


\noindent \begin{itemize}\atItemizeStart

\item at the source{-}code boundaries to untyped code;

\item around elimination forms;

\item and at the entry of every function.\end{itemize}

Boundaries clearly need protection.
If typed code expects a number and imports a value from untyped code,
 the value could have any shape and therefore needs a check.

Elimination forms need protection for the same reason, but are an
 over{-}approximation.
\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3adefensex22x29x29]{Figure~\FigureRef{52}{t:x28counter_x28x22figurex22_x22figx3atransientx3adefensex22x29x29}} provides a concrete example with a
 for loop that sums up a list of numbers.
Every step of the loop first checks the current list element.
If the list came from untyped code, then the checks are clearly needed.
The list might come from typed code, though, in which case the checks
 can never fail.

\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3adefensex22x29x29]{Figure~\FigureRef{52}{t:x28counter_x28x22figurex22_x22figx3atransientx3adefensex22x29x29}} also contains a function check.
The inputs to every typed function are checked to validate the type assumptions
 in the function body.
These checks might be unnecessary if the function never escapes to untyped code,
 but escapes are hard to detect because
 a typed function can escape as an argument to a combinator
 \Scribtexttt{(map sum{-}list nss)} or via a macro{-}introduced reference.

\Ssubsubsubsectionstarx{Current Limitations}{Current Limitations}\label{t:x28part_x22secx3atransientx3asurprisex22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.799999999999983bp}{\makebox[271.20000000000005bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_35.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aallx2dtypex22x29x29}Figure~54: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aallx2dtypex22x29x29}If the shape of a universal type depends on the bound variable, then
transient must either reject the program or treat type instantiation as an elimination form.}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.799999999999983bp}{\makebox[187.2bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_36.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aoccurrencex2dtypex22x29x29}Figure~55: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aoccurrencex2dtypex22x29x29}Occurrence types may change the type environment in each branch of
 an \Scribtexttt{if} statement.
Transient must either check the changes or disallow occurrence types
 on untyped functions.}}\end{FigureMulti}

The current implementation attaches transient checks at two kinds
 of syntax: boundaries and run{-}time elimination forms.
This approach does not suffice to protect all types, thus
 some well{-}typed programs are currently rejected to ensure soundness.

Unrestricted universal types are one problem.
If the shape \relax{$\tagof{\stype}$} of a universally{-}quantified type
 \relax{$\fforall{\alpha}{\stype}$} depends on the bound variable, then
 Shallow Racket rejects the program (\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aallx2dtypex22x29x29]{figure~\FigureRef{54}{t:x28counter_x28x22figurex22_x22figx3atransientx3aallx2dtypex22x29x29}}).
The trouble is that type instantiation can change the shape of such types,
 but type instantiation is not currently a run{-}time elimination form.

Occurrence types at a boundary are a second problem.
A program cannot assign an occurrence type to an untyped value,
 as in \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aoccurrencex2dtypex22x29x29]{figure~\FigureRef{55}{t:x28counter_x28x22figurex22_x22figx3atransientx3aoccurrencex2dtypex22x29x29}}.
This code uses \Scribtexttt{require/typed} to import an untyped function with a
 nonsensical occurrence type; it passes the type checker, but the compiler
 raises an error during contract generation because it cannot enforce the
 occurrence type.
Proper enforcement requires rewriting both branches of the conditional
 to include casts based on the occurrence type.
In this case, a check must ensure that \Scribtexttt{x} is a string.

\Ssubsubsection{Optimizer}{Optimizer}\label{t:x28part_x22secx3atransientx3aoptimizex22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{{
  \deftablemacros{}
  \begin{tabular}{l@{~}c@{~~~}l}
    Topic & Shape-Safe?
  \\\hline
    \(\mathsf{apply}\)          & \tblY
    & Deforest map-reduce exprs.
  \\
    \(\mathsf{box}\)            & \tblY
    & Speed up box access.
  \\
    \(\mathsf{dead{\mhyphen}code}\)      & \tblN
    & Remove if and case-lambda branches.
  \\
    \(\mathsf{extflonum}\)      & \tblY
    & Rewrite math for extended floats.
  \\
    \(\mathsf{fixnum}\)         & \tblY
    & Rewrite math for fixnums.
  \\
    \(\mathsf{float{\mhyphen}complex}\)  & \tblY
    & Unbox \& rewrite complex float ops.
  \\
    \(\mathsf{float}\)          & \tblY
    & Rewrite math for normal floats.
  \\
    \(\mathsf{list}\)           & \tblY
    & Speed up list access and length.
  \\
    \(\mathsf{number}\)         & \tblY
    & Rewrite basic numeric operations.
  \\
    \(\mathsf{pair}\)           & \tblN
    & Speed up (nested) pair access.
  \\
    \(\mathsf{sequence}\)       & \tblY
    & Insert type hints for the runtime.
  \\
    \(\mathsf{string}\)         & \tblY
    & Speed up string operations.
  \\
    \(\mathsf{struct}\)         & \tblY
    & Speed up struct access.
  \\
    \(\mathsf{vector}\)         & \tblY
    & Speed up vector access.
  \\
  \end{tabular}
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aoptimizex22x29x29}Figure~56: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aoptimizex22x29x29}TR optimizations and whether Shallow can re{-}use them.}}\end{FigureMulti}

Typed Racket uses static types to compile efficient code\relax{~\citep{sta-nt-base-types,stff-padl-2012,stf-oopsla-2012}}.
To give a basic example, a dynamically{-}typed sum \Scribtexttt{(+ n0 n1)} can be
 rewritten to add its inputs without first confirming that they are numbers.
In principle, such optimizations may rely on full types.
These {``}deep{''} optimizations are not safe for Shallow Racket because it only
 guarantees the top type constructor.

\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aoptimizex22x29x29]{Figure~\FigureRef{56}{t:x28counter_x28x22figurex22_x22figx3atransientx3aoptimizex22x29x29}} lists all optimization topics and shows,
 suprisingly, that only two are unsafe for shallow types.
The \relax{$\mathsf{dead{\mhyphen}code}$} pass remove type{-}inaccessible branches of an overloaded function.
With deep types, run{-}time contracts make these branches inaccessible.
Shallow types allow raw functions to flow to untyped code, and therefore
 the branches are not sealed off by a wrapper.
The \relax{$\mathsf{pair}$} pass depends on full types to rewrite nested accessors, such as \Scribtexttt{cdar},
 to versions that assume a deep pair structure.

Other passes are re{-}used in Shallow Racket.
The benefit of these optimizations is sometimes enough to outweigh the cost
 of transient checks (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3aperformancex22x29}{5.4}{Performance}).
Certain re{-}used passes, though, force design decisions.
The \relax{$\mathsf{apply}$} pass directly applies a typed function to the elements
 of a list.
This transformation is shape sound because all shallow{-}typed functions
 check their inputs, whether or not they escape to untyped code.
The \relax{$\mathsf{list}$} and \relax{$\mathsf{sequence}$} passes depend on the \relax{$O(n)$}
 shape check for list types.
The unboxing in the \relax{$\mathsf{float{\mhyphen}complex}$} pass is only safe by virtue
 of a conservative escape analysis.

\Ssubsubsection{Bonus Fixes and Enhancements}{Bonus Fixes and Enhancements}\label{t:x28part_x22secx3atransientx3aprx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{tabular}{rll}
     & kind   & pull request
\\\hline
   1 & bugfix & \href{https://github.com/racket/htdp/pull/98}{\Scribtexttt{racket/htdp \#98}}
\\
   2 & bugfix & \href{https://github.com/racket/pict/pull/60}{\Scribtexttt{racket/pict \#60}}
\\
   3 & bugfix & \href{https://github.com/racket/racket/pull/3182}{\Scribtexttt{racket/racket \#3182}}
\\
   4 & bugfix & \href{https://github.com/racket/typed-racket/pull/926}{\Scribtexttt{racket/typed{-}racket \#926}}
\\
   5 & bugfix & \href{https://github.com/racket/typed-racket/pull/919}{\Scribtexttt{racket/typed{-}racket \#919}}
\\
   6 & bugfix & \href{https://github.com/racket/typed-racket/pull/916}{\Scribtexttt{racket/typed{-}racket \#916}}
\\
   7 & bugfix & \href{https://github.com/racket/typed-racket/pull/914}{\Scribtexttt{racket/typed{-}racket \#914}}
\\
   8 & bugfix & \href{https://github.com/racket/typed-racket/pull/912}{\Scribtexttt{racket/typed{-}racket \#912}}
\\
   9 & bugfix & \href{https://github.com/racket/typed-racket/pull/923}{\Scribtexttt{racket/typed{-}racket \#923}}
\\
  10 & bugfix & \href{https://github.com/racket/typed-racket/pull/921}{\Scribtexttt{racket/typed{-}racket \#921}}
\\
  11 & bugfix & \href{https://github.com/racket/typed-racket/pull/918}{\Scribtexttt{racket/typed{-}racket \#918}}
\\
  12 & bugfix & \href{https://github.com/racket/typed-racket/pull/913}{\Scribtexttt{racket/typed{-}racket \#913}}
\\
  13 & bugfix & \href{https://github.com/racket/typed-racket/pull/884}{\Scribtexttt{racket/typed{-}racket \#884}}
\\
  14 & bugfix & \href{https://github.com/racket/typed-racket/pull/855}{\Scribtexttt{racket/typed{-}racket \#855}}
\\
  15 & bugfix & \href{https://github.com/racket/typed-racket/pull/612}{\Scribtexttt{racket/typed{-}racket \#612}}
\\
  16 & bugfix & \href{https://github.com/racket/typed-racket/pull/600}{\Scribtexttt{racket/typed{-}racket \#600}}
\\
  17 & enhancement & \href{https://github.com/racket/typed-racket/pull/927}{\Scribtexttt{racket/typed{-}racket \#927}}
\\
  18 & enhancement & \href{https://github.com/racket/typed-racket/pull/925}{\Scribtexttt{racket/typed{-}racket \#925}}
\\
  19 & enhancement & \href{https://github.com/racket/typed-racket/pull/911}{\Scribtexttt{racket/typed{-}racket \#911}}
\\
  20 & enhancement & \href{https://github.com/racket/typed-racket/pull/907}{\Scribtexttt{racket/typed{-}racket \#907}}
\\
  21 & enhancement & \href{https://github.com/racket/typed-racket/pull/917}{\Scribtexttt{racket/typed{-}racket \#917}}
\end{tabular}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3apullsx22x29x29}Figure~57: }{t:x28counter_x28x22figurex22_x22figx3atransientx3apullsx22x29x29}Pull requests inspired by work on Shallow Racket.}}\end{FigureMulti}

The development of Shallow Racket led to several improvements in
 other Racket libraries.
Debugging sessions occasionally revealed bugs in existing code,
 and the integration of Shallow and Deep Racket suggested
 enhancements for the latter.
\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3apullsx22x29x29]{Figure~\FigureRef{57}{t:x28counter_x28x22figurex22_x22figx3atransientx3apullsx22x29x29}} tabulates these fixes and enhancements;
 the third column contains links with more details.

Most improvements came about through transient run{-}time checks.
During compilation, transient relies on types embedded in an intermediate
 representation to generate checks.
Missing types and imprecise types caused problems at this completion step;
 on occasion, the problems were due to Typed Racket bugs.
At run{-}time, transient sometimes found incorrect types with its
 checks.
The HTDP fix offers a simple example (\href{https://github.com/racket/htdp/pull/98}{\Scribtexttt{racket/htdp \#98}}).
A library{-}provided function promised to return a unit value and actually
 returned a boolean.
Transient caught the unsoundness.

The fix to Racket is especially interesting (\href{https://github.com/racket/racket/pull/3182}{\Scribtexttt{racket/racket \#3182}}).
It came about because some shallow{-}typed programs failed with a strange error message:

\begin{SInsetFlow}\Scribtexttt{Expected a real number, got \#{\Stttextless}unsafe{-}undefined{\Stttextmore}}\end{SInsetFlow}

\noindent{}These programs were fully{-}typed, but somehow a run{-}time value
 contradicted the type checker without causing trouble in the Deep semantics.
Worse, this sentinel undefined value did not appear in the source code.
The problem was due to a disagreement between core Racket and Typed Racket
 about how to encode a method with optional arguments as a function with
 a fixed{-}length argument list.
Racket used an extra run{-}time check; Typed Racket thought the check was redundant.
The fix was indeed to change Racket, which means that pre{-}fix versions of Typed Racket
 are a hair{'}s breadth from a dangerous unsoundness.
Their saving grace is that the type optimizer does not transform methods;
 if it did, then user code would receive unsafe{-}undefined values because
 of the incorrect type assumption.

\Ssubsection{Performance}{Performance}\label{t:x28part_x22secx3atransientx3aperformancex22x29}

Shallow Racket sacrifices static guarantees for a wrapper{-}free implementation.
The loss of wrappers implies a loss of full type soundness, complete monitoring,
 and correct blame.
As compensation, shallow needs to demonstrate improved performance.

This section applies the method from chapter~\ChapRefLocal{t:x28part_x22chapx3aperformancex22x29}{3}{Performance Analysis Method} to evaluate
 Shallow Racket on the \relax{\textsc{gtp}} benchmarks.
The granularity of the experiment is module{-}level, same as our Deep Racket
 experiment from chapter~\SecRefLocal{t:x28part_x22secx3atrx3aevaluationx22x29}{3.5}{Application 1: Typed Racket}.
All data is from a dedicated Linux box with 4 physical
  i7{-}4790 3.60GHz cores and 16GB RAM.

\Ssubsubsection{Performance Ratios}{Performance Ratios}\label{t:x28part_x22secx3atransientx3aratiox22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\begin{SCentered}\begin{tabular}[t]{@{}l@{}l@{}r@{}r@{}r@{}}
\hbox{Benchmark} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{deep/untyped} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{shallow/untyped} \\
\hline \hbox{\relax{\textsf{sieve}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.97} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.36} \\
\hbox{\relax{\textsf{forth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.65} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5.21} \\
\hbox{\relax{\textsf{fsm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.54} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.38} \\
\hbox{\relax{\textsf{fsmoo}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.88} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.28} \\
\hbox{\relax{\textsf{mbta}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.63} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.69} \\
\hbox{\relax{\textsf{morsecode}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.73} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.72} \\
\hbox{\relax{\textsf{zombie}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.79} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{31.07} \\
\hbox{\relax{\textsf{dungeon}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.99} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.97} \\
\hbox{\relax{\textsf{jpeg}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.40} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.66} \\
\hbox{\relax{\textsf{zordoz}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.35} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.73} \\
\hbox{\relax{\textsf{lnm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.64} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.06} \\
\hbox{\relax{\textsf{suffixtree}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.69} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5.51} \\
\hbox{\relax{\textsf{kcfa}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.04} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.16} \\
\hbox{\relax{\textsf{snake}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.96} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.67} \\
\hbox{\relax{\textsf{take5}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.97} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.97} \\
\hbox{\relax{\textsf{acquire}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.22} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.40} \\
\hbox{\relax{\textsf{tetris}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.97} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{8.28} \\
\hbox{\relax{\textsf{synth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.96} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.07} \\
\hbox{\relax{\textsf{gregor}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.98} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.53} \\
\hbox{\relax{\textsf{quadT}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.99} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.22} \\
\hbox{\relax{\textsf{quadU}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{0.79} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.14}\end{tabular}\end{SCentered}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aratiox22x29x29}Figure~58: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aratiox22x29x29}Performance ratios for deep and shallow types on the \relax{\textsc{gtp}} benchmarks.}}\end{FigureMulti}

\noindent \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aratiox22x29x29]{Figure~\FigureRef{58}{t:x28counter_x28x22figurex22_x22figx3atransientx3aratiox22x29x29}} presents typed/untyped ratios for
 the benchmarks.
The middle column lists the overhead of fully{-}typed deep code relative
 to the untyped configuration.
The right column shows the overhead of fully{-}typed shallow types.

Because these shallow types are implemented with the transient semantics,
 one would expect them to run slower than deep types because the
 latter has no overhead in completely typed programs.
Indeed, deep runs faster in every row and has a worst{-}case overhead under 2x.
Shallow typically does well, with overhead under 5x, but a few benchmarks
 have larger slowdowns due to transient checks.
The worst is \relax{\textsf{zombie}}, which suffers a 30x ovehead because of the many
 elimination forms in typed code.
A better completion pass may be able to reduce this high cost.
The best case for transient is \relax{\textsf{lnm}}, which nearly runs faster than
 the fully{-}untyped configuration.

\Ssubsubsection{Overhead Plots}{Overhead Plots}\label{t:x28part_x22secx3atransientx3aoverheadx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-2.1093749999999547bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_37.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a0x22x29x29}Figure~59: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a0x22x29x29}Deep vs. Shallow (1/3). }}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-2.1093749999999547bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_38.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a1x22x29x29}Figure~60: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a1x22x29x29}Deep vs. Shallow (2/3).}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-2.1093749999999547bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_39.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a2x22x29x29}Figure~61: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a2x22x29x29}Deep vs. Shallow (3/3).}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a0x22x29x29]{Figures~\FigureRef{59}{t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a0x22x29x29}}, \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a1x22x29x29]{\FigureRef{60}{t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a1x22x29x29}}, and \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a2x22x29x29]{\FigureRef{61}{t:x28counter_x28x22figurex22_x22figx3atransientx3aoverheadx3a2x22x29x29}}
 plot the overhead of Deep and Shallow Racket.
As before, these plots show the proportion of \relax{$D$}{-}deliverable configurations
 for values of \relax{$D$} between 1x and 20x.

Shallow types lead to a huge improvement, from over 20x down to 8x or lower, in
 nine
 benchmarks.
With deep types, these benchmarks suffer high overhead
 due to eager and wrapped checks.
The wrapper{-}free transient semantics removes the issue.
Shallow improves on a few other benchmarks and it does equally{-}well on
 almost all the rest.
The one exception is \relax{\textsf{morsecode}}, which fares better with deep types.
Three characteristics account for the discrepancy:
 \relax{\textsf{morsecode}} boundaries create few wrappers;
 the transient laziness does not end up saving many checks;
 and the overhead of transient checks ends up slowing down large chunks of typed code.
Overall, Shallow Racket lives up to its promise of better mixed{-}typed performance.

\Ssubsubsection{Exact Runtime Plots}{Exact Runtime Plots}\label{t:x28part_x22secx3atransientx3aexactx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-2.1093749999999547bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_40.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a0x22x29x29}Figure~62: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a0x22x29x29}Exact Deep vs Shallow (1/3). }}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-2.1093749999999547bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_41.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a1x22x29x29}Figure~63: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a1x22x29x29}Exact Deep vs Shallow (2/3).}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-2.1093749999999547bp}{\makebox[328.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_42.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a2x22x29x29}Figure~64: }{t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a2x22x29x29}Exact Deep vs Shallow (3/3).}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a0x22x29x29]{Figures~\FigureRef{62}{t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a0x22x29x29}}, \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a1x22x29x29]{\FigureRef{63}{t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a1x22x29x29}}, and \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a2x22x29x29]{\FigureRef{64}{t:x28counter_x28x22figurex22_x22figx3atransientx3aexactx3a2x22x29x29}}
 offer a different perspective on deep and shallow types.
These exact runtime plots show how performance changes as the number of type
 annotations in a benchmark increases.
The leftmost column of each plot has one dot for each fully{-}untyped running
 time.
The right{-}most columns plot the fully{-}typed running times, and columns in
 between have data for every point at the same level of the performance lattice.

In Deep Racket, mixing typed and untyped code can lead to significant overhead.
Points in the middle columns are for mixed configurations, and can have
 high cost; \relax{\textsf{zombie}} in particular slows down in the middle.
Points on the right columns, however, do not suffer.
After critical boundaries are typed, performance is often excellent.

In Shallow Racket, the trend is simple: adding types slows code down.
There is a linear, upward trend in every benchmark.
As the overhead plots anticipate, the linear cost is typically much lower
 than the extremes of deep types.

\Ssubsubsection{Blame Performance}{Blame Performance}\label{t:x28part_x22secx3atransientx3ablamex2dperformancex22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\begin{SCentered}\begin{tabular}[t]{@{}l@{}l@{}r@{}r@{}r@{}r@{}r@{}}
\hbox{Benchmark} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{s.blame/untyped} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{shallow/untyped} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{deep worst{-}case} \\
\hline \hbox{\relax{\textsf{sieve}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{out of memory} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.36} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{15.67} \\
\hbox{\relax{\textsf{forth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{41.54} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5.21} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4010.71} \\
\hbox{\relax{\textsf{fsm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{timeout} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.38} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.37} \\
\hbox{\relax{\textsf{fsmoo}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{294.24} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.28} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{451.07} \\
\hbox{\relax{\textsf{mbta}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{40.71} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.69} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.92} \\
\hbox{\relax{\textsf{morsecode}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{timeout} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.72} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.47} \\
\hbox{\relax{\textsf{zombie}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{563.53} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{31.07} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{54.62} \\
\hbox{\relax{\textsf{dungeon}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{84.68} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.97} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{14573.66} \\
\hbox{\relax{\textsf{jpeg}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{45.92} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.66} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{23.16} \\
\hbox{\relax{\textsf{zordoz}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{192.54} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.73} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.72} \\
\hbox{\relax{\textsf{lnm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{29.19} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.06} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.11} \\
\hbox{\relax{\textsf{suffixtree}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{timeout} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5.51} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{31.17} \\
\hbox{\relax{\textsf{kcfa}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{27.76} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.16} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.43} \\
\hbox{\relax{\textsf{snake}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{timeout} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.67} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{11.84} \\
\hbox{\relax{\textsf{take5}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{50.77} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.97} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{32.17} \\
\hbox{\relax{\textsf{acquire}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{44.79} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.40} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.15} \\
\hbox{\relax{\textsf{tetris}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{timeout} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{8.28} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{11.71} \\
\hbox{\relax{\textsf{synth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{timeout} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.07} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{49.12} \\
\hbox{\relax{\textsf{gregor}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{30.71} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.53} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.63} \\
\hbox{\relax{\textsf{quadT}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{108.50} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.22} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{27.10} \\
\hbox{\relax{\textsf{quadU}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{561.73} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.14} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{59.66}\end{tabular}\end{SCentered}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex2dperformancex22x29x29}Figure~65: }{t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex2dperformancex22x29x29}Performance ratios for Shallow Racket with blame,
 Shallow without blame, and the worst{-}case of Deep types.
The Shallow columns are for the fully{-}typed configuration;
 the Deep column uses the slowest configuration.
The blame experiments ran on a dedicated Linux machine with 16GB RAM
 for at most 10 minutes.}}\end{FigureMulti}

\noindent \hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex2dperformancex22x29x29]{Figure~\FigureRef{65}{t:x28counter_x28x22figurex22_x22figx3atransientx3ablamex2dperformancex22x29x29}} evaluates the overhead of
 Shallow Racket with blame enabled.
The second column of this table measures the overhead of blame on
 the fully{-}typed configuration.
For comparison, the third column lists the overhead of the same
 configuration without blame, and the fourth column lists the absolute
 worst{-}case of deep types.
This table reports only the fully{-}typed configuration for shallow because
 this configuration contains the greatest number blame{-}map updates.
Configurations with fewer typed modules have syntactically fewer locations
 that must touch the global map.

The data shows that blame adds tremendous overhead to Shallow Racket.
Six benchmarks fail to terminate within
 a generous 10{-}minute limit.
One benchmark, \relax{\textsf{sieve}}, ends with an OS{-}level memory error
 after consuming a huge chunk of a 16GB RAM pool.
The rest run far slower than shallow without blame.

Surprisingly, the fourth column shows that shallow blame costs
 more than the worst case of Deep types in 18 benchmarks.
Shallow blame slows down every operation by a small factor
 and allocates a small amount of memory for every value.
These small costs add up, even in our relatively short{-}running benchmarks.
Deep is slowest only in benchmarks that frequently send higher{-}order
 values across boundaries; collapsible contracts may resolve these issues\relax{~\citep{fgsfs-oopsla-2018}}.

Our blame results are far less optimistic than the early report in
 \relax{\citet{vss-popl-2017}}, which found an average slowdown on 2.5x and
 worst{-}case slowdown of 5.4x on fully{-}typed configurations.
For Shallow Racket benchmarks that terminate, the average slowdown
 from blame is 32.04x
 and the worst{-}case is 78.67x.
These different statistics are due to two factors that let Reticulated
 insert fewer checks: the chosen benchmarks and gradual type inference.

Regarding benchmarks, \relax{\citet{vss-popl-2017}} use small programs from the
 \href{https://pyperformance.readthedocs.io/}{\Scribtexttt{pyperformance}} suite.
Three of the twelve benchmarks
focus on numeric computations; since the blame map does not track primitive
values, adding blame adds little overhead.
Four others have since been retired from the Python suite because they are
 too small, unrealistic, and unstable (\href{https://pyperformance.readthedocs.io/changelog.html}{\Scribtexttt{pyperformance{\hbox{\texttt{.}}}readthedocs{\hbox{\texttt{.}}}io/changelog{\hbox{\texttt{.}}}html}}).
Among the remaining benchmarks, the overhead of blame appears to increase with
 the size of the program.
Larger Reticulated benchmarks should run on par with Shallow Racket.
For example, a Reticulated variant of the \relax{\textsf{sieve}} benchmark
 runs in about 40 seconds without blame and times out after 10 minutes with
 blame enabled.

The type inference issue is subtle.
Reticulated frequently infers the dynamic type for local variables.
Doing so is type{-}sound and lets Reticulated skip many runtime checks
 and blame{-}map updates; however, the programmer gets less precise type
 and blame information.
For example, the following Python snippet creates a list of numbers,
 mutates the list, and reads the first element.

\raisebox{-0.799999999999983bp}{\makebox[260.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_43.pdf}}}

Reticulated infers the dynamic type for the list \Scribtexttt{nums} and does
 not check that \Scribtexttt{nums[0]} returns a number.
Running this program leads to a Python exception about comparing strings
 and integers.
For the benchmarks, the lack of checks leads to a faster running time,
 especially in programs that incrementally update local variables in a loop.
If updates lead to the dynamic type, then run{-}time operations are free of
 shape checks.

\sectionNewpage

\Ssection{Deep and Shallow, Combined}{Deep and Shallow, Combined}\label{t:x28part_x22chapx3abothx22x29}

This chapter validates the central point of my thesis: that deep and shallow types
 can be combined in a companion language for Racket, and the combination is an improvement
 over either one alone.
First, I prove that deep types via natural and shallow types
 via transient can coexist in a formal model.
The two semantics can interoperate without changing the formal properties
 of either one (chapter~\SecRefLocal{t:x28part_x22secx3abothx3amodelx22x29}{6.1}{Model and Properties}).
Second, I report challenges that arose combining Deep Racket and
 Shallow Racket in a single implementation (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aimplementationx22x29}{6.2}{Implementation}).
Overall, the combined implementation has clear benefits (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aevaluationx22x29}{6.3}{Evaluation}).
Programmers are better off with a choice of deep guarantees
 and transient performance.
Combining the two semantics in one program can further improve performance.
And, surprisingly, the addition of shallow types can express programs
 that Deep Racket currently cannot.

A downside of the combination is that natural and transient cannot
 easily share the results of their type checks.
The reason is simple: transient as{-}is lacks a way of learning from past checks.
Chapter~\SecRefLocal{t:x28part_x22secx3afuturex3anonoptx22x29}{7.3}{Improving Deep{--}Transient Interaction} explains the synergy challenge in terms of the
 model and outlines implementation techniques that may get around the issue.

\Ssubsection{Model and Properties}{Model and Properties}\label{t:x28part_x22secx3abothx3amodelx22x29}

The model combines deep{-}typed code, shallow{-}typed code, and
 untyped code in one surface language.
Each of these three disciplines is recognized by a surface{-}typing
 judgment and comes with a complier.
The three compilers translate well{-}typed code to a common evaluation
 syntax that has one untyped semantics.

Although the three varieties of surface code give rise to six kinds of
 interactions, the model keeps these interactions under control with
 only three kinds of run{-}time boundaries (\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3abasex2dinteractionx22x29x29]{figure~\FigureRef{66}{t:x28counter_x28x22figurex22_x22figx3abothx3abasex2dinteractionx22x29x29}}).
A \emph{wrap} boundary inserts a higher{-}order check to support deep
 types.
A \emph{scan} boundary validates a top{-}level shape for shallow code.
Lastly, a \emph{noop} boundary does nothing.
Chapter~\SecRefLocal{t:x28part_x22secx3abothx3amodelx3atheoremsx22x29}{6.1.8}{Properties} proves that these checks are strong enough to realize
 shallow types that satisfy shape{-}soundness and deep types that
 satisfy complete monitoring.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.19999999999998863bp}{\makebox[240.0bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_44.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3abasex2dinteractionx22x29x29}Figure~66: }{t:x28counter_x28x22figurex22_x22figx3abothx3abasex2dinteractionx22x29x29}Deep, Shallow, and untyped interactions.}}\end{FigureMulti}

\Ssubsubsection{Syntax}{Syntax}\label{t:x28part_x22secx3abothx3amodelx3asyntaxx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{langarray}
  \ssurface & \slangeq &
    \svar \mid \sint \mid \epair{\ssurface}{\ssurface} \mid
  \\ & &
    \efun{\svar}{\ssurface}
    \mid \efun{\tann{\svar}{\stype}}{\ssurface}
    \mid \efun{\tann{\svar}{\tfloor{\stype}}}{\ssurface} \mid
  \\ & &
    \eunop{\ssurface} \mid \ebinop{\ssurface}{\ssurface} \mid
    \eappu{\ssurface}{\ssurface} \mid
  \\ & &
    \emod{\slang}{\ssurface}
  \\
  \stype & \slangeq &
    \tnat \mid \tint \mid \tpair{\stype}{\stype} \mid \tfun{\stype}{\stype}
  \\
  \slang & \slangeq &
    \sD \mid \sS \mid \sU
  \\
  \stspec & \slangeq &
    \stype \mid \tfloor{\stype} \mid \tdyn
\end{langarray}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3asurfacex22x29x29}Figure~67: }{t:x28counter_x28x22figurex22_x22figx3abothx3asurfacex22x29x29}Surface syntax}}\end{FigureMulti}

The surface syntax begins with simple expressions and adds module boundaries
 to enable a three{-}way interpretation.
The simple expressions are function application (\relax{$\eappu{\ssurface}{\ssurface}$}),
 primitive operation application (\relax{$\eunop{\ssurface}$}, \relax{$\ebinop{\ssurface}{\ssurface}$}),
 variables (\relax{$\svar$}),
 integers (\relax{$\sint$}),
 pairs (\relax{$\epair{\ssurface}{\ssurface}$}),
 and functions.
Functions come in three flavors:
 an untyped function has no type annotation (\relax{$\efun{\svar}{\ssurface}$}),
 a deep{-}typed function has a type annotation (\relax{$\efun{\tann{\svar}{\stype}}{\ssurface}$}),
 and a shallow{-}typed function has an underlined type annotation (\relax{$\efun{\tann{\svar}{\tfloor{\stype}}}{\ssurface}$}).
The underline mark simplifies proofs, and serves as a hint to readers that
 only the top{-}level shape of this type is guaranteed at run{-}time.
It is \emph{not} a meta{-}function.
Types (\relax{$\stype$}) express natural numbers (\relax{$\tnat$}),
 integers (\relax{$\tint$}),
 pairs (\relax{$\tpair{\stype}{\stype}$}),
 and functions (\relax{$\tfun{\stype}{\stype}$}).

Module{-}boundary expressions declare the intent of the code within them.
For example, the term \relax{$\emod{\sD}{\ssurface_0}$} asks for deep types
 in expression \relax{$\ssurface_0$} by default.
If another boundary appears within \relax{$\ssurface_0$}, then its language flag
 (\relax{$\sD$}, \relax{$\sS$}, or \relax{$\sU$}) sets a new default.

Note that module boundaries are similar to the boundary expressions
 from chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method}.
Instead of adding a third boundary term to split the old \relax{$\sstat$} boundaries
 into deep and shallow versions, the present model uses one
 parameterized term.
Both the old and new boundary terms correspond to module boundaries in a
 realistic language.

\Ssubsubsection{Surface Typing}{Surface Typing}\label{t:x28part_x22secx3abothx3amodelx3atypesx22x29}

In principle, the surface language comes with three typing judgments
 to recognize deep, shallow, and untyped code.
These judgments are mutually recursive at module{-}boundary terms.
To keep things simple, however, \hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3asurfacex2dtypex22x29x29]{figure~\FigureRef{68}{t:x28counter_x28x22figurex22_x22figx3abothx3asurfacex2dtypex22x29x29}}
 presents one judgment (\relax{$\stypeenv \sST \sexpr : \stspec$})
 that supports three possible conclusions.
A conclusion (\relax{$\stspec$}) is one of:
 the uni{-}type \relax{$\tdyn$} of untyped code,
 a type \relax{$\stype$} for deep{-}typed code,
 or a decorated type \relax{$\tfloor{\stype}$} for shallow code.
The notation is again a hint.
A decorated type is equal to a normal type during static type checking,
 but makes a weaker statement about program behavior.

The typing rules are straightforward.
If anything, the only surprise is that one module may contain another with
 the same language flag.
\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2dtypex22x29x29]{Figure~\FigureRef{69}{t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2dtypex22x29x29}} defines a
 subtyping judgment (\relax{$\ssubt$}) and a type{-}assignment for primitive
 operations (\relax{$\sDelta$}).

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{mathpar}
  \inferrule*{
    \tann{\svar_0}{\tdyn} \in \stypeenv_0
  }{
    \stypeenv_0 \sST \svar_0 : \tdyn
  }

  \inferrule*{
    \tann{\svar_0}{\stype_0} \in \stypeenv_0
  }{
    \stypeenv_0 \sST \svar_0 : \stype_0
  }

  \inferrule*{
    \tann{\svar_0}{\tfloor{\stype_0}} \in \stypeenv_0
  }{
    \stypeenv_0 \sST \svar_0 : \tfloor{\stype_0}
  }

  \inferrule*{
  }{
    \stypeenv_0 \sST \sint_0 : \tdyn
  }

  \inferrule*{
  }{
    \stypeenv_0 \sST \snat_0 : \tnat
  }

  \inferrule*{
  }{
    \stypeenv_0 \sST \snat_0 : \tfloor{\tnat}
  }

  \inferrule*{
  }{
    \stypeenv_0 \sST \sint_0 : \tint
  }

  \inferrule*{
  }{
    \stypeenv_0 \sST \sint_0 : \tfloor{\tint}
  }

  \inferrule*{
    \stypeenv_0 \sST \ssurface_0 : \tdyn
    \\
    \stypeenv_0 \sST \ssurface_1 : \tdyn
  }{
    \stypeenv_0 \sST \epair{\ssurface_0}{\ssurface_1} : \tdyn
  }

%  \inferrule*{
%    \stypeenv_0 \sST \ssurface_0 : \stype_0
%    \\
%    \stypeenv_0 \sST \ssurface_1 : \stype_1
%  }{
%    \stypeenv_0 \sST \epair{\ssurface_0}{\ssurface_1} : \tpair{\stype_0}{\stype_1}
%  }
%
%  \inferrule*{
%    \stypeenv_0 \sST \ssurface_0 : \tfloor{\stype_0}
%    \\
%    \stypeenv_0 \sST \ssurface_1 : \tfloor{\stype_1}
%  }{
%    \stypeenv_0 \sST \epair{\ssurface_0}{\ssurface_1} : \tfloor{\tpair{\stype_0}{\stype_1}}
%  }
%
  \inferrule*{
    \fcons{\tann{\svar_0}{\tdyn}}{\stypeenv_0} \sST \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sST \efun{\svar_0}{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\stype_0}}{\stypeenv_0} \sST \sexpr_0 : \stype_1
  }{
    \stypeenv_0 \sST \efun{\tann{\svar_0}{\stype_0}}{\sexpr_0} : \tfun{\stype_0}{\stype_1}
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\tfloor{\stype_0}}}{\stypeenv_0} \sST \sexpr_0 : \tfloor{\stype_1}
  }{
    \stypeenv_0 \sST \efun{\tann{\svar_0}{\stype_0}}{\sexpr_0} : \tfloor{\tfun{\stype_0}{\stype_1}}
  }

%  \inferrule*{
%    \stypeenv_0 \sST \ssurface_0 : \tdyn
%  }{
%    \stypeenv_0 \sST \eunop{\ssurface_0} : \tdyn
%  }
%
  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \stype_0
    \\\\
    \sDelta(\sunop, \stype_0) = \stype_1
  }{
    \stypeenv_0 \sST \eunop{\sexpr_0} : \stype_1
  }

%  \inferrule*{
%    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0}
%    \\
%    \sDelta(\sunop, \stype_0) = \stype_1
%  }{
%    \stypeenv_0 \sST \eunop{\sexpr_0} : \tfloor{\stype_1}
%  }
%
%  \inferrule*{
%    \stypeenv_0 \sST \ssurface_0 : \tdyn
%    \\
%    \stypeenv_0 \sST \ssurface_1 : \tdyn
%  }{
%    \stypeenv_0 \sST \ebinop{\ssurface_0}{\ssurface_1} : \tdyn
%  }
%
%  \inferrule*{
%    \stypeenv_0 \sST \sexpr_0 : \stype_0
%    \\
%    \stypeenv_0 \sST \sexpr_1 : \stype_1
%    \\\\
%    \sDelta(\sbinop, \stype_0, \stype_1) = \stype_2
%  }{
%    \stypeenv_0 \sST \ebinop{\sexpr_0}{\sexpr_1} : \stype_2
%  }
%
  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0}
    \\
    \stypeenv_0 \sST \sexpr_1 : \tfloor{\stype_1}
    \\\\
    \sDelta(\sbinop, \stype_0, \stype_1) = \stype_2
  }{
    \stypeenv_0 \sST \ebinop{\sexpr_0}{\sexpr_1} : \tfloor{\stype_2}
  }

%  \inferrule*{
%    \stypeenv_0 \sST \ssurface_0 : \tdyn
%    \\
%    \stypeenv_0 \sST \ssurface_1 : \tdyn
%  }{
%    \stypeenv_0 \sST \eapp{\ssurface_0}{\ssurface_1} : \tdyn
%  }
%
%  \inferrule*{
%    \stypeenv_0 \sST \sexpr_0 : \tfun{\stype_0}{\stype_1}
%    \\
%    \stypeenv_0 \sST \sexpr_1 : \stype_0
%  }{
%    \stypeenv_0 \sST \eapp{\sexpr_0}{\sexpr_1} : \stype_1
%  }
%
  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\tfun{\stype_0}{\stype_1}}
    \\
    \stypeenv_0 \sST \sexpr_1 : \tfloor{\stype_0}
  }{
    \stypeenv_0 \sST \eapp{\sexpr_0}{\sexpr_1} : \tfloor{\stype_1}
  }

%  \inferrule*{
%    \stypeenv_0 \sST \sexpr_0 : \stype_0
%    \\
%    \fsubt{\stype_0}{\stype_1}
%  }{
%    \stypeenv_0 \sST \sexpr_0 : \stype_1
%  }
%
  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0}
    \\
    \fsubt{\stype_0}{\stype_1}
  }{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sST \emodule{\sulang}{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \stype_0
  }{
    \stypeenv_0 \sST \emodule{\stlang}{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0}
  }{
    \stypeenv_0 \sST \emodule{\sslang}{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sST \emodule{\sulang}{\sexpr_0} : \stype_0
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \stype_0
  }{
    \stypeenv_0 \sST \emodule{\stlang}{\sexpr_0} : \stype_0
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0}
  }{
    \stypeenv_0 \sST \emodule{\sslang}{\sexpr_0} : \stype_0
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sST \emodule{\sulang}{\sexpr_0} : \tfloor{\stype_0}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \stype_0
  }{
    \stypeenv_0 \sST \emodule{\stlang}{\sexpr_0} : \tfloor{\stype_0}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0}
  }{
    \stypeenv_0 \sST \emodule{\sslang}{\sexpr_0} : \tfloor{\stype_0}
  }
\end{mathpar}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3asurfacex2dtypex22x29x29}Figure~68: }{t:x28counter_x28x22figurex22_x22figx3abothx3asurfacex2dtypex22x29x29}Surface typing judgment (selected rules)}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\lbl{\fbox{$\fsubt{\stype}{\stype}$}}{\begin{mathpar}
  \inferrule*{
  }{
    \fsubt{\tnat}{\tint}
  }

  \inferrule*{
    \fsubt{\stype_0}{\stype_2}
    \\
    \fsubt{\stype_1}{\stype_3}
  }{
    \fsubt{\tpair{\stype_0}{\stype_1}}{\tpair{\stype_2}{\stype_3}}
  }

  \inferrule*{
    \fsubt{\stype_2}{\stype_0}
    \\
    \fsubt{\stype_1}{\stype_3}
  }{
    \fsubt{\tfun{\stype_0}{\stype_1}}{\tfun{\stype_2}{\stype_3}}
  }
\end{mathpar}}

\begin{minipage}[t]{0.5\columnwidth}
\lbl{\fbox{$\sDelta : \ffun{\tpair{\sunop}{\stype}}{\stype}$}}{
  \begin{langarray}
    \sDelta(\sfst, \tpair{\stype_0}{\stype_1}) & \feq & \stype_0
  \\
    \sDelta(\ssnd, \tpair{\stype_0}{\stype_1}) & \feq & \stype_1
  \end{langarray}
}

\end{minipage}\begin{minipage}[t]{0.5\columnwidth}
\lbl{\fbox{$\sDelta : \ffun{\tpair{\sbinop}{\tpair{\stype}{\stype}}}{\stype}$}}{
  \begin{langarray}
    \sDelta(\ssum, \tnat, \tnat) & \feq & \tnat
  \\
    \sDelta(\ssum, \tint, \tint) & \feq & \tint
  \\
    \sDelta(\squotient, \tnat, \tnat) & \feq & \tnat
  \\
    \sDelta(\squotient, \tint, \tint) & \feq & \tint
  \end{langarray}
}
\end{minipage}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2dtypex22x29x29}Figure~69: }{t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2dtypex22x29x29}Subtyping and primitive op. typing}}\end{FigureMulti}

\Ssubsubsection{Evaluation Syntax}{Evaluation Syntax}\label{t:x28part_x22secx3abothx3amodelx3aevalx2dsyntaxx22x29}

The evaluation syntax removes the declarative parts of the surface syntax
 and adds tools for enforcing types.
First to go are the module boundary expressions, which express a desire
 for a style of type enforcement.
Instead, the evaluation syntax has three kinds of run{-}time check expression:
 a wrap boundary fully enforces a type, perhaps with a guard wrapper (\relax{$\emon{\stype}{\svalue}$});
 a scan boundary checks a type{-}shape (\relax{$\sshape$}),
 and a noop boundary checks nothing.
Second, the shallow{-}typed functions from the surface syntax (\relax{$\efun{\tann{\svar}{\tfloor{\stype}}}{\ssurface}$})
 are replaced with shape{-}annotated functions (\relax{$\efun{\tann{\svar}{\sshape}}{\sexpr}$}).
Type{-}shapes (\relax{$\sshape$}) express the outermost constructor of a type;
 the weakened function annotation reflects what is known, in general,
 at run{-}time.

The evaluation syntax also includes values (\relax{$\svalue$}),
 errors (\relax{$\serror$}),
 and evaluation contexts (\relax{$\sctx$}).
Running a program may produce a value or an error.
For the most part, the different errors come from boundaries.
A \relax{$\swraperror$} arises when a wrap boundary receives invalid input,
 a \relax{$\sscanerror$} comes from a failed scan,
 and a \relax{$\sdivzeroerror$} occurs when a primitive operation rejects its input.
The final error, \relax{$\stagerror$}, is the result of a malformed term that cannot
 reduce further.
Such errors can easily occur in untyped code without any boundaries;
 for instance, the application of a number (\relax{$\eappu{2~}{4}$}) signals a tag error.
Reduction in typed code, whether deep or shallow, should never raise a
 tag error.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{langarray}
  \sexpr & \slangeq &
    \svar \mid \svalue \mid \epair{\sexpr}{\sexpr}
    \mid \eunop{\sexpr} \mid
    \ebinop{\sexpr}{\sexpr} \mid \eappu{\sexpr}{\sexpr} \mid \serror \mid
  \\ & &
    \ewrap{\stype}{\sexpr}
    \mid \escan{\sshape}{\sexpr}
    \mid \enoop{\sexpr}
  \\
  \svalue & \slangeq &
    \sint \mid \epair{\svalue}{\svalue}
    \mid \efun{\svar}{\sexpr}
    \mid \efun{\tann{\svar}{\stype}}{\sexpr}
    \mid \efun{\tann{\svar}{\sshape}}{\sexpr}
    \mid \emon{\stype}{\svalue}
  \\
  \sshape & \slangeq &
    \knat \mid \kint \mid \kpair \mid \kfun \mid \kany
  \\
  \serror & \slangeq &
    \swraperror \mid \sscanerror \mid \sdivzeroerror \mid \stagerror
  \\
  \sctx & \slangeq &
    \sctxhole \mid \eunop{\sctx} \mid \ebinop{\sctx}{\sexpr} \mid \ebinop{\svalue}{\sctx}
    \mid \eappu{\sctx}{\sexpr} \mid \eappu{\svalue}{\sctx} \mid
  \\ & &
    \enoop{\sctx} \mid \escan{\sshape}{\sctx} \mid \ewrap{\stype}{\sctx}
\end{langarray}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3aevalx2dsyntaxx22x29x29}Figure~70: }{t:x28counter_x28x22figurex22_x22figx3abothx3aevalx2dsyntaxx22x29x29}Evaluation Syntax}}\end{FigureMulti}

\Ssubsubsection{Evaluation Typing}{Evaluation Typing}\label{t:x28part_x22secx3abothx3amodelx3aevalx2dtypesx22x29}

The evaluation syntax comes with three typing judgments that describe the
 run{-}time invariants of deep, shallow, and untyped code.
The deep typing judgment (\relax{$\sWTT$}) validates full types.
The shallow judgment (\relax{$\sWTS$}) checks top{-}level shapes.
In this judgment, elimination forms have a catch{-}all shape (\relax{$\kany$}) because
 they can produce any value at run{-}time;
 these must appear within a scan expression to guarantee a non{-}trivial
 shape.
Lastly, the untyped judgment (\relax{$\sWTU$}) guarantees no free variables.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{mathpar}
  \inferrule*{
    \tann{\svar_0}{\stype_0} \in \stypeenv_0
  }{
    \stypeenv_0 \sWTT \svar_0 : \stype_0
  }

  \inferrule*{
  }{
    \stypeenv_0 \sWTT \snat_0 : \tnat
  }

  \inferrule*{
  }{
    \stypeenv_0 \sWTT \sint_0 : \tint
  }

  \inferrule*{
    \stypeenv_0 \sWTT \sexpr_0 : \stype_0
    \\
    \stypeenv_0 \sWTT \sexpr_1 : \stype_1
  }{
    \stypeenv_0 \sWTT \epair{\sexpr_0}{\sexpr_1} : \tpair{\stype_0}{\stype_1}
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\stype_0}}{\stypeenv_0} \sWTT \sexpr_0 : \stype_1
  }{
    \stypeenv_0 \sWTT \efun{\tann{\svar_0}{\stype_0}}{\sexpr_0} : \tfun{\stype_0}{\stype_1}
  }

  \inferrule*{
    \stypeenv_0 \sWTU \svalue_0 : \tdyn
  }{
    \stypeenv_0 \sWTT \emon{\stype_0}{\svalue_0} : \stype_0
  }

  \inferrule*{
    \stypeenv_0 \sWTS \svalue_0 : \sshape_0
  }{
    \stypeenv_0 \sWTT \emon{\stype_0}{\svalue_0} : \stype_0
  }

  \inferrule*{
    \stypeenv_0 \sWTT \sexpr_0 : \stype_0
    \\\\
    \sDelta(\sunop, \stype_0) = \stype_1
  }{
    \stypeenv_0 \sWTT \eunop{\sexpr_0} : \stype_1
  }

  \inferrule*{
    \stypeenv_0 \sWTT \sexpr_0 : \stype_0
    \\
    \stypeenv_0 \sWTT \sexpr_1 : \stype_1
    \\\\
    \sDelta(\sbinop, \stype_0, \stype_1) = \stype_2
  }{
    \stypeenv_0 \sWTT \ebinop{\sexpr_0}{\sexpr_1} : \stype_2
  }

  \inferrule*{
    \stypeenv_0 \sWTT \sexpr_0 : \tfun{\stype_0}{\stype_1}
    \\
    \stypeenv_0 \sWTT \sexpr_1 : \stype_0
  }{
    \stypeenv_0 \sWTT \eappu{\sexpr_0}{\sexpr_1} : \stype_1
  }

  \inferrule*{
    \stypeenv_0 \sWTT \sexpr_0 : \stype_0
  }{
    \stypeenv_0 \sWTT \enoop{\sexpr_0} : \stype_0
  }

  \inferrule*{
    \stypeenv_0 \sWTU \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sWTT \ewrap{\stype_0}{\sexpr_0} : \stype_0
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_0
  }{
    \stypeenv_0 \sWTT \ewrap{\stype_0}{\sexpr_0} : \stype_0
  }

  \inferrule*{
    \stypeenv_0 \sWTT \sexpr_0 : \stype_0
    \\
    \fsubt{\stype_0}{\stype_1}
  }{
    \stypeenv_0 \sWTT \sexpr_0 : \stype_1
  }

  \inferrule*{
  }{
    \stypeenv_0 \sWTT \serror : \stype_0
  }
\end{mathpar}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3adeepx2dtypex22x29x29}Figure~71: }{t:x28counter_x28x22figurex22_x22figx3abothx3adeepx2dtypex22x29x29}Deep typing judgment}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{mathpar}
  \inferrule*{
    \tann{\svar_0}{\sshape_0} \in \stypeenv_0
  }{
    \stypeenv_0 \sWTS \svar_0 : \sshape_0
  }

  \inferrule*{
  }{
    \stypeenv_0 \sWTS \snat_0 : \tnat
  }

  \inferrule*{
  }{
    \stypeenv_0 \sWTS \sint_0 : \tint
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_0
    \\
    \stypeenv_0 \sWTS \sexpr_1 : \sshape_1
  }{
    \stypeenv_0 \sWTS \epair{\sexpr_0}{\sexpr_1} : \kpair
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\tdyn}}{\stypeenv_0} \sWTU \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sWTS \efun{\svar_0}{\sexpr_0} : \kfun
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\sshape_0}}{\stypeenv_0} \sWTS \sexpr_0 : \sshape_1
  }{
    \stypeenv_0 \sWTS \efun{\tann{\svar_0}{\sshape_0}}{\sexpr_0} : \kfun
  }

  \inferrule*{
    \stypeenv_0 \sWTT \svalue_0 : \stype_0
  }{
    \stypeenv_0 \sWTS \emon{\stype_0}{\svalue_0} : \kfun
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_0
  }{
    \stypeenv_0 \sWTS \eunop{\sexpr_0} : \kany
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_0
    \\
    \stypeenv_0 \sWTS \sexpr_1 : \sshape_1
  }{
    \stypeenv_0 \sWTS \ebinop{\sexpr_0}{\sexpr_1} : \kany
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \kfun
    \\
    \stypeenv_0 \sWTS \sexpr_1 : \sshape_0
  }{
    \stypeenv_0 \sWTS \eappu{\sexpr_0}{\sexpr_1} : \kany
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_0
  }{
    \stypeenv_0 \sWTS \enoop{\sexpr_0} : \sshape_0
  }

  \inferrule*{
    %% TODO why need this???
    \stypeenv_0 \sWTU \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sWTS \enoop{\sexpr_0} : \kany
  }

  \inferrule*{
    \stypeenv_0 \sWTU \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sWTS \escan{\sshape_0}{\sexpr_0} : \sshape_0
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_1
  }{
    \stypeenv_0 \sWTS \escan{\sshape_0}{\sexpr_0} : \sshape_0
  }

  \inferrule*{
    \stypeenv_0 \sWTT \sexpr_0 : \stype_0
    \\
    \fshape{\stype_0} = \sshape_0
  }{
    \stypeenv_0 \sWTS \ewrap{\stype_0}{\sexpr_0} : \sshape_0
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_0
    \\
    \fsubt{\sshape_0}{\sshape_1}
  }{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_1
  }

  \inferrule*{
  }{
    \stypeenv_0 \sWTS \serror : \sshape_0
  }
\end{mathpar}

\lbl{\fbox{$\fsubt{\sshape}{\sshape}$}}{\begin{mathpar}
  \inferrule*{
  }{
    \fsubt{\knat}{\kint}
  }

  \inferrule*{
  }{
    \fsubt{\sshape_0}{\kany}
  }
\end{mathpar}}

\lbl{\fbox{$\sshapecheck : \ffun{\stype}{\sshape}$}}{
  \begin{langarray}
    \fshape{\tnat} & \feq & \knat
  \\
    \fshape{\tint} & \feq & \kint
  \\
    \fshape{\tpair{\stype_0}{\stype_1}} & \feq & \kpair
  \\
    \fshape{\tfun{\stype_0}{\stype_1}} & \feq & \kfun
  \end{langarray}
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3ashallowx2dtypex22x29x29}Figure~72: }{t:x28counter_x28x22figurex22_x22figx3abothx3ashallowx2dtypex22x29x29}Shallow typing judgment, subtyping, and shape map}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{mathpar}
  \inferrule*{
    \tann{\svar_0}{\tdyn} \in \stypeenv_0
  }{
    \stypeenv_0 \sWTU \svar_0 : \tdyn
  }

  \inferrule*{
  }{
    \stypeenv_0 \sWTU \sint_0 : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTU \sexpr_0 : \tdyn
    \\
    \stypeenv_0 \sWTU \sexpr_1 : \tdyn
  }{
    \stypeenv_0 \sWTU \epair{\sexpr_0}{\sexpr_1} : \tdyn
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\tdyn}}{\stypeenv_0} \sWTU \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sWTU \efun{\svar_0}{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\sshape_0}}{\stypeenv_0} \sWTS \sexpr_0 : \sshape_1
  }{
    \stypeenv_0 \sWTU \efun{\tann{\svar_0}{\sshape_0}}{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTT \svalue_0 : \stype_0
  }{
    \stypeenv_0 \sWTU \emon{\stype_0}{\svalue_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTU \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sWTU \eunop{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTU \sexpr_0 : \tdyn
    \\
    \stypeenv_0 \sWTU \sexpr_1 : \tdyn
  }{
    \stypeenv_0 \sWTU \ebinop{\sexpr_0}{\sexpr_1} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTU \sexpr_0 : \tdyn
    \\
    \stypeenv_0 \sWTU \sexpr_1 : \tdyn
  }{
    \stypeenv_0 \sWTU \eappu{\sexpr_0}{\sexpr_1} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTU \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sWTU \enoop{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_0
  }{
    \stypeenv_0 \sWTU \enoop{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTU \sexpr_0 : \tdyn
  }{
    \stypeenv_0 \sWTU \escan{\sshape_0}{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTS \sexpr_0 : \sshape_1
  }{
    \stypeenv_0 \sWTU \escan{\sshape_0}{\sexpr_0} : \tdyn
  }

  \inferrule*{
    \stypeenv_0 \sWTT \sexpr_0 : \stype_0
  }{
    \stypeenv_0 \sWTU \ewrap{\stype_0}{\sexpr_0} : \tdyn
  }

  \inferrule*{
  }{
    \stypeenv_0 \sWTU \serror : \tdyn
  }
\end{mathpar}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3auntypedx2dtypex22x29x29}Figure~73: }{t:x28counter_x28x22figurex22_x22figx3abothx3auntypedx2dtypex22x29x29}Untyped typing judgment (dynamic typing)}}\end{FigureMulti}

\Ssubsubsection{Completion}{Completion}\label{t:x28part_x22secx3abothx3amodelx3acompletionx22x29}

A completion pass links the surface and evaluation syntaxes.
The basic goal is to translate module boundaries to appropriate run{-}time
 checks, but other terms may require checks as well.
Formally, the goal is to map all well{-}typed surface expressions to well{-}typed
 evaluation expressions (\relax{\lemmaref{lemma:both:completion}}).
The completion rules shown in \hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3acompletion1x22x29x29]{figures~\FigureRef{74}{t:x28counter_x28x22figurex22_x22figx3abothx3acompletion1x22x29x29}} and \hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3acompletion2x22x29x29]{\FigureRef{75}{t:x28counter_x28x22figurex22_x22figx3abothx3acompletion2x22x29x29}}
 meet this goal via different strategies for each kind of code:


\noindent \begin{itemize}\atItemizeStart

\item In deep{-}typed code, completion inserts wrap expressions at the
 module boundaries to less{-}typed code.
Other deep expressions have no checks.

\item In shallow code, completion scans incoming untyped code and the result
 of every elimination form.

\item In untyped code, completion adds no run{-}time checks.
At the boundaries to deep and shallow code, however, the above
 strategies call for a wrap or scan check.\end{itemize}

\noindent \noindent{}\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3acompletion1x22x29x29]{Figure~\FigureRef{74}{t:x28counter_x28x22figurex22_x22figx3abothx3acompletion1x22x29x29}} in particular shows how surface
 functions translate to evaluation syntax functions and how applications translate.
For deep and untyped code, the completion of an application is simply
 the completion of its subexpressions.
For shallow code, this elimination form requires a scan check to
 validate the result.
Other elimination forms have similar completions.

The completion of a shallow function is deceptively simple.
In a realistic language, such functions would translate to an un{-}annotated
 function that first scans the shape of its input and then proceeds with the
 body expression.
This model, however, gets an implicit domain check thanks to cooperation
 from the upcoming semantics.
The application of a shallow{-}typed function always scans the
 argument before substituting into the function body (chapter~\SecRefLocal{t:x28part_x22secx3abothx3amodelx3areductionx22x29}{6.1.6}{Reduction Relation}).
This design simplifies the model and proof details regarding substitution,
 but the lack of an explicit domain check means that the model cannot
 support a pass that eliminates redundant checks.

\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3acompletion2x22x29x29]{Figure~\FigureRef{75}{t:x28counter_x28x22figurex22_x22figx3abothx3acompletion2x22x29x29}} presents the completion rules for module
 boundaries.
Aside from the self{-}boundaries, the picture in \hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3abasex2dinteractionx22x29x29]{figure~\FigureRef{66}{t:x28counter_x28x22figurex22_x22figx3abothx3abasex2dinteractionx22x29x29}}
 is an accurate summary of these rules.
Each module represents a channel of communication between a context and the inside of the module.
The module declares its type discipline and the context{'}s style is clear
 from the conclusion of the surface typing judgment.
To protect against mis{-}communications, the side with the stronger type requirements
 determines the check that a module boundary completes to.
Deep always directs, shallow wins over untyped, and the others{---}with
 one exception{---}are clear noops.
The exception is for shallow values that exit to untyped code;
 for integers there is nothing to protect, but functions would seem to need
 some kind of wrapper to protect their body against untyped input.
In fact, these boundaries are safe noops because shallow pre{-}emptively
 protects functions as noted above.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{mathpar}
  \inferrule*{
  }{
    \stypeenv_0 \sST \svar_0 : \tdyn \scompile \svar_0
  }

  \inferrule*{
  }{
    \stypeenv_0 \sST \svar_0 : \stype_0 \scompile \svar_0
  }

  \inferrule*{
  }{
    \stypeenv_0 \sST \svar_0 : \tfloor{\stype_0} \scompile \svar_0
  }

%  \inferrule*{
%  }{
%    \stypeenv_0 \sST \sint_0 : \tdyn \scompile \sint_0
%  }
%
%  \inferrule*{
%  }{
%    \stypeenv_0 \sST \sint_0 : \stype_0 \scompile \sint_0
%  }
%
%  \inferrule*{
%  }{
%    \stypeenv_0 \sST \sint_0 : \tfloor{\stype_0} \scompile \sint_0
%  }
%
%  \inferrule*{
%    \stypeenv_0 \sST \sexpr_0 : \tdyn \scompile \sexpr_2
%    \\\\
%    \stypeenv_0 \sST \sexpr_1 : \tdyn \scompile \sexpr_3
%  }{
%    \stypeenv_0 \sST \epair{\sexpr_0}{\sexpr_1} : \tdyn \scompile \epair{\sexpr_2}{\sexpr_3}
%  }
%
%  \inferrule*{
%    \stypeenv_0 \sST \sexpr_0 : \stype_0 \scompile \sexpr_2
%    \\\\
%    \stypeenv_0 \sST \sexpr_1 : \stype_1 \scompile \sexpr_3
%  }{
%    \stypeenv_0 \sST \epair{\sexpr_0}{\sexpr_1} : \tpair{\stype_0}{\stype_1} \scompile \epair{\sexpr_2}{\sexpr_3}
%  }
%
%  \inferrule*{
%    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0} \scompile \sexpr_2
%    \\\\
%    \stypeenv_0 \sST \sexpr_1 : \tfloor{\stype_1} \scompile \sexpr_3
%  }{
%    \stypeenv_0 \sST \epair{\sexpr_0}{\sexpr_1} : \tfloor{\tpair{\stype_0}{\stype_1}} \scompile \epair{\sexpr_2}{\sexpr_3}
%  }
%
  \inferrule*{
    \fcons{\tann{\svar_0}{\tdyn}}{\stypeenv_0} \sST \sexpr_0 : \tdyn \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \efun{\svar_0}{\sexpr_0} : \tdyn \scompile \efun{\svar_0}{\sexpr_1}
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\stype_0}}{\stypeenv_0} \sST \sexpr_0 : \stype_1 \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \efun{\tann{\svar_0}{\stype_0}}{\sexpr_0} : \tfun{\stype_0}{\stype_1} \scompile \efun{\tann{\svar_0}{\stype_0}}{\sexpr_1}
  }

  \inferrule*{
    \fcons{\tann{\svar_0}{\tfloor{\stype_0}}}{\stypeenv_0} \sST \sexpr_0 : \tfloor{\stype_1} \scompile \sexpr_1
    \\
    \fshape{\stype_0} = \sshape_0
  }{
    \stypeenv_0 \sST \efun{\tann{\svar_0}{\tfloor{\stype_0}}}{\sexpr_0} : \tfloor{\tfun{\stype_0}{\stype_1}} \scompile \efun{\tann{\svar_0}{\sshape_0}}{\sexpr_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tdyn \scompile \sexpr_2
    \\\\
    \stypeenv_0 \sST \sexpr_1 : \tdyn \scompile \sexpr_3
  }{
    \stypeenv_0 \sST \eappu{\sexpr_0}{\sexpr_1} : \tdyn \scompile \eappu{\sexpr_2}{\sexpr_3}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfun{\stype_1}{\stype_0} \scompile \sexpr_2
    \\\\
    \stypeenv_0 \sST \sexpr_1 : \stype_1 \scompile \sexpr_3
  }{
    \stypeenv_0 \sST \eappu{\sexpr_0}{\sexpr_1} : \stype_0 \scompile \eappu{\sexpr_2}{\sexpr_3}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\tfun{\stype_1}{\stype_0}} \scompile \sexpr_2
    \\\\
    \stypeenv_0 \sST \sexpr_1 : \tfloor{\stype_1} \scompile \sexpr_3
    \\
    \fshape{\stype_1} = \sshape_0
  }{
    \stypeenv_0 \sST \eappu{\sexpr_0}{\sexpr_1} : \tfloor{\stype_0} \scompile \escan{\sshape_0}{(\eappu{\sexpr_2}{\sexpr_3})}
  }

\end{mathpar}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3acompletion1x22x29x29}Figure~74: }{t:x28counter_x28x22figurex22_x22figx3abothx3acompletion1x22x29x29}Surface{-}to{-}evaluation completion (selected rules)}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{mathpar}
  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tdyn \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \emodule{\sulang}{\sexpr_0} : \tdyn \scompile \enoop{\sexpr_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \stype_0 \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \emodule{\stlang}{\sexpr_0} : \tdyn \scompile \ewrap{\stype_0}{\sexpr_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0} \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \emod{\sslang}{\sexpr_0} : \tdyn \scompile \enoop{\sexpr_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tdyn \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \emodule{\sulang}{\sexpr_0} : \stype_0 \scompile \ewrap{\stype_0}{\sexpr_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \stype_0 \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \emodule{\stlang}{\sexpr_0} : \stype_0 \scompile \enoop{\sexpr_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0} \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \emodule{\sslang}{\sexpr_0} : \stype_0 \scompile \ewrap{\stype_0}{\sexpr_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tdyn \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \emodule{\sulang}{\sexpr_0} : \tfloor{\stype_0} \scompile \escan{\sshape_0}{\sexpr_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \stype_0 \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \emodule{\stlang}{\sexpr_0} : \tfloor{\stype_0} \scompile \ewrap{\stype_0}{\sexpr_1}
  }

  \inferrule*{
    \stypeenv_0 \sST \sexpr_0 : \tfloor{\stype_0} \scompile \sexpr_1
  }{
    \stypeenv_0 \sST \emodule{\sslang}{\sexpr_0} : \tfloor{\stype_0} \scompile \enoop{\sexpr_1}
  }
\end{mathpar}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3acompletion2x22x29x29}Figure~75: }{t:x28counter_x28x22figurex22_x22figx3abothx3acompletion2x22x29x29}Completion for module boundaries}}\end{FigureMulti}

\Ssubsubsection{Reduction Relation}{Reduction Relation}\label{t:x28part_x22secx3abothx3amodelx3areductionx22x29}

The semantics of the evaluation syntax is based on one notion of reduction (\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3arrx22x29x29]{figure~\FigureRef{76}{t:x28counter_x28x22figurex22_x22figx3abothx3arrx22x29x29}}).
Aside from the domain checks for shallow{-}typed functions, reduction proceeds
 in a standard, untyped fashion.
Unary and binary operations proceed according to the \relax{$\sdelta$} metafunction (\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2drrx22x29x29]{figure~\FigureRef{78}{t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2drrx22x29x29}}).
Basic function application substitutes an argument value into a function body.
Wrapped function application decomposes into two wrap boundaries: one
 for the input and another for the result.
Lastly, boundary terms optionally perform a run{-}time check.
A noop boundary performs no check and lets any value cross.
A scan boundary checks the top{-}level shape of a value against the expected
 type.
And a wrap boundary checks top{-}level shapes and either installs a wrapper
 around a higher{-}order value or recursively checks a data structure.

\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2drrx22x29x29]{Figure~\FigureRef{78}{t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2drrx22x29x29}} defines evaluation metafunctions.
The \relax{$\sdelta$} function gives semantics to primitives.
The \relax{$\sshallow$} function matches a type shape against the outer structure of a value.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{rrarray}
  \eunop{\svalue_0} & \snr
  & \stagerror
  \\\sidecond{if $\sdelta(\sunop, \svalue_0)$ is undefined}
  \\[1.0ex]
  \eunop{\svalue_0} & \snr
  & \sdelta(\sunop, \svalue_0)
  \\\sidecond{if $\sdelta(\sunop, \svalue_0)$ is defined}
  \\[1.0ex]
  \ebinop{\svalue_0}{\svalue_1} & \snr
  & \stagerror
  \\\sidecond{if $\sdelta(\sbinop, \svalue_0, \svalue_1)$ is undefined}
  \\[1.0ex]
  \ebinop{\svalue_0}{\svalue_1} & \snr
  & \sdelta(\sbinop, \svalue_0, \svalue_1)
  \\\sidecond{if $\sdelta(\sbinop, \svalue_0, \svalue_1)$ is defined}
  \\[1.0ex]
  \eappu{\svalue_0}{\svalue_1} & \snr &
  \stagerror
  \\\sidecond{if $\svalue_0 \not\in \efun{\svar}{\sexpr} \cup \efun{\tann{\svar}{\stype}}{\sexpr} \cup \efun{\tann{\svar}{\sshape}}{\sexpr} \cup \emon{\stype}{\svalue}$}
  \\[1.0ex]
  \eappu{(\efun{\svar_0}{\sexpr_0})}{\svalue_0} & \snr
  & \esubst{\sexpr_0}{\svar_0}{\svalue_0}
  \\[1.0ex]
  \eappu{(\efun{\tann{\svar_0}{\stype_0}}{\sexpr_0})}{\svalue_0} & \snr
  & \esubst{\sexpr_0}{\svar_0}{\svalue_0}
  \\[1.0ex]
  \eappu{(\efun{\tann{\svar_0}{\sshape_0}}{\sexpr_0})}{\svalue_0} & \snr
  & \sscanerror
  \\\sidecond{if $\neg\fshallow{\sshape_0}{\svalue_0}$}
  \\[1.0ex]
  \eappu{(\efun{\tann{\svar_0}{\sshape_0}}{\sexpr_0})}{\svalue_0} & \snr
  & \esubst{\sexpr_0}{\svar_0}{\svalue_0}
  \\\sidecond{if $\fshallow{\sshape_0}{\svalue_0}$}
  \\[1.0ex]
  \eappu{(\emon{\tfun{\stype_0}{\stype_1}}{\svalue_0})}{\svalue_1} & \snr
  & \ewrap{\stype_1}{(\eappu{\svalue_0}{(\ewrap{\stype_0}{\svalue_1})})}
  \\[1.0ex]
  \enoop{\svalue_0} & \snr
  & \svalue_0
  \\[1.0ex]
  \escan{\sshape_0}{\svalue_0} & \snr
  & \sscanerror
  \\\sidecond{if $\neg\fshallow{\sshape_0}{\svalue_0}$}
  \\[1.0ex]
  \escan{\sshape_0}{\svalue_0} & \snr
  & \svalue_0
  \\\sidecond{if $\fshallow{\sshape_0}{\svalue_0}$}
  \\[1.0ex]
  \ewrap{\stype_0}{\svalue_0} & \snr
  & \swraperror
  \\\sidecond{if $\fshallow{\fshape{\sshape_0}}{\svalue_0}$}
  \\[1.0ex]
  \ewrap{\tfun{\stype_0}{\stype_1}}{\svalue_0} & \snr
  & \emon{\tfun{\stype_0}{\stype_1}}{\svalue_0}
  \\\sidecond{if $\fshallow{\kfun}{\svalue_0}$}
  \\[1.0ex]
  \ewrap{\tpair{\stype_0}{\stype_1}}{\epair{\svalue_0}{\svalue_1}} & \snr
  & \epair{\ewrap{\stype_0}{\svalue_0}}{\ewrap{\stype_1}{\svalue_1}}
  \\[1.0ex]
  \ewrap{\stype_0}{\svalue_0} & \snr
  & \svalue_0
  \\\sidecond{if $\stype_0 \in \tint \cup \tnat$ and $\fshallow{\stype_0}{\svalue_0}$}
\end{rrarray}

\medskip
\lbl{\fbox{\(\sexpr \srr \sexpr\)}\(~~\sdefeq \mbox{reflexive, transitive, compatible closure of $\snr$}\)}{
}
}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3arrx22x29x29}Figure~76: }{t:x28counter_x28x22figurex22_x22figx3abothx3arrx22x29x29}Semantics for the evaluation syntax}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{rrarray}
  \obars{\eunop{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1}
  & \snr
  & \obars{\stagerror}{\sowner_1}
  \\\sidecond{if $\svalue_0 \not\in \obars{\svalue}{\sowner}$ and $\sdelta(\sunop, \svalue_0)$ is undefined}
  \\[1.0ex]
  \obars{\eunop{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1}
  & \snr
  & \obbars{\sdelta(\sunop, \svalue_0)}{\fconcat{\sownerlist_0}{\sowner_1}}
  \\\sidecond{if $\sdelta(\sunop, \svalue_0)$ is defined}
  \\[1.0ex]
  \obars{\ebinop{\obbars{\svalue_0}{\sownerlist_0}}{\obbars{\svalue_1}{\sownerlist_1}}}{\sowner_2}
  & \snr
  & \obars{\stagerror}{\sowner_2}
  \\\sidecond{if $\svalue_i \not\in \obars{\svalue}{\sowner}$ and $\sdelta(\sbinop, \svalue_0, \svalue_1)$ is undefined}
  \\[1.0ex]
  \obars{\ebinop{\obbars{\svalue_0}{\sownerlist_0}}{\obbars{\svalue_1}{\sownerlist_1}}}{\sowner_2}
  & \snr
  & \obars{\sdelta(\sbinop, \svalue_0, \svalue_1)}{\sowner_2}
  \\\sidecond{if $\sdelta(\sbinop, \svalue_0, \svalue_1)$ is defined}
  \\[1.0ex]
  \obars{\eappu{\obbars{\svalue_0}{\sownerlist_0}}{\svalue_1}}{\sowner_1}
  & \snr
  & \obars{\stagerror}{\sowner_1}
  \\\sidecond{if $\svalue_0 \not\in \obars{\svalue}{\sowner} \cup \efun{\svar}{\sexpr} \cup \efun{\tann{\svar}{\stype}}{\sexpr} \cup \efun{\tann{\svar}{\sshape}}{\sexpr} \cup \emon{\stype}{\svalue}$}
  \\[1.0ex]
  \obars{\eappu{\obbars{\efun{\svar_0}{\sexpr_0}}{\sownerlist_0}}{\svalue_0}}{\sowner_1}
  & \snr
  & \obbars{\esubst{\sexpr_0}{\svar_0}{\obbars{\svalue_0}{\fconcat{\sowner_1}{\frev{\sownerlist_0}}}}}{\fconcat{\sownerlist_0}{\sowner_1}}
  \\[1.0ex]
  \obars{\eappu{\obbars{\efun{\tann{\svar_0}{\stype_0}}{\sexpr_0}}{\sownerlist_0}}{\svalue_0}}{\sowner_1}
  & \snr
  & \obbars{\esubst{\sexpr_0}{\svar_0}{\obbars{\svalue_0}{\fconcat{\sowner_1}{\frev{\sownerlist_0}}}}}{\fconcat{\sownerlist_0}{\sowner_1}}
  \\[1.0ex]
  \obars{\eappu{\obbars{\efun{\tann{\svar_0}{\sshape_0}}{\sexpr_0}}{\sownerlist_0}}{\svalue_0}}{\sowner_1}
  & \snr
  & \obars{\sscanerror}{\sowner_1}
  \\\sidecond{if $\neg\fshallow{\sshape_0}{\svalue_0}$}
  \\[1.0ex]
  \obars{\eappu{\obbars{\efun{\tann{\svar_0}{\sshape_0}}{\sexpr_0}}{\sownerlist_0}}{\svalue_0}}{\sowner_1}
  & \snr
  & \obbars{\esubst{\sexpr_0}{\svar_0}{\obbars{\svalue_0}{\fconcat{\sowner_1}{\frev{\sownerlist_0}}}}}{\fconcat{\sownerlist_0}{\sowner_1}}
  \\\sidecond{if $\fshallow{\sshape_0}{\svalue_0}$}
  \\[1.0ex]
  \obars{\eappu{\obbars{\emon{\tfun{\stype_0}{\stype_1}}{\obars{\svalue_0}{\sowner_0}}}{\sownerlist_1}}{\svalue_1}}{\sowner_2}
  & \snr
  \\\sidecond{\qquad\(\obbars{\ewrap{\stype_1}{\obars{\eappu{\svalue_0}{(\ewrap{\stype_0}{\obbars{\svalue_1}{\fconcat{\sowner_2}{\frev{\sownerlist_1}}}})}}{\sowner_0}}}{\fconcat{\sownerlist_1}{\sowner_2}}\)}
  \\[1.0ex]
  \obars{\enoop{\obbars{\svalue_0}}{\sownerlist_0}}{\sowner_1}
  & \snr
  & \obbars{\svalue_0}{\fconcat{\sownerlist_0}{\sowner_1}}
  \\[1.0ex]
  \obars{\escan{\sshape_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1}
  & \snr
  & \obars{\sscanerror}{\sowner_1}
  \\\sidecond{if $\neg\fshallow{\sshape_0}{\svalue_0}$}
  \\[1.0ex]
  \obars{\escan{\sshape_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1}
  & \snr
  & \obbars{\svalue_0}{\fconcat{\sownerlist_0}{\sowner_1}}
  \\\sidecond{if $\fshallow{\sshape_0}{\svalue_0}$}
  \\[1.0ex]
  \obars{\ewrap{\stype_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1}
  & \snr
  & \obars{\swraperror}{\sowner_1}
  \\\sidecond{if $\fshallow{\fshape{\sshape_0}}{\svalue_0}$}
  \\[1.0ex]
  \obars{\ewrap{\tfun{\stype_0}{\stype_1}}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1}
  & \snr
  & \obars{\emon{\tfun{\stype_0}{\stype_1}}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1}
  \\\sidecond{if $\fshallow{\kfun}{\svalue_0}$}
  \\[1.0ex]
  \obars{\ewrap{\tpair{\stype_0}{\stype_1}}{\obbars{\epair{\svalue_0}{\svalue_1}}{\sownerlist_0}}}{\sowner_1}
  & \snr
  \\\sidecond{\qquad\(\obars{\epair{\ewrap{\stype_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\ewrap{\stype_1}{\obbars{\svalue_1}{\sownerlist_0}}}}{\sowner_1}\)}
  \\[1.0ex]
  \obars{\ewrap{\stype_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1}
  & \snr
  & \obars{\svalue_0}{\sowner_1}
  \\\sidecond{if $\stype_0 \in \tint \cup \tnat$ and $\fshallow{\stype_0}{\svalue_0}$}
\end{rrarray}
}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3arrlblx22x29x29}Figure~77: }{t:x28counter_x28x22figurex22_x22figx3abothx3arrlblx22x29x29}Labeled semantics for the evaluation language, derived from \hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3arrx22x29x29]{figure~\FigureRef{76}{t:x28counter_x28x22figurex22_x22figx3abothx3arrx22x29x29}} and the guidelines in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alawsx22x29}{4.4.4.1}{How to lift a reduction relation}.}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{minipage}[t]{0.5\columnwidth}
\lbl{\fbox{$\sdelta : \ffun{\tpair{\sunop}{\svalue}}{\svalue}$}}{
  \begin{langarray}
    \sdelta(\sfst, \epair{\svalue_0}{\svalue_1}) & \feq & \svalue_0
    \\
    \sdelta(\ssnd, \epair{\svalue_0}{\svalue_1}) & \feq & \svalue_1
  \end{langarray}
}

\end{minipage}\begin{minipage}[t]{0.5\columnwidth}
\lbl{\fbox{$\sdelta : \ffun{\tpair{\sbinop}{\tpair{\svalue}{\svalue}}}{\svalue}$}}{
  \begin{langarray}
    \sdelta(\ssum, \sint_0, \sint_1) & \feq & \sint_0 + \sint_1
    \\
    \sdelta(\squotient, \sint_0, 0) & \feq & \divisionbyzeroerror
    \\
    \sdelta(\squotient, \sint_0, \sint_1) & \feq & \floorof{\sint_0 / \sint_1}
  \end{langarray}
}
\end{minipage}

\lbl{\fbox{$\sshallow : \ffun{\tpair{\sshape}{\svalue}}{\fbool}$}}{
  \begin{langarray}
   \fshallow{\kfun}{\svalue_0} & \feq & \ftrue
   \\\sidecond{if $\svalue_0 \in \efun{\svar}{\sexpr} \cup \efun{\tann{\svar}{\stype}}{\sexpr} \cup \efun{\tann{\svar}{\sshape}}{\sexpr} \cup \emon{\stype}{\svalue}$}
   \\[0.8ex]
   \fshallow{\kpair}{\epair{\svalue_0}{\svalue_1}} & \feq & \ftrue
   \\[0.8ex]
   \fshallow{\kint}{\sint_0} & \feq & \ftrue
   \\[0.8ex]
   \fshallow{\knat}{\snat_0} & \feq & \ftrue
   \\[0.8ex]
   \fshallow{\kany}{\svalue_0} & \feq & \ftrue
   \\[0.8ex]
   \fshallow{\sshape_0}{\svalue_0} & \feq & \ffalse
   \\\sidecond{otherwise}
  \end{langarray}
}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2drrx22x29x29}Figure~78: }{t:x28counter_x28x22figurex22_x22figx3abothx3aextrax2drrx22x29x29}Semantic metafunctions}}\end{FigureMulti}

\Ssubsubsection{Single{-}Owner Consistency}{Single{-}Owner Consistency}\label{t:x28part_x22secx3abothx3amodelx3aownershipx22x29}

Deep types are characterized by complete monitoring (chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method}).
To state a complete monitoring theorem, the model needs a labeled syntax,
 a single{-}owner consistency judgment, and a reduction relation that propagates
 labels.

The labeled syntax permits an ownership label around any expression (\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3aownershipx2dsyntaxx22x29x29]{figure~\FigureRef{79}{t:x28counter_x28x22figurex22_x22figx3abothx3aownershipx2dsyntaxx22x29x29}}).
For example, the terms \relax{$\obars{4}{\sowner_0}$} and \relax{$\obars{\eapp{\svar_0}{\svar_1}}{\sowner_1}$}
 illustrate one labeled value and one labeled expression.
Most terms may have zero or more labels.
Boundary terms are an exception;
 a \relax{$\swrap$}, \relax{$\sscan$}, or \relax{$\snoop$} boundary must have at least one label
 around its subexpression.
The notation \relax{$\obbars{\sexpr_0}{\sownerlist_0}$} matches an expressiow with a sequence of labels
 (\relax{$\sownerlist_0$}).

An ownership label \relax{$\sowner_0$} carries two pieces of information.
First is a typing discipline: \relax{$\sdowner$} for deep,
 \relax{$\ssowner$} for shallow, and \relax{$\suowner$} for untyped.
Second is a natural number index to distinguish different labels.
Initially, in a well{-}formed expression, these labels state the original owner
 and typing of a subterm.
As expressions reduce to values and flow across boundaries, labels accumulate
 to show which components are partly responsible for these values.

Ultimately, the goal of our complete monitoring proof effort is to show that
 only deep{-}typed code is responsible for deep{-}typed expressions.
Both shallow and untyped may recklessly share values.
The single{-}owner consistency judgment in \hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3aownershipx2dconsistencyx22x29x29]{figure~\FigureRef{80}{t:x28counter_x28x22figurex22_x22figx3abothx3aownershipx2dconsistencyx22x29x29}}
 formalizes the target invariant by stating when
 an expression is consistent for label \relax{$\sowner_0$} and label environment
 \relax{$\sownerenv_0$}.
A variable must be bound to \relax{$\sowner_0$} in the label environment.
Non{-}boundary terms must have consistent subterms.
Boundary terms and guard wrappers are ownership switch points;
 a boundary is consistent if its subterm is consistent with respect to the
 label inside the boundary.
Finally, the rules for explicitly{-}labeled expressions impose a discipline
 on labels.
A deep{-}labeled expression may have other deep labels, but nothing weaker.
Shallow and untyped{-}labeled expressions, by contrast, can mix together.

Reduction of a labeled expression begins with the rules for the evaluation language
 (\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3arrx22x29x29]{figure~\FigureRef{76}{t:x28counter_x28x22figurex22_x22figx3abothx3arrx22x29x29}}) and propagates labels according to the laws
 stated in chapter~\SecRefLocal{t:x28part_x22secx3adesignx3alawsx22x29}{4.4.4.1}{How to lift a reduction relation}.
\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3arrlblx22x29x29]{Figure~\FigureRef{77}{t:x28counter_x28x22figurex22_x22figx3abothx3arrlblx22x29x29}} presents the rules in full.
In short, labels always accumulate unless a simple value meets a boundary with
 a matching type shape.
Even noop boundaries add a label; this is why ownership consistency allows
 sequences of deep labels.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{langarray}
  \sexpr & \slangeq &
    \svar \mid \svalue \mid \epair{\sexpr}{\sexpr}
    \mid \eunop{\sexpr} \mid
    \ebinop{\sexpr}{\sexpr} \mid \eappu{\sexpr}{\sexpr} \mid \serror \mid
  \\ & &
    \ewrap{\stype}{\obars{\sexpr}{\sowner}}
    \mid \escan{\sshape}{\obars{\sexpr}{\sowner}}
    \mid \enoop{\obars{\sexpr}{\sowner}}
    \mid \obars{\sexpr}{\sowner}
  \\
  \svalue & \slangeq &
    \sint \mid \epair{\svalue}{\svalue}
    \mid \efun{\svar}{\sexpr}
    \mid \efun{\tann{\svar}{\stype}}{\sexpr}
    \mid \efun{\tann{\svar}{\sshape}}{\sexpr}
    \mid \emon{\stype}{\obars{\svalue}{\sowner}}
    \mid \obars{\svalue}{\sowner}
  \\
  \sctx & \slangeq &
    \ldots \mid \obars{\sctx}{\sowner}
  \\
  \sowner & \slangeq &
    \stowner_0 \mid \stowner_1 \mid \ldots \mid
  %\\ & &
    \ssowner_0 \mid \ssowner_1 \mid \ldots \mid
  %\\ & &
    \suowner_0 \mid \suowner_1 \mid \ldots
  \\
  \sownerlist & \slangeq &
    \mbox{sequence of ownership labels ($\sowner$)}
  \\
  \sownerenv & \slangeq &
    \cdot \mid \fcons{\tann{\svar}{\sowner}}{\sownerenv}
\end{langarray}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3aownershipx2dsyntaxx22x29x29}Figure~79: }{t:x28counter_x28x22figurex22_x22figx3abothx3aownershipx2dsyntaxx22x29x29}Ownership syntax}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\relax{\begin{mathpar}
  \inferrule*{
    \tann{\svar_0}{\sowner_0} \in \sownerenv_0
  }{
    \sowner_0; \sownerenv_0 \sWL \svar_0
  }

  \inferrule*{
  }{
    \sowner_0; \sownerenv_0 \sWL \sint_0
  }

  \inferrule*{
    \sowner_0; \sownerenv_0 \sWL \sexpr_0
    \\
    \sowner_0; \sownerenv_0 \sWL \sexpr_1
  }{
    \sowner_0; \sownerenv_0 \sWL \epair{\sexpr_0}{\sexpr_1}
  }

  \inferrule*{
    \sowner_0; \fcons{\tann{\svar_0}{\sowner_0}}{\sownerenv_0} \sWL \sexpr_0
  }{
    \sowner_0; \sownerenv_0 \sWL \efun{\svar_0}{\sexpr_0}
  }

  \inferrule*{
    \sowner_0; \fcons{\tann{\svar_0}{\sowner_0}}{\sownerenv_0} \sWL \sexpr_0
  }{
    \sowner_0; \sownerenv_0 \sWL \efun{\tann{\svar_0}{\sshape_0}}{\sexpr_0}
  }

  \inferrule*{
    \sowner_0; \fcons{\tann{\svar_0}{\sowner_0}}{\sownerenv_0} \sWL \sexpr_0
  }{
    \sowner_0; \sownerenv_0 \sWL \efun{\tann{\svar_0}{\stype_0}}{\sexpr_0}
  }

  \inferrule*{
    \sowner_0; \sownerenv_0 \sWL \sexpr_0
  }{
    \sowner_0; \sownerenv_0 \sWL \eunop{\sexpr_0}
  }

  \inferrule*{
    \sowner_0; \sownerenv_0 \sWL \sexpr_0
    \\
    \sowner_0; \sownerenv_0 \sWL \sexpr_1
  }{
    \sowner_0; \sownerenv_0 \sWL \ebinop{\sexpr_0}{\sexpr_1}
  }

  \inferrule*{
    \sowner_0; \sownerenv_0 \sWL \sexpr_0
    \\
    \sowner_0; \sownerenv_0 \sWL \sexpr_1
  }{
    \sowner_0; \sownerenv_0 \sWL \eappu{\sexpr_0}{\sexpr_1}
  }

  \inferrule*{
  }{
    \sowner_0; \sownerenv_0 \sWL \serror
  }

  \inferrule*{
    \sowner_1; \sownerenv_0 \sWL \sexpr_0
  }{
    \sowner_0; \sownerenv_0 \sWL \enoop{\obars{\sexpr_0}{\sowner_1}}
  }

  \inferrule*{
    \sowner_1; \sownerenv_0 \sWL \sexpr_0
  }{
    \sowner_0; \sownerenv_0 \sWL \escan{\sshape_0}{\obars{\sexpr_0}{\sowner_1}}
  }

  \inferrule*{
    \sowner_1; \sownerenv_0 \sWL \sexpr_0
  }{
    \sowner_0; \sownerenv_0 \sWL \ewrap{\stype_0}{\obars{\sexpr_0}{\sowner_1}}
  }

  \inferrule*{
    \sowner_1; \sownerenv_0 \sWL \svalue_0
  }{
    \sowner_0; \sownerenv_0 \sWL \emon{\stype_0}{\obars{\svalue_0}{\sowner_1}}
  }

  \inferrule*{
    \stowner_1; \sownerenv_0 \sWL \sexpr_0
  }{
    \stowner_0; \sownerenv_0 \sWL \obars{\sexpr_0}{\stowner_1}
  }

  \inferrule*{
    \ssowner_1; \sownerenv_0 \sWL \sexpr_0
  }{
    \ssowner_0; \sownerenv_0 \sWL \obars{\sexpr_0}{\ssowner_1}
  }

  \inferrule*{
    \suowner_0; \sownerenv_0 \sWL \sexpr_0
  }{
    \ssowner_0; \sownerenv_0 \sWL \obars{\sexpr_0}{\suowner_0}
  }

  \inferrule*{
    \suowner_1; \sownerenv_0 \sWL \sexpr_0
  }{
    \suowner_0; \sownerenv_0 \sWL \obars{\sexpr_0}{\suowner_1}
  }

  \inferrule*{
    \ssowner_0; \sownerenv_0 \sWL \sexpr_0
  }{
    \suowner_0; \sownerenv_0 \sWL \obars{\sexpr_0}{\ssowner_0}
  }

\end{mathpar}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3aownershipx2dconsistencyx22x29x29}Figure~80: }{t:x28counter_x28x22figurex22_x22figx3abothx3aownershipx2dconsistencyx22x29x29}Single{-}owner consistency}}\end{FigureMulti}

\Ssubsubsection{Properties}{Properties}\label{t:x28part_x22secx3abothx3amodelx3atheoremsx22x29}

The primary meta{-}theoretic results are about type soundness and
 complete monitoring.
Type soundness predicts the possible outcomes of a well{-}typed expression.
Naturally, these outcomes depend on the {``}strength{''} of the static types;
 for example, untyped code has weaker guarantees than shallow code.
Complete monitoring asks whether single{-}owner consistency is an invariant.

The statement of type soundness relies on one new notation and a family of
 metafunctions.
The notation \relax{$\ssurface_0 \srr \sexpr_0$} defines evaluation for surface
 expressions; the meaning is that \relax{$\ssurface_0$} is well{-}typed somehow
 (\relax{$\fexists{\stspec}{\vdash \ssurface_0 : \stspec}$}),
 compiles to an evaluation expression (\relax{$\vdash \ssurface_0 : \stspec \scompile \sexpr_1$}),
 and then the compiled expression steps to the result (\relax{$\sexpr_1 \srr \sexpr_0$}).
The metafunctions{---}\relax{$\stypemapzero$}, \relax{$\stypemapshape$}, and \relax{$\stypemapone$}{---}map
 surface{-}language types to evaluation types.
One function, \relax{$\stypemapshape$}, extends the similarly{-}name function from
 \hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3ashallowx2dtypex22x29x29]{figure~\FigureRef{72}{t:x28counter_x28x22figurex22_x22figx3abothx3ashallowx2dtypex22x29x29}} to map the unitype \relax{$\tdyn$} to itself.
The others are simple: \relax{$\stypemapzero$} maps all types to \relax{$\tdyn$}
 and \relax{$\stypemapone$} is the identity.
These tools enable a concise, parameterized statement of type soundness.

\relax{\begin{definition}[TS$(\stypemap)$]
  Language\ $\sX$
  satisfies\ $\fTS{\stypemap}$
  if for all\ $\ssurface_0$
  such that\ $\vdash \ssurface_0 : \stspec$
  holds, one of the following holds:
  \begin{itemize}
    \item $\ssurface_0 \srr \svalue_0$ and\ $\sWTX \svalue_0 : \ftypemap{\stspec}$
    \item $\ssurface_0 \srr \serror$
    \item $\ssurface_0 \srr$ diverges
  \end{itemize}
\end{definition}}

\relax{\begin{theorem}[type soundness]\leavevmode
  \begin{itemize}
    \item $\sU$ satisfies\ $\fTS{\stypemapzero}$
    \item $\sS$ satisfies\ $\fTS{\stypemapshape}$
    \item $\sT$ satisfies\ $\fTS{\stypemapone}$
  \end{itemize}
\end{theorem}
\begin{proof}
  \Lemmaref{lemma:both:completion} guarantees that the compiled form
   of the surface expression is well-typed.
  The rest follows from straightforward progress and preservation lemmas for the evaluation typing judgments.
  \Lemmaref{lemma:both:delta} is essential to preservation for primitive operations.
  Lemmas~\ref{lemma:both:su} and~\ref{lemma:both:boundary} are key aspects of preservation for boundary terms.
\end{proof}}

Complete monitoring is technically a statement about labeled expressions
 and a label{-}propagating reduction relation.
But, because the propagating reduction is derived from the basic reduction
 relation in a straightforward manner, our theorem statement uses the
 basic symbol (\relax{$\srr$}).
Likewise, both \relax{$\sexpr_0$} and \relax{$\sexpr_1$} refer to a labeled variant
 of an evaluation{-}language expression.
If no such labeling exist for a term, then the theorem holds vacuously.

\relax{\begin{theorem}[complete monitoring]
  If\ $~\vdash \ssurface_0 : \stspec$
  and\ $\vdash \ssurface_0 : \stspec \scompile \sexpr_0$
  and\ $\sowner_0; \cdot \Vdash \sexpr_0$
  and\ $\sexpr_0 \srr \sexpr_1$
  then\ $\sowner_0; \cdot \Vdash \sexpr_1$.
\end{theorem}
\begin{proof}
  By a preservation argument.
  The proofs for each basic reduction step are sketched below.
  These depend on two metafunctions: $\srev$ reverses a sequence of labels
   and $\slast$ extracts the last (outermost) element of such a sequence.

  \begin{description}
  \item[Case:]
    \(\obars{\eunop{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1} \snr \obars{\stagerror}{\sowner_1}\)
  \item[]
    by the definition, \(\sowner_1; \cdot \sWL \obars{\stagerror}{\sowner_1}\).

  \item[Case:]
    \(\obars{\eunop{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1} \snr \obbars{\sdelta(\sunop, \svalue_0)}{\fconcat{\sownerlist_0}{\sowner_1}}\)
  \subitem
    \begin{enumerate}
    \item
      $\sownerlist_0$ is either all \sdeep{} labels or a mix of \sshallow{} and \suntyped{}, by single-owner consistency of the redex.
    \item
      similarly, $\sowner_1$ must match $\sownerlist_0$
    \item
      $\svalue_0$ is a pair, because $\sdelta$ is defined on it.
    \item
      both components of $\svalue_0$ are well-labeled, again by single-owner consistency on the redex.
    \item
      by the definition of $\sdelta$.
    \end{enumerate}

  \item[Case:]
    \(\obars{\ebinop{\obbars{\svalue_0}{\sownerlist_0}}{\obbars{\svalue_1}{\sownerlist_1}}}{\sowner_2} \snr \obars{\stagerror}{\sowner_2}\)
  \item[]
    by the definition of $\sWL$.

  \item[Case:]
    \(\obars{\ebinop{\obbars{\svalue_0}{\sownerlist_0}}{\obbars{\svalue_1}{\sownerlist_1}}}{\sowner_2} \snr \obars{\sdelta(\sbinop, \svalue_0, \svalue_1)}{\sowner_2}\)
  \item[]
    by the definition of $\sWL$ and $\sdelta$; note that the binary operators are not elimination forms.

  \item[Case:]
    \(\obars{\eappu{\obbars{\svalue_0}{\sownerlist_0}}{\svalue_1}}{\sowner_1} \snr \obars{\stagerror}{\sowner_1}\)
  \item[]
    by the definition of $\sWL$.

  \item[Case:]
    \(\obars{\eappu{\obbars{\efun{\svar_0}{\sexpr_0}}{\sownerlist_0}}{\svalue_0}}{\sowner_1} \snr \obbars{\esubst{\sexpr_0}{\svar_0}{\obbars{\svalue_0}{\fconcat{\sowner_1}{\frev{\sownerlist_0}}}}}{\fconcat{\sownerlist_0}{\sowner_1}}\)
  \subitem
    \begin{enumerate}
    \item\label{step:both:cm:1}
      $\sownerlist_0$ is all \sdeep{} or a mix of \sshallow{} and \suntyped{}, by single-owner consistency of the redex.
    \item\label{step:both:cm:2}
      $\sowner_2; \cdot \sWL \svalue_0$, also by single-owner consistency of the redex.
    \item
      $\flast{\sownerlist_0}; \cdot \sWL \obbars{\svalue_0}{\fconcat{\sowner_1}{\frev{\sownerlist_0}}}$, by steps~\ref{step:both:cm:1} and~\ref{step:both:cm:2}.
    \item
      $\flast{\sownerlist_0}; \cdot \sWL \svar_0$ for each occurrence of $\svar_0$ in $\sexpr_0$, by single-owner consistency of the redex.
    \item
      by a substitution lemma.
    \end{enumerate}

  \item[Case:]
    \(\obars{\eappu{\obbars{\efun{\tann{\svar_0}{\stype_0}}{\sexpr_0}}{\sownerlist_0}}{\svalue_0}}{\sowner_1} \snr \obbars{\esubst{\sexpr_0}{\svar_0}{\obbars{\svalue_0}{\fconcat{\sowner_1}{\frev{\sownerlist_0}}}}}{\fconcat{\sownerlist_0}{\sowner_1}}\)
  \item[]
    similar to the previous case.

  \item[Case:]
    \(\obars{\eappu{\obbars{\efun{\tann{\svar_0}{\sshape_0}}{\sexpr_0}}{\sownerlist_0}}{\svalue_0}}{\sowner_1} \snr \obars{\sscanerror}{\sowner_1}\)
  \item[]
    by the definition of $\sWL$.

  \item[Case:]
    \(\obars{\eappu{\obbars{\efun{\tann{\svar_0}{\sshape_0}}{\sexpr_0}}{\sownerlist_0}}{\svalue_0}}{\sowner_1} \snr \obbars{\esubst{\sexpr_0}{\svar_0}{\obbars{\svalue_0}{\fconcat{\sowner_1}{\frev{\sownerlist_0}}}}}{\fconcat{\sownerlist_0}{\sowner_1}}\)
  \item[]
    similar to the other substitution cases.

  \item[Case:]
    \(\obars{\eappu{\obbars{\emon{\tfun{\stype_0}{\stype_1}}{\obars{\svalue_0}{\sowner_0}}}{\sownerlist_1}}{\svalue_1}}{\sowner_2} \snr\)
    \\\qquad\(\obbars{\ewrap{\stype_1}{\obars{\eappu{\svalue_0}{(\ewrap{\stype_0}{\obbars{\svalue_1}{\fconcat{\sowner_2}{\frev{\sownerlist_1}}}})}}{\sowner_0}}}{\fconcat{\sownerlist_1}{\sowner_2}}\)
  \subitem
    \begin{enumerate}
    \item
      $\sowner_0; \cdot \sWL \svalue_0$, by single-owner consistency of the redex.
    \item
      $\sowner_2; \cdot \sWL \svalue_1$, again by the redex.
    \item
      $\sownerlist_1$ is either all \sdeep{} or a mix of \sshallow{} and \suntyped{}, again by the redex.
    \item
      by the definition of $\sWL$.
    \end{enumerate}

  \item[Case:]
    \(\obars{\enoop{\obbars{\svalue_0}}{\sownerlist_0}}{\sowner_1} \snr \obbars{\svalue_0}{\fconcat{\sownerlist_0}{\sowner_1}}\)
  \item[]
    by the definition of $\scompile$, because a $\snoop{}$ boundary connects either:
     two \sdeep{} components, two \sshallow{} components, two \suntyped{} components, or one \sshallow{} and one \suntyped{} component.

  \item[Case:]
    \(\obars{\escan{\sshape_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1} \snr \obars{\sscanerror}{\sowner_1}\)
  \item[]
    by the definition of $\sWL$.

  \item[Case:]
    \(\obars{\escan{\sshape_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1} \snr \obbars{\svalue_0}{\fconcat{\sownerlist_0}{\sowner_1}}\)
  \item[]
    by the definition of $\scompile$, because a $\sscan{}$ boundary only links an \suntyped{} component to a \sshallow{} component.

  \item[Case:]
    \(\obars{\ewrap{\stype_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1} \snr \obars{\swraperror}{\sowner_1}\)
  \item[]
    by the definition of $\sWL$.

  \item[Case:]
    \(\obars{\ewrap{\tfun{\stype_0}{\stype_1}}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1} \snr \obars{\emon{\tfun{\stype_0}{\stype_1}}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1}\)
  \item[]
    by the definition of $\sWL$.

  \item[Case:]
    \(\obars{\ewrap{\tpair{\stype_0}{\stype_1}}{\obbars{\epair{\svalue_0}{\svalue_1}}{\sownerlist_0}}}{\sowner_1} \snr\)
    \\\qquad\(\obars{\epair{\ewrap{\stype_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\ewrap{\stype_1}{\obbars{\svalue_1}{\sownerlist_0}}}}{\sowner_1}\)
  \item[]
    by the definition of $\sWL$.
    Note that the rule moves the elements of the pair in the redex into a new pair in the contractum.

  \item[Case:]
  \(\obars{\ewrap{\stype_0}{\obbars{\svalue_0}{\sownerlist_0}}}{\sowner_1} \snr \obars{\svalue_0}{\sowner_1}\)
  \\ where $\stype_0 \in \tint \cup \tnat$ and $\fshallow{\stype_0}{\svalue_0}$
  \item[]
    by the definition of $\sWL$.

  \end{description}
\end{proof}}

\relax{\begin{lemma}\label{lemma:both:completion}
  If\ $\vdash \ssurface_0 : \stspec$
  then\ $\vdash \ssurface_0 : \stspec \scompile \sexpr_0$
  and\ $\sWTX \sexpr_0 : \ftypemap{\stspec}$
\end{lemma}}

\relax{\begin{lemma}[$\sdelta, \sDelta$ agreement]\label{lemma:both:delta}\leavevmode
  \begin{itemize}
    \item
      If\ $~\sDelta(\sunop, \tdyn) = \tdyn$
      and\ $\vdash \svalue_0 : \tdyn$
    \item[]
      and\ $\fdefined{\sdelta(\sunop, \svalue_0)}$
      then\ $\vdash \sdelta(\sunop, \svalue_0) : \tdyn$
    \item
      If\ $~\sDelta(\sunop, \sshape_0) = \sshape_1$
      and\ $\vdash \svalue_0 : \sshape_0$
    \item[]
      and\ $\fdefined{\sdelta(\sunop, \svalue_0)}$
      then\ $\vdash \sdelta(\sunop, \svalue_0) : \sshape_1$
    \item
      If\ $~\sDelta(\sbinop, \tdyn, \tdyn) = \tdyn$
      and\ $\vdash \svalue_0 : \tdyn$
      and\ $\vdash \svalue_1 : \tdyn$
    \item[]
      and\ $\fdefined{\sdelta(\sbinop, \svalue_0, \svalue_1)}$
      then\ $\vdash \sdelta(\sbinop, \svalue_0, \svalue_1) : \tdyn$
    \item
      If\ $~\sDelta(\sbinop, \sshape_0, \sshape_1) = \sshape_2$
      and\ $\vdash \svalue_0 : \sshape_0$
      and\ $\vdash \svalue_1 : \sshape_1$
    \item[]
      and\ $\fdefined{\sdelta(\sbinop, \svalue_0, \svalue_1)}$
      then\ $\vdash \sdelta(\sbinop, \svalue_0, \svalue_1) : \sshape_2$
  \end{itemize}
\end{lemma}}

\relax{\begin{lemma}\label{lemma:both:su}
  If\ $\sWTS \sexpr_0 : \sshape_0$
  then\ $\sWTU \sexpr_0 : \tdyn$
\end{lemma}
\begin{proof}
  By definition.
  The key rules are for shape-annotated functions.
\end{proof}}

\relax{\begin{lemma}[boundary-crossing]\label{lemma:both:boundary}\leavevmode
  \begin{itemize}
    \item
      If\ $\vdash \svalue_0 : \stspec$
      and\ $\fshapematch{\sshape_0}{\svalue_0}$
      then\ $\vdash \svalue_0 : \sshape_0$
    \item
      If\ $\vdash \svalue_0 : \sshape_0$
      then\ $\vdash \svalue_0 : \tdyn$
    \item
      If\ $\vdash \svalue_0 : \stype_0$
      and\ $\ewrap{\stype_0}{\svalue_0} \snr \svalue_1$
      then\ $\vdash \svalue_1 : \ftypemapshape{\stype_0}$
      and\ $\vdash \svalue_1 : \tdyn$
  \end{itemize}
\end{lemma}}

\Ssubsection{Implementation}{Implementation}\label{t:x28part_x22secx3abothx3aimplementationx22x29}

The implementation of Shallow Racket begins with two new \Scribtexttt{\#lang}
 languages to communicate the options available to programmers.


\noindent \begin{itemize}\atItemizeStart

\item Modules that start with \Scribtexttt{\#lang typed/racket} continue to use deep types,
 same as earlier versions of Typed Racket;

\item \Scribtexttt{\#lang typed/racket/deep} is a new way to opt{-}in to deep types;

\item and \Scribtexttt{\#lang typed/racket/shallow} provides shallow types.\end{itemize}

\noindent \noindent{}All three languages invoke the same type checker.
At steps where deep and shallow disagree,
 the compiler queries the current language to proceed.
For example, the type{-}directed optimizer checks that it has deep types
 before rewriting code based on the deep soundness guarantee.

Many parts of the modified compiler use a similar, one{-}or{-}the{-}other strategy
 to handle deep and shallow types.
This section deals with the more challenging aspects.
Sharing variables between deep and shallow required changes to
 type{-}lookup and wrapper generation (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aimplx3acodex22x29}{6.2.1}{Deep and Shallow Interaction}).
Sharing macros requires further changes; currently, deep{-}typed syntax can only
 be re{-}used through unsafe mechanisms (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aimplx3acodex22x29}{6.2.1}{Deep and Shallow Interaction}).
Lastly, Typed Racket has a small API that gives programmers control
 over the deep type enforcement strategy.
This API needed generalizations to handle shallow types (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aimplx3atux22x29}{6.2.3}{Deep{--}Untyped Utilities}).

\Ssubsubsection{Deep and Shallow Interaction}{Deep and Shallow Interaction}\label{t:x28part_x22secx3abothx3aimplx3acodex22x29}

Racket supports separate compilation.
Each module in a program gets compiled to a core language individually, and
 other modules can re{-}use the output.
Typed Racket cooperates with the separate compilation protocol by serializing
 the results of type checking.
A well{-}typed module compiles to untyped code (with appropriate contracts)
 and a local type environment.
When one deep module imports from another, it can find the type of the
 imported identifier in the type environment.

At first glance, it appears that shallow code can use the same protocol
 to find the type of deep imports.
The protocol fails, however, because wrappers get in the way.
When deep wants to provide an identifier, it really provides a piece of
 syntax called a rename transformer.
These transformers expand to one of two identifiers depending on where they
 appear: deep{-}typed code gets the original identifier and can easily
 look up its type, but untyped and shallow code gets a wrapped
 version.
The wrapper causes a direct type lookup to fail.

For deep{-}to{-}shallow exports, the solution is to modify
 type lookup to pass through wrappers.
Fortunately, the change was easy to make because the Racket contract library
 provides enough metadata.
At compile time (and only then), a wrapped identifier is associated with
 a structure that links back to the original.
The shallow type checker looks out for these wrappers and uncovers
 the originals as needed.

Shallow{-}to{-}deep exports use a dual method.
Like deep, a shallow module provides only rename transformers.
These expand to the original identifier in other shallow and untyped
 code; the original is associated with type information.
For deep clients, the transformers expand to a wrapped identifier.
Consequently, the deep type checker watches for {``}untyped{''} wrappers and
 tests whether there is an available type.
Such types allow static type checks to succeed, and at run{-}time the wrapper
 keeps deep code safe.

A surprising consequence of the final protocol is that a shallow module must
 be prepared to create wrappers for its exports.
The wrapper{-}making code is generated during compilation, at the end of
 type checking, but it does not run until needed by a deep client.
In this way, only deep code appears to suffer from the expressiveness
 limits of wrappers.

\Ssubsubsection{Syntax Re{-}Use}{Syntax Re{-}Use}\label{t:x28part_x22secx3abothx3aimplx3asyntaxx22x29}

Shallow code cannot use deep macros.
Re{-}use is desirable to avoid copying code, but it requires a static analysis
 to enforce soundness.
This section explains the problem and suggests requirements for a solution.

To appreciate the problem, consider the following simple macro.
This macro applies a a typed function \Scribtexttt{f} to an input, and is consequently
 unsafe:

\raisebox{-0.7999999999999972bp}{\makebox[215.2bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_45.pdf}}}

\noindent{}If this macro could appear in shallow code, then any
 shallow value \Scribtexttt{x} could sneak into the deep function.
Unless \Scribtexttt{f} makes no assumptions about its input, such values can break
 the deep soundness guarantee and lead to dangerous results in optimized
 code.

One possible fix is to put a contract around every deep identifier that
 appears in a macro.
Doing so would require an analysis to find out which contracts are needed,
 and a second analysis to install the contracts (ideally without repeats).
It should also be possible to avoid the contracts if the macro goes only to deep clients.
These are major changes.

Another possibility is to statically check whether a macro is safe to
 export.
Safe macros appear, for example, in the typed compatibility layer for the
 RackUnit testing library.
RackUnit is an untyped library that exports some functions and some macros.
The typed layer provides types for the functions and type{-}annotated copies
 of the macros (about 300 lines in total).
These macros are safe because they do not expose any deep{-}typed identifiers.
For example, the following macro combines a sequence of expressions into
 a named RackUnit test case:

\raisebox{-0.7999999999999972bp}{\makebox[299.20000000000005bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_46.pdf}}}

\noindent{}This macro is safe for shallow code, but for complicated reasons.
First, \Scribtexttt{ensure{-}str} is a typed function that accepts any input.
Second, \Scribtexttt{test{-}begin} is a macro from the same file that is also safe.
Third, \Scribtexttt{parameterize} comes from untyped Racket.

Currently, the author of a deep library can enable syntax re{-}use by disabling the optimizer
 and unsafely providing macros.
This work{-}around requires a manual inspection, but it is more appealing than
 forking the RackUnit library and asking programmers to choose the correct version.

\Ssubsubsection{Deep{--}Untyped Utilities}{Deep{--}Untyped Utilities}\label{t:x28part_x22secx3abothx3aimplx3atux22x29}

Typed Racket has a small API to let programmers control boundaries
 between deep and untyped code.
The API arose over time, as programmers discovered challenges.
Two forms in this API can lead to surprising results due to the existence of
 shallow code.

The first problem concerns \Scribtexttt{require/untyped{-}contract}.
This form lets untyped code import a typed identifier whose precise type
 cannot be expressed with a deep contract.
Users supply a supertype of the precise type and Deep Racket uses this
 weaker type to generate a contract.

For example, the \relax{\textsf{jpeg}} benchmark depends on a library for multi{-}dimensional
 arrays (\href{https://docs.racket-lang.org/math/array.html}{\Scribtexttt{math/array}}).
This library accepts two kinds of data for array indices:
 either a vector of natural numbers or a vector of integers.
Helper functions assert that values with the integer type do not actually
 contain negative numbers using a run{-}time checking function:

\relax{\smallskip}
\raisebox{-0.7999999999999972bp}{\makebox[276.80000000000007bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_47.pdf}}}

\noindent{}Deep contracts cannot express the type for the checking
 function because they lack support for true unions.
The work around is to impose a supertype on untyped clients:

\relax{\smallskip}
\raisebox{-0.0bp}{\makebox[279.20000000000005bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_48.pdf}}}

This form comes with a surprising design choice.
If an untyped{-}contract identifier flows back into typed code,
 the type checker uses the original type rather than the supertype.
For deep code, the choice is convenient because more programs can type{-}check
 using the supertype.
For shallow, though, the convenience disappears.
A shallow client must receive the wrapped version of the identifier,
 which means shallow code must behave in accordance with the supertype;
 hence, the shallow type checker uses the supertype as well.
Consequently, some well{-}typed deep programs raise type errors upon switching
 to shallow types.

The second problematic form is \Scribtexttt{define{-}typed/untyped{-}identifier},
 which creates a new identifier from two old ones.
The following example defines \Scribtexttt{f} from two other names:

\relax{\smallskip}
\raisebox{-0.7999999999999972bp}{\makebox[198.4bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_49.pdf}}}

\noindent{}The meaning of the new \Scribtexttt{f} depends on the context in which it appears.
In typed code, \Scribtexttt{f} expands to \Scribtexttt{typed{-}f}.
In untyped code, an \Scribtexttt{f} is a synonym for \Scribtexttt{untyped{-}f}.

The \Scribtexttt{typed{-}f} is intended for deep{-}typed code.
It cannot be safely used in a shallow module because it may
 assume type invariants.
Consequently, shallow code gets the untyped id.
This means, unfortunately, that changing a deep module to shallow
 can raise a type checking error because occurrences of \Scribtexttt{f} that expand to
 \Scribtexttt{untyped{-}f} are plain, untyped identifiers.
There is no way to uncover the type that a \Scribtexttt{typed{-}f} would have, and
 anyway there is no guarantee that \Scribtexttt{typed{-}f} and \Scribtexttt{untyped{-}f} have
 the same behavior.

For now, such type errors call for programmer{-}supplied annotations in
 the shallow client code.
In the future, this  form would benefit
 from a third argument that specifies behavior in shallow contexts.

\Ssubsection{Evaluation}{Evaluation}\label{t:x28part_x22secx3abothx3aevaluationx22x29}

The integration of Shallow Racket and Deep Racket has implications for
 expressiveness (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aexpressivenessx22x29}{6.3.1}{Expressiveness}) and performance (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aperformancex22x29}{6.3.2}{Performance}).
Switching between these two type{-}enforcement strategies can help programmers
 express new designs and avoid huge performance costs.

\Ssubsubsection{Expressiveness}{Expressiveness}\label{t:x28part_x22secx3abothx3aexpressivenessx22x29}

Conversations with Typed Racket users have shown that deep types can
 lead to unexpected outcomes.
In some programs, type enforcement appears overly strict.
In others, type enforcement is impossible because the implementation of
 Deep Racket lacks wrappers for certain kinds of values.
Worst of all, the wrappers that Deep inserts can change hehavior.
Shallow Racket avoids all of these issues because of its weak, wrapper{-}free
 method of enforcing types.

\Ssubsubsubsectionstarx{Less{-}strict Any Type}{Less{-}strict Any Type}\label{t:x28part_x22Lessx2dstrictx5fAnyx5fTypex22x29}

\begin{SInsetFlow}\emph{Inspired by:}

\noindent \begin{itemize}\atItemizeStart

\item \href{https://groups.google.com/g/racket-users/c/cCQ6dRNybDg/m/CKXgX1PyBgAJ}{\Snolinkurl{groups.google.com/g/racket-users/c/cCQ6dRNybDg/m/CKXgX1PyBgAJ}}

\item \href{https://groups.google.com/g/racket-users/c/jtmVDFCGL28/m/jwl4hsjtBQAJ}{\Snolinkurl{groups.google.com/g/racket-users/c/jtmVDFCGL28/m/jwl4hsjtBQAJ}}\end{itemize}\end{SInsetFlow}

The deep type named \Scribtexttt{Any} is a normal {``}top{''} type at compile{-}time,
 but it is surprisingly strict at run{-}time.
For compile{-}time type checking, \Scribtexttt{Any} is a supertype of every other
 type.
A function that expects an \Scribtexttt{Any} input must ask occurrence{-}typing questions
 before it can do anything to it.
At run{-}time, the \Scribtexttt{Any} type is enforced with an opaque wrapper.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.3999999999999915bp}{\makebox[325.6000000000001bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_50.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3aanyx2dwrapx22x29x29}Figure~81: }{t:x28counter_x28x22figurex22_x22figx3abothx3aanyx2dwrapx22x29x29}Deep seals mutable values of type \Scribtexttt{Any} in a wrapper. Shallow lets untyped code modify the box.}}\end{FigureMulti}

The wrapper is a surprise for developers who expect programs such
 as \hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3aanyx2dwrapx22x29x29]{figure~\FigureRef{81}{t:x28counter_x28x22figurex22_x22figx3abothx3aanyx2dwrapx22x29x29}} to run without error.
This program defines a mutable box in typed code,
 assigns the \Scribtexttt{Any} type to the box,
 and sends it to untyped code.
The untyped module attempts to set the box.
Deep Racket raises an exception when untyped code tries to modify the box.
Unfortunately for the programmer, this error is essential for soundness.
If untyped code put an integer in the box, then typed uses of the
 box would give a result that is inconsistent with its type.

Shallow Racket runs the program without error because of its delayed
 checking strategy.
If shallow{-}typed code tries to read a symbol from the
 box, then that access will raise an error.
Until then, the program runs.

\Ssubsubsubsectionstarx{No Missing Wrappers}{No Missing Wrappers}\label{t:x28part_x22Nox5fMissingx5fWrappersx22x29}

Every kind of mutable value that can appear in deep code needs a kind of
 wrapper to protect it against untyped contexts.
Wrappers do not exist for some values, causing Deep to reject code
 that sends such a value across a boundary.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.3999999999999915bp}{\makebox[320.80000000000007bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_51.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3anox2dwrapx22x29x29}Figure~82: }{t:x28counter_x28x22figurex22_x22figx3abothx3anox2dwrapx22x29x29}Deep lacks wrappers for mutable pairs and a few other datatypes. Shallow does not need wrappers, and can express mixed{-}typed programs that share such values with untyped code.}}\end{FigureMulti}

\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3anox2dwrapx22x29x29]{Figure~\FigureRef{82}{t:x28counter_x28x22figurex22_x22figx3abothx3anox2dwrapx22x29x29}} demonstrates the issue with a mutable pair
 (\Scribtexttt{MPairof}) type.
Deep raises a run{-}time error when untyped code tries to call the \Scribtexttt{add{-}mpair}
 function.
In total, there are twelve types that
 suffer from this issue.
Implementing wrappers for these types is a challenge.
For example, syntax objects can contain mutable data and therefore need wrappers.
But syntax wrappers would require changes to many parts of the Racket compiler,
 including the macro expander.

Shallow Racket avoids the question of wrappers thanks to the Transient
 semantics.
Consequently, programmers gain the ability to send new types across boundaries
 and explore new mixed{-}typed designs.

\Ssubsubsubsectionstarx{Uniform Behavior}{Uniform Behavior}\label{t:x28part_x22Uniformx5fBehaviorx22x29}

\begin{SInsetFlow}\emph{Inspired by:}

\noindent \begin{itemize}\atItemizeStart

\item \href{https://groups.google.com/g/racket-users/c/UD20HadJ9Ec/m/Lmuw0U8mBwAJ}{\Snolinkurl{groups.google.com/g/racket-users/c/UD20HadJ9Ec/m/Lmuw0U8mBwAJ}}

\item \href{https://groups.google.com/g/racket-users/c/ZbYRQCy93dY/m/kF_Ek0VvAQAJ}{\Snolinkurl{groups.google.com/g/racket-users/c/ZbYRQCy93dY/m/kF_Ek0VvAQAJ}}\end{itemize}\end{SInsetFlow}

Although the purpose of Deep Racket wrappers is to reject certain operations
 without changing anything else about a program, wrappers can cause some
 programs to run differently.
One obvious case is code that explicitly looks for wrappers; the answers to
 low{-}level observations such as \Scribtexttt{has{-}contract{\hbox{\texttt{?}}}} may depend on the type
 boundaries in a deep program.
\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3aindexx2dofx22x29x29]{Figure~\FigureRef{83}{t:x28counter_x28x22figurex22_x22figx3abothx3aindexx2dofx22x29x29}} presents a second, more subtle case.
This typed module imports an untyped function, \Scribtexttt{index{-}of}, with a precise
 polymorphic type.
The wrapper that enforces this type
 creates a new wrapper for every input to the function{---}to enforce parametric
 polymorphism\relax{~\citep{gmfk-dls-2007}}.
Unfortunately, these input wrappers change the behavior of \Scribtexttt{index{-}of};
 it ends up searching the list for a wrapped version of the symbol \Scribtexttt{}\Scribtexttt{{'}}\Scribtexttt{a} and returns
 a {``}not found{''} result (\Scribtexttt{\#f}) instead of the correct position.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.19999999999998863bp}{\makebox[153.6bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_52.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3aindexx2dofx22x29x29}Figure~83: }{t:x28counter_x28x22figurex22_x22figx3abothx3aindexx2dofx22x29x29}The deep contract for an \Scribtexttt{All} type can change the behavior of untyped code.}}\end{FigureMulti}

Shallow Racket avoids all such changes in behavior because the Transient
 semantics does not use wrappers to enforce types.

\Ssubsubsection{Performance}{Performance}\label{t:x28part_x22secx3abothx3aperformancex22x29}

With the Shallow Racket implementation, the tradeoffs of chapter~\ChapRefLocal{t:x28part_x22chapx3atransientx22x29}{5}{Shallow Racket} disappear.
For all our benchmarks, the choice improves the worst{-}case overhead of
 type boundaries (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aperfx3aworstx22x29}{6.3.2.1}{GTP Benchmarks, Worst{-}Case}).
By implication, Typed Racket can offer a new migration story:

\begin{SInsetFlow}\emph{use shallow types when converting an untyped application and switch to
deep types after the boundaries stabilize.}\end{SInsetFlow}

Mixing deep and shallow types in one program offers new ways of
 improving performance (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aperfx3abothx22x29}{6.3.2.2}{Case Studies: Deep and Shallow}).

\Ssubsubsubsectionstarx{GTP Benchmarks, Worst{-}Case}{GTP Benchmarks, Worst{-}Case}\label{t:x28part_x22secx3abothx3aperfx3aworstx22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\begin{SCentered}\begin{tabular}[t]{@{}l@{}l@{}r@{}r@{}r@{}r@{}r@{}}
\hbox{Benchmark} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{worst before} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{worst after} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{   improvement} \\
\hline \hbox{\relax{\textsf{sieve}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{15.67x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.36x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3x} \\
\hbox{\relax{\textsf{forth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4010.71x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5.51x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{727x} \\
\hbox{\relax{\textsf{fsm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.38x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.37x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{$<$2x} \\
\hbox{\relax{\textsf{fsmoo}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{451.07x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.28x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{105x} \\
\hbox{\relax{\textsf{mbta}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.92x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.74x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{$<$2x} \\
\hbox{\relax{\textsf{morsecode}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.77x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.47x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{$<$2x} \\
\hbox{\relax{\textsf{zombie}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{54.62x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{31.42x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{$<$2x} \\
\hbox{\relax{\textsf{dungeon}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{14573.66x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.97x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2930x} \\
\hbox{\relax{\textsf{jpeg}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{23.16x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.66x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{13x} \\
\hbox{\relax{\textsf{zordoz}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.75x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.72x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{$<$2x} \\
\hbox{\relax{\textsf{lnm}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.21x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.11x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{$<$2x} \\
\hbox{\relax{\textsf{suffixtree}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{31.17x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5.80x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{5x} \\
\hbox{\relax{\textsf{kcfa}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.43x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.24x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3x} \\
\hbox{\relax{\textsf{snake}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{11.84x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.67x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{$<$2x} \\
\hbox{\relax{\textsf{take5}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{32.17x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2.99x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{10x} \\
\hbox{\relax{\textsf{acquire}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.15x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.42x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{2x} \\
\hbox{\relax{\textsf{tetris}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{11.71x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{9.93x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{$<$2x} \\
\hbox{\relax{\textsf{synth}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{49.12x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{4.20x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{11x} \\
\hbox{\relax{\textsf{gregor}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.63x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{1.59x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{$<$2x} \\
\hbox{\relax{\textsf{quadT}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{27.10x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.39x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{3x} \\
\hbox{\relax{\textsf{quadU}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{59.66x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7.57x} &
\hbox{\mbox{\hphantom{\Scribtexttt{xx}}}} &
\hbox{7x}\end{tabular}\end{SCentered}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3amixedx2dworstx2dtablex22x29x29}Figure~84: }{t:x28counter_x28x22figurex22_x22figx3abothx3amixedx2dworstx2dtablex22x29x29}Worst{-}case overhead before (deep types)
 and after (either deep or shallow)
 the integration of Deep and Shallow Racket.}}\end{FigureMulti}

\noindent Now that Racket programmers can easily switch between deep and shallow
 types, worst{-}case overheads improve by orders of magnitude.
Before, the cost of deep types overwhelmed many configurations.
After, the costs can be avoided by changing the first line (the language specification)
 of the typed modules.

\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3amixedx2dworstx2dtablex22x29x29]{Figure~\FigureRef{84}{t:x28counter_x28x22figurex22_x22figx3abothx3amixedx2dworstx2dtablex22x29x29}} quantifies the improvements in the
 Typed Racket benchmarks.
The first data column reports the old worst{-}case overheads.
The second columns reports the new worst{-}case, now that programmers can
 pick the best of deep and shallow types.
The final column is the quoient between the first two.
In short, the {``}after{''} case is always better and can be an arbitrarily large
 improvement.

\Ssubsubsubsectionstarx{Case Studies: Deep and Shallow}{Case Studies: Deep and Shallow}\label{t:x28part_x22secx3abothx3aperfx3abothx22x29}

Early experience with Shallow Racket shows that the combination of
 deep and shallow types can be better that either alone.
Here are three motivating case studies.

\paragraph{synth}
The \relax{\textsf{synth}} benchmark is derived from \href{http://github.com/stamourv/synth}{an untyped program}
 that interacts with part of a typed math library.
When the library code uses deep types, the original client runs with
 high overhead{---}14x slower that a deep{-}typed client.

Changing the library to use shallow types improves
 the gap between an untyped and deep{-}typed client to
 5x.
This fast untyped configuration is about 2x slower than the fast
 deep{-}deep configuration, but the worst{-}case is 1.39x
 faster (3 seconds) than before.
Overall, the shallow library is a better tradeoff for \relax{\textsf{synth}}.

\paragraph{MsgPack}
\href{http://msgpack.org/}{MessagePack} is a serialization format.
\href{https://gitlab.com/HiPhish/MsgPack.rkt}{MsgPack} is a Typed Racket
 library that maps Racket values to binary data according to the format.
The author of this library
 \href{https://groups.google.com/g/racket-users/c/6KQxpfMLTn0/m/lil_6qSMDAAJ}{reported a performance hit}
 after narrowing some types from \Scribtexttt{Any} to a more{-}precise union type for serializable inputs.
Tests that formerly passed on the package server timed out after the change.

I cloned MsgPack commit \href{https://github.com/HiPhish/MsgPack.rkt/commit/64a60986b149703ff9436877da1dd3e86c6e4094}{\Scribtexttt{64a6098}}
 and found that running all unit tests took 320 seconds.
Changing one file to shallow types brought the time down to 204 seconds{---}a
 huge improvement for a one{-}line switch.
Moving the rest of the library from deep to shallow types adds only a slight
 improvement (down to 202 seconds), which suggests that a mix of deep and
 shallow is best.

\paragraph{External Data}
Typed code that deals with data from an external source is often better off
 with shallow types because they lazily validate data as it is accessed.
By contrast, the deep{-}type guarantee requires a full traversal to validate
 data as soon as it reaches a type boundary.
If the boundary types allow mutable values, then the traversal is even more
 expensive because it creates wrappers as it copies the dataset.

To illustrate the pitfall, I wrote a typed script that reads a large dataset of
 apartment data using on off{-}the{-}shelf JSON parser and accesses one field
 from each object in the dataset.
Deep types make the script run over 10x slower than shallow types.

In principle, deep code can avoid the slowdown with a custom parser
 that validates data as it reads it.
Indeed, Phil Nguyen has written a \href{https://github.com/philnguyen/json-type-provider}{library}
 for JSON that mitigates the overhead of deep types.
Such libraries are ideal, but until we have them for the next data exchange
 format (SQL, XML, YAML, ...) shallow types get the job with the parsers
 that are available today.

\Ssubsubsubsectionstarx{Release Information}{Release Information}\label{t:x28part_x22secx3abothx3aperfx3areleasex22x29}

Shallow Typed Racket is publicly available in a pull request to Typed Racket:
\href{https://github.com/racket/typed-racket/pull/948}{\Scribtexttt{racket/typed{-}racket \#948}}.
I expect to merge the pull request early in 2021.
After the release, I look forward to collecting more anecdotal experiences
 with the system.

\sectionNewpage

\Ssection{Future Work}{Future Work}\label{t:x28part_x22chapx3afuturex22x29}

Now that we have a language that provides deep types via the natural
 semantics and shallow types via the transient one, two lines of
 crucial future work are apparent: improving blame and improving the performance
 of transient.

\Ssubsection{Transient with Blame, Natural without Blame}{Transient with Blame, Natural without Blame}\label{t:x28part_x22Transientx5fwithx5fBlamex5fx5fNaturalx5fwithoutx5fBlamex22x29}

The most surprising result of my research is the
 huge cost of transient blame (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3ablamex2dperformancex22x29}{5.4.4}{Blame Performance}).
Because so many benchmarks run slower with blame than in the worst case
 of deep types, Shallow Racket does not even attempt to track blame.

This result demands a two{-}step investigation.
The first step is to assess the usefulness of the original blame algorithm.
Both user studies and automated analyses\relax{~\citep{lksfd-popl-2020}} can help.
Once the community knows more about what makes blame valuable,
 then the second step is the development of efficient algorithms that are
  tailored to developers{'} needs.

As for deep types, the natural semantics is designed with blame in
 mind.
If blame is not needed, then an alternative semantics could enforce the same type guarantees
 using fewer wrappers.
\relax{\citet{fgsfs-oopsla-2018}} show that removing some wrappers while preserving
 blame behavior leads to better performance.
An implementation could remove many more wrappers if it ignores blame.

\Ssubsubsection{Transient Blame Filtering}{Transient Blame Filtering}\label{t:x28part_x22Transientx5fBlamex5fFilteringx22x29}

My implementation of blame for Shallow Racket makes an effort to filter
 irrelevant boundaries as suggested by \relax{\citet{vss-popl-2017}}.
Filtering, however, is expensive and fails on boundaries that use
 generative struct types (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3ablamex3atypesx22x29}{5.2.6}{Types at Runtime}).
The failure warrants further investigation.
But regardless of whether run{-}time filtering can cover more types,
 we need to measure its usefulness.
If filtering is unlikely to help programmers diagnose issues,
 then removing it can save a tremendous amount of bookkeeping.
Without the need to filter, the blame map does not need to store types or
 actions{---}only pointers and source locations.

\Ssubsection{Fully{-}Typed Transient}{Fully{-}Typed Transient}\label{t:x28part_x22Fullyx2dTypedx5fTransientx22x29}

Despite the large improvement relative to natural, the cost of
 shallow transient types is still high.
The fully{-}typed configurations of the benchmarks make this problem apparent (\hyperref[t:x28counter_x28x22figurex22_x22figx3atransientx3aratiox22x29x29]{figure~\FigureRef{58}{t:x28counter_x28x22figurex22_x22figx3atransientx3aratiox22x29x29}});
 in the worst case, transient is 30x slower than untyped even with type{-}directed optimizations.
Transient needs a way to reduce the cost of shape checks.

\relax{\citet{vsc-dls-2019}} have demonstrated that a whole{-}program static analysis
 and a tracing JIT compiler can greatly improve performance in Reticulated Python.
What remains to be seen is how well a compositional analysis can do, and
 whether the JIT is essential.
Earlier versions of Shallow Racket ran much slower due to redundant checks
 and the overhead of contract library combinators; perhaps further analysis
 and ahead{-}of{-}time optimization can close the gap between fully{-}typed shallow
 and deep.
Starting points for such an analysis include occurrence typing\relax{~\citep{tf-icfp-2010}},
 modular set{-}based analysis\relax{~\citep{mff-popl-2006}}, and Henglein{'}s tagging optimization\relax{~\citep{h-lfp-1992}}.
My investigations in chapter~\ChapRefLocal{t:x28part_x22chapx3atransientx22x29}{5}{Shallow Racket} suggest two additional
 starting points, based on the observation that Shallow Racket checks the
 result of almost every function call that occurs in typed code:


\noindent \begin{itemize}\atItemizeStart

\item The only function calls that are not protected with a shape check have
 the form \Scribtexttt{(f x {\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}})} where the identifier \Scribtexttt{f} appears
 in a trusted environment.
For example, Shallow Racket trusts that calls to \Scribtexttt{map} return
 proper lists.
This approach has major limitations.
Checking identifiers is brittle; an alias to \Scribtexttt{map} defeats the optimization.
Furthermore, the current approach cannot trust deeper properties of a type.
A call to \Scribtexttt{filter}, for example, guarantees the shape of the result
 \emph{and} the shape of every element in the list.
There should be some way to encode this shape knowledge in a type environment,
 rather than a flat identifier environment.

\item Some user{-}defined functions do not need transient result checks.
If a transient module defines a function \Scribtexttt{f = ($\lambda$ (x) {\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}})}
 then there is no need for the current module to check its results
 because static typing guarantees a shape{-}correct output.
Other functions that are defined indirectly, for example by reading
 a function from an untyped list (\Scribtexttt{f = (car f*)}),
 cannot be trusted.\end{itemize}

The Pycket compiler adds a JIT to Deep Typed Racket and significantly
 reduces the overhead of type boundaries\relax{~\citep{bbhkpst-icfp-2015,bbst-oopsla-2017}}.
Adapting this backend to Shallow Racket may reduce costs immediately,
 without the need for an analysis.
In the context of a simpler type system,
\relax{\citet{rmhn-ecoop-2019}} report that a tracing JIT eliminates the cost
 of transient{-}inspired checks in Grace.

\Ssubsection{Improving Deep{--}Transient Interaction}{Improving Deep{--}Transient Interaction}\label{t:x28part_x22secx3afuturex3anonoptx22x29}

The model in chapter~\ChapRefLocal{t:x28part_x22chapx3abothx22x29}{6}{Deep and Shallow, Combined} is safe, but makes deep types expensive.
Every boundary to deep code gets protected with a wrap check (\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3abasex2dinteractionx22x29x29]{figure~\FigureRef{66}{t:x28counter_x28x22figurex22_x22figx3abothx3abasex2dinteractionx22x29x29}}).
For boundaries between deep and untyped this is no surprise, because
 the untyped code is unconstrained.
For shallow code, though, static typing provides some checked claims;
 one would hope to get away with a less expensive check at the boundary.
After all, closed programs that use only deep and shallow code
 need no checks in principle because every line of code is validated by the
 strong surface{-}language type checker.

One possible way to optimize is to weaken the boundary between deep and
 shallow.
Deep can avoid wrapping an export if the value never interacts with untyped
 code going forward.
Likewise, deep can trust an import if the value was never handled or influenced
 by untyped code.
\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3aopt0x22x29x29]{Figure~\FigureRef{85}{t:x28counter_x28x22figurex22_x22figx3abothx3aopt0x22x29x29}} sketches the boundaries that could change via
 this strategy; the deep{--}untyped and shallow{--}untyped boundaries
 are unaffected.
Note, however, that determining whether a value interacts with untyped
 code requires a careful analysis.
Developing a correct analysis that runs quickly is a research challenge in
 itself.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.20000000000000284bp}{\makebox[240.0bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_53.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3aopt0x22x29x29}Figure~85: }{t:x28counter_x28x22figurex22_x22figx3abothx3aopt0x22x29x29}With an escape analysis, the deep{--}shallow boundaries could be weakened.}}\end{FigureMulti}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.20000000000000284bp}{\makebox[320.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict_54.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3abothx3aopt1x22x29x29}Figure~86: }{t:x28counter_x28x22figurex22_x22figx3abothx3aopt1x22x29x29}With an escape analysis and the ability to create wrappers in shallow code, all runtime type checks could be pushed to the boundaries with untyped code.}}\end{FigureMulti}

A second possibility is to make the deep{--}shallow boundary
 a noop by delaying wrappers until a deep value reaches untyped code.
Ideally, this strategy can work with an escape analysis to avoid wrapping
 untyped values that never reach deep code (\hyperref[t:x28counter_x28x22figurex22_x22figx3abothx3aopt1x22x29x29]{figure~\FigureRef{86}{t:x28counter_x28x22figurex22_x22figx3abothx3aopt1x22x29x29}}).
The challenge here is to design an escape analysis and to add wrapper{-}making
 code to shallow without losing the expressiveness that transient gains
 by avoiding wrappers altogether.
For first{-}order interactions,
 Shallow can be careful about the identifiers that it sends to untyped code.
Higher{-}order communication is the real source of difficulties.
For example,
 if shallow imports an untyped map function, then shallow must be
 prepared to wrap every function that it sends to map just in case such a function
 is deep{-}typed.

If a language can create wrappers in shallow code, however, then the
 \relax{\fname} semantics (chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method}) may be a better fit than Transient.
Shallow types via \relax{\fname} do not require shape checks throughout
 typed code, and the 1{-}level wrappers can dynamically cooperate with deep{-}wrapped
 values; that is, the interactions do not require a static analysis
 because the wrappers carry information.

\Ssubsection{Evaluate Alternative Shape Designs}{Evaluate Alternative Shape Designs}\label{t:x28part_x22Evaluatex5fAlternativex5fShapex5fDesignsx22x29}

The shape checks in Shallow Racket enforce full type constructors
 (chapter~\SecRefLocal{t:x28part_x22secx3atransientx3atheoryx3atypesx22x29}{5.1.1}{More{-}Expressive Static Types}).
Other designs are possible, though, and may lead to a better tradeoff
 between type guarantees and performance.

One direction is to strenghten the run{-}time checks to go beyond the outermost type
 constructor.
Some designs may benefit from two or three levels of constructor checks.
In the limit, a transient could enforce all first{-}order properties.

A second alternative is to weaken run{-}time checks for maximal performance.
The current shapes check too much, in the sense that the Typed Racket optimizer
 cannot use all the information.
For example, the Shallow check \Scribtexttt{procedure{\hbox{\texttt{?}}}} does not help any optimizations.
If performance is the only concern, then an implementation can let the dynamically{-}typed
 runtime system handle function applications.

\Ssubsection{Other Challenges}{Other Challenges}\label{t:x28part_x22Otherx5fChallengesx22x29}

\begin{itemize}\atItemizeStart

\item In a performance lattice, an inspection of the configurations with exactly
 one typed unit can reveal the lack of fast paths through the lattice.
Namely, if any of these bottom{-}level configurations suffer high overhead
 then a one{-}by{-}one conversion path is going to suffer similar overhead
 at some step.
Perhaps there are other properties that can be predicted without exploring
 a full lattice.
\relax{\citet{grmhn-vmil-2019}}, for example, suggest that transient slowdowns
 can be diagnosed by studying each typed unit individually.

\item The performance evaluation method begins by toggling types at a
 certain granularity.
The definition of granularity in chapter~\SecRefLocal{t:x28part_x22chapx3aperformancex3adefinitionx22x29}{3.2.2}{By Definition} does not
 allow for imprecise types such as \Scribtexttt{List(Dyn)} and \Scribtexttt{Function([Dyn], Str)}.
Adapting the definition to such types would improve our understanding of
 prior work that randomly generates imprecise types\relax{~\citep{kas-pldi-2019,vsc-dls-2019}}.

\item Design a semantics, \relax{\xsym}, that eagerly checks pairs like the \relax{\nname{}} semantics
 and wraps/unwraps functions like \relax{\fname{}}.
Prove that \relax{\xsym} does not satisfy complete monitoring,
 but can satisfy blame soundness and completeness.
There may be an undiscovered variant of complete monitoring that
 distinguishes this \relax{\xsym} semantics from the basic \relax{\fname{}} semantics,
 which may omit checks on the elements of a pair.

\item Rephrase complete monitoring in semantic terms, using types and observable
 behaviors instead of syntax.

\item The error preorder (\relax{$\sbehaviorle$}) looks like the term precision
 relation (\relax{$\sqle$}) from the gradual typing literature\relax{~\citep{svcb-snapl-2015,nla-popl-2019}}.
To investigate whether there is a deeper connection,
 use the \relax{\nname{}} and \relax{\fname{}} semantics to design two compilers into a core
 language that satisfies graduality.
\relax{\kafka} may be a good starting point\relax{~\citep{clzv-ecoop-2018}}.
Prove that the \relax{\fname{}} compiler always gives less{-}precise expressions according
 to the term precision relation.
Test whether core{-}language term precision can be used to indirectly prove the surface{-}language error preorder.

\item Implement transient blame with multiple parents per link entry.
For operations such as \Scribtexttt{hash{-}ref}, dynamically choose which parent
 to follow.
A language of blame types may be necessary to guide choices.
Measure the quality of errors and the performance cost that results from the
 extra bookkeeping.\end{itemize}

\sectionNewpage

\Ssection{Conclusion}{Conclusion}\label{t:x28part_x22chapx3aconclusionx22x29}

Deep and shallow types can interoperate,
 both in theory and in a practical implementation, and the synthesis brings
 measurable benefits.
The benefits improve all three main dimensions of a mixed{-}typed programming:
\relax{{\renewcommand{\labelitemi}{{\large\decothreeright}} %{\raisebox{0.4ex}{\tiny\(\bullet\)}}
\begin{itemize}
\item \emph{Proofs}\/:
  Switching from \sshallow{} to \sdeep{} types strengthens the formal guarantees
   for a block of code.
  In Typed Racket, a one-line change thus improves types from local spot-checks
   to claims that hold throughout the program, including in untyped modules.
\item\emph{Performance}\/:
  Flipping between \sdeep{} and \sshallow{} can improve performance.
  In fully-typed programs, \sdeep{} types have zero cost---and often run faster
   due to type-directed optimizations.
  In mixed programs, \sshallow{} avoids the tremendous overheads
   of \sdeep{} type boundaries.
\item \emph{People}:
  \sShallow{} types can express new combinations of typed and untyped code
   because they enforce weaker guarantees.
  Programmers can choose between this flexibility and the stability
   of \sdeep{} types as they see fit, for each part of a codebase.
\end{itemize}}}
\noindent{}Integrating deep and shallow within one codebase{---}as
 opposed to picking one or the other{---}improves several concrete examples (chapter~\SecRefLocal{t:x28part_x22secx3abothx3aperfx3abothx22x29}{6.3.2.2}{Case Studies: Deep and Shallow}).
These examples all use shallow types for code that is tightly coupled to
 an untyped boundary and deep types everywhere else.
More experience is likely to reveal other patterns and best practices.
For now, I recommend shallow types when initially converting an untyped
 program.
Once the types are in place and the boundaries are clear,
 then moving from shallow to deep may assist with debugging tasks
 and may improve performance.

The foundations of this work are the methods that I developed to systematically
 measure mixed{-}typed languages.


\noindent \begin{enumerate}\atItemizeStart

\item The performance evaluation methods from (chapter~\ChapRefLocal{t:x28part_x22chapx3aperformancex22x29}{3}{Performance Analysis Method}) offer a comprehensive
 and scalable picture of run{-}time costs.
An exhaustive method summarizes the complete dataset when feasible, and an
 approximate method gives an empirically{-}justified weakening otherwise.

\item The design evaluation method (chapter~\ChapRefLocal{t:x28part_x22chapx3adesignx22x29}{4}{Design Analysis Method}) rigorously assess the strengths
 and weaknesses of static types.
Our application of this method leads to the most precise
 characterization of designs in the literature.\end{enumerate}

Overall, my dissertation brings us closer to useful mixed{-}typed languages.
The step from \emph{untyped{-}or{-}typed} to \emph{mixed{-}typed} has presented a
 serious challenge to the conventional wisdom about static types.
Standard techniques that realize strong guarantees and fast performance in a fully{-}typed
 setting yield weaker guarantees and slower running times in mixed programs.
In the words of one Racket programmer, mixed languages {``}seemed to combine the
 best of both worlds .... but in practice seems to combine mainly the
 downsides{''} because of friction between static and dynamic typing.
Methods and measurements have improved our understanding of the design space
 and articulated the benefits of combining deep and shallow
 types.
With both styles available, programmers can avoid severe roadblocks.
Yet much remains to be done, especially to see how programmers comprehend
 the new types and leverage the new choices.

\relax{\bibliography{bg}}

\postDoc
\end{document}
