\begin{enumerate}
\item Combine deep and shallow migratory typing in a model; formulate and prove safety properties.
\item Implement the model via a Shallow Typed Racket; re-use the Typed Racket type system.
\item Compare the performance of the combined language to Typed Racket + Racket.
\end{enumerate}

\subsection{Challenge 1: Model}

We need a model that combines deep and shallow migratory typing.
The model must allow the definition of deep-typed code, shallow-typed code, and untyped code.
All three must be able to interact.

The primary goal of the model is to state and prove safety properties for each kind of type.
Deep types must be trustworthy in any context.
Shallow types must match the type-tag of values in shallow-typed contexts.
If the safety properties depend on any new extensions, the model must make these clear.
For example, shallow-typed code may need to accept proxied values from deep-typed code.

% primary = implementable?

A secondary goal of the model is to realize safety with few run-time checks.
We plan to identify methods that may (and may not) be used to reduce the necessary run-time checks.
Time-permitting, we plan to explore promising methods in the implementation.


\subsection{Challenge 2: Implementation}

An implementation must validate the model.
Racket is a natural target for such an implementation, because it fully supports deep migratory typing and partially supports shallow migratory typing.
What remains is to extend the partial support for shallow migratory typing and to combine the two styles according to the model.
Time-permitting, we may explore further extensions.


\subsubsection{Primary Goals}

The current partial support for shallow migratory typing must be extended to accomodate all Typed Racket types
 that appear in the functional GTP benchmarks.
Each type needs a matching tag-check.
Some tag-checks are easy to define; for example, the proper tag-check for the \racketcode{Symbol} type is the \racketcode{symbol?} predicate.
Other types present a choice:
 should the check for \racketcode{Listof} ensure a proper list?
 should the check for \racketcode{->*} validate arity and keyword arguments?
We plan to say ``yes'' to both questions, and generally to check all possible first-order properties.

The implementation must avoid the Racket contract library.
Contract combinators have administrative overhead.
Tag-checks must be realized with simple Racket code wherever possible to
improve run-time performance and take advantage of compiler optimizations.

The implementation must support safe interop. with Typed Racket.
Statically, shallow and deep-typed code must be able to share type definitions.
Dynamically, deep-typed code must protect itself against shallow values.
No combination of deep and shallow code can lead to a memory error.

Shallow-typed code must compile efficiently.
Some overhead relative to deep-Typed Racket may arise from the pass that
rewrites typed code.
Anything more than a 10\% slowdown, however, must be studied and explained.


\subsubsection{Secondary Goals}

Add support for class and object types.
These types need a tag check, but there are many question about how deeply such
 checks should explore compatible values.
One idea is to mimic the first-order checks done by the contract system;
 the question is whether those checks suffice for soundness.
% TODO fact-check
%  alt: traverse hierarchy?

Investigate a static analysis to remove tag checks.
Typed Racket employs occurrence typing to propagate information about type-tests.
A tag-check is a simple type test; its success has implications for the rest of
the program.
For example, if a block of code projects an element of an immutable pair twice in a row,
 then only the first projection should go through a tag check.
The completion of this goal requires: the design of a static analysis,
 an implementation within the Typed Racket compiler,
 and an evaluation to test whether the analysis saves time in realistic programs.

Adapt the Typed Racket optimizer.
The current implementation of shallow types is incompatible with the Typed
Racket optimizer.
For one, the implementation outputs code that the optimizer cannot handle.
More significantly, some optimization passes are inappropriate for shallow-typed
code (because the passes rely on deep type information).
Shallow-typed code may still benefit from simple optimizations, however,
so it is worthwhile to try reusing the optimizer.
For example, it may specialize an application of \racketcode{+} to expect unboxed numbers.

Compare performance with and without contracts.
If an early implementation of shallow tag checks relies on the contract library,
then it would be useful to measure the performance delta after removing contracts.
The data would be a useful reference for other clients of the contract library,
and may reveal potential improvements to contracts.


\subsection{Challenge 3: Evaluation}

% - functional subset of GTP benchmarks, possibly OO
% - avoid 3^N analysis because ...
%   well its huge and hard, possibly, to understand b/c 2^N for each node
%   but ok, DON'T make this a stated goal

An evaluation must test the hypothesis that a combination of deep and shallow
 types is better than either one individually.
There are a few ways that a programmer could benefit:
 changing one module from deep to shallow may reduce the cost of type boundaries,
 changing a collection of modules from shallow to deep may remove many tag checks,
 and/or changing a library from deep to shallow may improve the performance of untyped programs.

In particular, we posit that changing the Racket math library to use shallow
types will improve its performance in untyped programs without ``shifting the problem''
to deep-typed clients.
We expect all clients to suffer moderate overhead after the change instead
of the +25x pathologies that programmers currently need to deal with.

We plan to use the GTP benchmark programs in a systematic performance evaluation.
It is unclear, however, how to conduct such an evaluation.

To test the math library, the existing method suffices:
 convert the math library to be shallow-typed and measure the performance lattice.
This same protocol applies to any benchmarks that depend on typed libraries.

To test the benefits for program authors, who now have three choices for every
module, we propose a path-based metric.
First, we assume that authors are seeking fully-typed programs.
Second, we assume that the authors are seeking deep-typed programs.
The question is what percentage of paths through the deep-typed performance
lattice have no configurations that exceed a certain overhead, say 10x, given
the option at each step of converting some modules to shallow types.

The idea is that a programmer moves up the lattice by adding type annotations
to one module.
If, at any step, deep types lead to unacceptable overhead, the programmer can
switch to shallow (since both use the same static types).
Once the programmer has added ``enough'' types, switching back to deep should
offer a performance boost (in addition to the stronger guarantees of deep types).

Both assumptions above threaten the validity of any conclusions we draw from the
evaluation.
Experience with Racket suggests that fully-typed programs are not the norm.
Programmers often end up with partially-typed programs, especially when they
intend to support typed and untyped client programs.
It is also unclear that deep-typing offers the best performance for fully-typed
programs.
There are $2^N$ ways of mixing deep and shallow typing in a fully-typed program;
 without a full evaluation, we cannot be sure that a mixed program out-performs
 the deep version.
If we integrate shallow typing with a variant of the Typed Racket optimizer,
then we plan to validate this second assumption.
